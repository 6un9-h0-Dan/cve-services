
require('dotenv').config()
const CveId = require('../src/model/cve-id')
const CveIdRange = require('../src/model/cve-id-range')
const Org = require('../src/model/org')
const User = require('../src/model/user')
const logger = require('../src/middleware/logger')
const CONSTANTS = require('../src/constants')
const utils = require('../src/utils/utils')
const CONSOLE_OUTPUT = false

// DONE *
async function reserveCveId (req, res) {
  const requester = req.header(CONSTANTS.AUTH_HEADERS.USER)
  const cnaShortName = req.header(CONSTANTS.AUTH_HEADERS.ORG)
  let returned = false
  let batchType
  let amount
  let shortName
  let year

  Object.keys(req.query).forEach(k => {
    const key = k.toLowerCase()

    if (!returned) {
      if (key === 'amount') {
        amount = req.query.amount.replace(/["']/g, '')
      } else if (key === 'batch_type') {
        batchType = req.query.batch_type.replace(/["']/g, '').toLowerCase()
      } else if (key === 'short_name') {
        shortName = req.query.short_name.replace(/["']/g, '').toLowerCase()
      } else if (key === 'cve_year') {
        year = req.query.cve_year.replace(/["']/g, '')
      } else {
        returned = true
        return res.status(400).json({ message: 'Invalid query parameter \'' + key + '\'' })
      }
    }
  })

  const isSecretariat = await utils.isSecretariat(cnaShortName)
  if (cnaShortName !== shortName && !isSecretariat && !returned) {
    returned = true
    return res.status(403).json(CONSTANTS.CNA_CANNOT_RESERVE_FOR_OTHER)
  }

  if (!shortName && !returned) {
    returned = true
    return res.status(400).json(CONSTANTS.NO_CNA_SHORTNAME)
  }

  if (!year && !returned) {
    returned = true
    return res.status(400).json(CONSTANTS.NO_YEAR)
  }

  if (!amount && !returned) {
    returned = true
    return res.status(400).json(CONSTANTS.NO_AMOUNT)
  }

  if (amount <= 0 && !returned) {
    returned = true
    return res.status(400).json(CONSTANTS.INVALID_AMOUNT)
  }

  if (amount > 1 && !batchType && !returned) {
    returned = true
    return res.status(400).json(CONSTANTS.NO_BATCH_TYPE)
  }

  let result
  if (!returned) {
    result = await Org.findOne().byShortName(shortName)

    if (!result) {
      returned = true
      logger.info(shortName + ' CNA does not exist.')
      return res.status(403).json(CONSTANTS.CNA_DNE)
    }
  }

  let payload
  if (!returned) {
    payload = await getPayload(result)

    if (amount > payload.available) {
      returned = true
      CONSTANTS.OVER_ID_QUOTA.details = payload
      return res.status(403).json(CONSTANTS.OVER_ID_QUOTA)
    }
  }

  if (!returned) {
    if (batchType === 'non-sequential' || batchType === 'nonsequential') {
      await nonSequentialReservation(year, amount, shortName, cnaShortName, requester, payload.available, res)
    } else {
      return res.status(400).json(CONSTANTS.INVALID_BATCH_TYPE)
    }
  }
}

// DONE *
async function nonSequentialReservation (year, amount, shortName, cnaShortName, requester, availableIds, res) {
  let isFull = false
  let returned = false
  let available
  amount = parseInt(amount)
  let availableLimit = Math.max(3 * amount, CONSTANTS.DEFAULT_AVAILABLE_POOL)
  let result = await CveIdRange.findOne({ cve_year: year })

  if (CONSOLE_OUTPUT) {
    console.log('amount = ' + amount)
    console.log('availableLimit = ' + availableLimit)
  }

  // Cve Id Range for 'year' does not exists
  if (!result) {
    returned = true
    logger.info('CVE IDs for year ' + year + ' cannot be reserved at this time.')
    res.header(CONSTANTS.QUOTA_HEADER, availableIds)
    return res.status(403).json(CONSTANTS.CANNOT_RESERVE_FOR_YEAR)
  }

  if (!returned) {
    if (CONSOLE_OUTPUT) {
      console.log('available count (uncapped) = ' + (await CveId.find({ cve_year: year, state: 'AVAILABLE' })).length) // get available ids
    }

    available = await CveId.find({ cve_year: year, state: 'AVAILABLE' }).limit(availableLimit) // get available ids

    if (CONSOLE_OUTPUT) {
      console.log('available count (capped) = ' + available.length) // get available ids
    }

    // Case 1: Not enough IDs in the 'AVAILABLE' pool
    if (available.length < availableLimit) {
      result = await incrementNonSequentialPool(availableLimit, result.ranges.general.end, result.ranges.general.top_id, amount, available.length, year)
      isFull = result.isFull
      returned = result.returned

      if (isFull || returned) {
        logger.error('The cve id non-sequential block is full for year ' + year + '. No more sequential ids can be reserved at this time.')
        res.header(CONSTANTS.QUOTA_HEADER, availableIds)
        return res.status(403).json(CONSTANTS.YEAR_RANGE_FULL)
      }

      await allocateAvailableCveIds(result.ids, year) // Pool was incremented. Create 'AVAILABLE' cve ids.

      if (CONSOLE_OUTPUT) {
        console.log('available count (uncapped) = ' + (await CveId.find({ cve_year: year, state: 'AVAILABLE' })).length) // get available ids
      }

      available = await CveId.find({ cve_year: year, state: 'AVAILABLE' }).limit(availableLimit) // get available ids

      if (CONSOLE_OUTPUT) {
        console.log('available count (capped) = ' + available.length) // get available ids
      }
    }
  }

  // Case 2: Enough IDs in the 'AVAILABLE' pool
  let index
  let counter = 0
  let dummyCounter = 0
  const cveIdDocuments = []
  const cveIdDocumentsUUID = []
  const owningOrgUUID = await utils.getOrgUUID(shortName)
  const orgUUID = await utils.getOrgUUID(cnaShortName)
  const requesterUUID = (await User.findOne().byUserNameAndOrgUUID(requester, orgUUID)).UUID

  if (CONSOLE_OUTPUT) {
    console.log('counter = ' + counter)
    console.log('dummyCounter = ' + dummyCounter)
  }

  while ((counter < amount) && (!isFull && !returned)) {
    index = getRandomInt(0, available.length) // get random index in the available array
    result = await reserveNonSequentialCveId(index, available, year, shortName, cnaShortName, requester, owningOrgUUID, orgUUID, requesterUUID, dummyCounter)

    if (CONSOLE_OUTPUT && !result.isReserved) {
      console.log('isReserved: ' + result.isReserved)
    }

    if (result.isReserved) {
      cveIdDocuments.push(result.cveId) // add reserved cve id to the array of reserved cve ids
      cveIdDocumentsUUID.push(result.cveIdUUID) // add reserved cve id UUID to the array of reserved cve ids
      available.splice(index, 1) // remove reserved cve id from the 'AVAILABLE' pool
      counter++

      if (CONSOLE_OUTPUT) {
        console.log('cveIdDocuments: ' + cveIdDocuments.length + ', available: ' + available.length + ', counter = ' + counter)
      }
    } else {
      if (CONSOLE_OUTPUT) {
        console.log('available = ' + available.length)
        console.log('available count (uncapped) = ' + (await CveId.find({ cve_year: year, state: 'AVAILABLE' })).length) // get available ids
      }

      available = await CveId.find({ cve_year: year, state: 'AVAILABLE' }).limit(availableLimit) // get available ids

      if (CONSOLE_OUTPUT) {
        console.log('available count (capped) = ' + available.length) // get available ids
      }

      availableLimit = Math.max(3 * (amount - counter), CONSTANTS.DEFAULT_AVAILABLE_POOL) // recalculate the available limit since some ids might have been reserved

      if (CONSOLE_OUTPUT) {
        console.log('availableLimit = ' + availableLimit)
      }

      // Case 1: Not enough IDs in the 'AVAILABLE' pool
      if (available.length < availableLimit) {
        result = await CveIdRange.findOne({ cve_year: year })
        result = await incrementNonSequentialPool(availableLimit, result.ranges.general.end, result.ranges.general.top_id, amount - counter, available.length, year)
        isFull = result.isFull
        returned = result.returned

        if (isFull || returned) {
          logger.info({ message: 'Only ' + counter + ' cve ids were reserved because there are not enough ids in the CVE ID non-sequential block. Non-sequential CVE IDs were reserved for \'' + shortName + '\' org on behalf of \'' + cnaShortName + '\' org.', cve_ids: cveIdDocumentsUUID })
          const partialError = CONSTANTS.RESERVED_PARTIAL_AMOUNT
          partialError.details = { amount_reserved: counter }
          partialError.cve_ids = cveIdDocuments
          res.header(CONSTANTS.QUOTA_HEADER, availableIds - counter)
          return res.status(206).json(partialError)
        }

        await allocateAvailableCveIds(result.ids, year) // Pool was incremented. Create 'AVAILABLE' cve ids.

        if (CONSOLE_OUTPUT) {
          console.log('available count (uncapped) = ' + (await CveId.find({ cve_year: year, state: 'AVAILABLE' })).length) // get available ids
        }

        available = await CveId.find({ cve_year: year, state: 'AVAILABLE' }).limit(availableLimit) // get available ids

        if (CONSOLE_OUTPUT) {
          console.log('available count (capped) = ' + available.length) // get available ids
        }
      }
    }

    dummyCounter++

    if (CONSOLE_OUTPUT) {
      console.log('dummyCounter = ' + dummyCounter)
    }
  }

  if (!isFull && !returned) {
    logger.info({ message: 'Non-sequential CVE IDs were reserved for \'' + shortName + '\' org on behalf of \'' + cnaShortName + '\' org.', cve_ids: cveIdDocumentsUUID })
    res.header(CONSTANTS.QUOTA_HEADER, availableIds - amount)
    return res.status(200).json({ cve_ids: cveIdDocuments })
  }
}

// DONE
async function incrementNonSequentialPool (availableLimit, end, top, amount, available, year) {
  let increment = availableLimit - available + amount // the amount is the increment amount
  const endRange = parseInt(end)
  const topId = parseInt(top)

  if (CONSOLE_OUTPUT) {
    console.log('increment = ' + increment)
    console.log('endRange = ' + endRange)
    console.log('topId = ' + topId)
  }

  // Cap increment to end of general CVE ID block
  if (endRange < (topId + increment)) {
    increment = endRange - topId
  }

  if (CONSOLE_OUTPUT) {
    console.log('increment = ' + increment)
  }

  const result = {
    isFull: false,
    returned: false,
    ids: null
  }

  if (increment > 0) {
    let r = await CveIdRange.findOneAndUpdate({ $and: [{ cve_year: year }, { 'ranges.general.end': { $gte: increment } }] }, { $inc: { 'ranges.general.top_id': increment } }, { new: true })

    if (CONSOLE_OUTPUT) {
      console.log('top_id = ' + r.ranges.general.top_id)
    }

    // Cap increment because it went over end of general block
    if (r.ranges.general.top_id > endRange) {
      if (CONSOLE_OUTPUT) {
        console.log('increment = ' + increment)
      }

      increment = increment - (r.ranges.general.top_id - endRange) // adjusting real increment
      r = await CveIdRange.findOneAndUpdate({ cve_year: year }, { $set: { 'ranges.general.top_id': endRange } }, { new: true }) // Cap top_id to end of the block

      if (CONSOLE_OUTPUT) {
        console.log('top_id = ' + r.ranges.general.top_id)
      }
    }

    if (CONSOLE_OUTPUT) {
      console.log('increment = ' + increment)
    }

    if (increment > 0) {
      result.ids = generateSequentialIds(year, r.ranges.general.top_id, increment)
    } else if (available < amount) { // You hit the end of the boundary
      result.isFull = true
      result.returned = true
    }
  } else if (available < amount) { // You hit the end of the boundary
    result.isFull = true
    result.returned = true
  }

  return result
}

// DONE *
async function allocateAvailableCveIds (ids, year) {
  if (ids) {
    const cveIdDocuments = []
    let cveId

    ids.forEach(id => {
      cveId = new CveId()
      cveId.cve_id = id
      cveId.cve_year = year
      cveId.state = 'AVAILABLE'
      cveId.owning_cna = 'N/A' // the org who gets assigned the reserved CVE IDs
      cveId.reserved = Date.now()
      cveId.requested_by = {
        cna: 'N/A', // the org who requested the CVE IDs
        user: 'N/A'
      }

      cveIdDocuments.push(cveId)
    })

    if (CONSOLE_OUTPUT) {
      console.log('Allocated ids: [' + cveIdDocuments[0].cve_id + ', ... , ' + cveIdDocuments[cveIdDocuments.length - 1].cve_id + ']')
      console.log('Allocated count = ' + cveIdDocuments.length)
    }

    await CveId.insertMany(cveIdDocuments) // Save the 'AVAILABLE' cve ids
  }
}

// DONE *
async function reserveNonSequentialCveId (index, available, year, shortName, cnaShortName, requester, owningOrgUUID, orgUUID, requesterUUID, dummyCounter) {
  // Update available Cve Id
  const cveIdUUID = new CveId()
  const cveId = new CveId()

  cveIdUUID.cve_id = cveId.cve_id = available[index].cve_id
  cveIdUUID.cve_year = cveId.cve_year = year
  cveIdUUID.state = cveId.state = 'RESERVED'
  cveIdUUID.owning_cna = owningOrgUUID
  cveId.owning_cna = shortName // the org who gets assigned the reserved CVE IDs
  cveIdUUID.reserved = cveId.reserved = Date.now()
  cveIdUUID.requested_by = {
    cna: orgUUID, // the org who requested the CVE IDs
    user: requesterUUID
  }
  cveId.requested_by = {
    cna: cnaShortName, // the org who requested the CVE IDs
    user: requester
  }

  const result = {
    cveId: cveId,
    cveIdUUID: cveIdUUID
  }

  if (dummyCounter === 5) {
    result.isReserved = await CveId.findOneAndUpdate({ cve_id: 'CVE-2888-5465', state: 'AVAILABLE' }, cveIdUUID, { new: true })
  } else {
    result.isReserved = await CveId.findOneAndUpdate({ cve_id: cveIdUUID.cve_id, state: 'AVAILABLE' }, cveIdUUID, { new: true })
  }

  return result
}

// DONE *
async function getPayload (org) {
  const payload = {
    id_quota: org.policies.id_quota
  }

  const result = await CveId.countDocuments({ owning_cna: org.UUID, state: 'RESERVED' })
  payload.total_reserved = result
  payload.available = (payload.id_quota - payload.total_reserved)

  return payload
}

// DONE
function generateSequentialIds (year, topId, increment) {
  const start = topId - increment + 1 // before the pool 'AVAILABLE' pool increment
  const end = topId // after the 'AVAILABLE' pool increment
  const ids = []

  if (CONSOLE_OUTPUT) {
    console.log('start = ' + start)
    console.log('end = ' + end)
  }

  for (let i = start; i < end + 1; i++) {
    ids.push('CVE-' + year + '-' + String(i).padStart(4, '0'))
  }

  if (CONSOLE_OUTPUT) {
    console.log('Generated ids: [' + ids[0] + ', ... , ' + ids[ids.length - 1] + ']')
  }

  return ids
}

// DONE
function getRandomInt (min, max) {
  min = Math.ceil(min)
  max = Math.floor(max)

  return Math.floor(Math.random() * (max - min) + min) // The maximum is exclusive and the minimum is inclusive
}

module.exports = {
  CVEID_RESERVE: reserveCveId
}
