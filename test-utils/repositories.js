// unique name endpoints
// repository per test
// register each endpoint
const RepositoryFactory = require('../src/repositories/repositoryFactory')
const chai = require('chai')
const { existentOrg, existentUser, owningOrg, orgWithNegativeIdQuota, orgExceedingMaxIdQuota, nonExistentOrg, nonExistentUser } = require('../test/unit-tests/org/mockObjects.org')
const expect = chai.expect

/* -------- Org Repositories -------- */
class OrgCreatedWhenUuidUndefined {
    constructor(){}

    async findOneByShortName(shortname) {
        return null
    }

    async updateByOrgUUID(uuid, org, settings) {
        // This is where you can actually write some test assertions!

        // For instance, you can even inspect the settings object to make sure the code passes upsert as true.

        // Or more importantly, you can make sure UUID isn't null or something and you can inspect all the fields on the org object
        // to make sure it's exactly what should be sent to the database.

        // But at a bare minimum, you can simply return null because the code isn't actually inspecting the return here.
        return null
    }

    // Notice that the following two functions are used to get information for logging. We aren't examining the logs in this test,
    // so we can again get by with returning null.
    async getOrgUUID() {
        return null
    }

}

class OrgCreatedWhenUuidNull {
    constructor(){}

    async findOneByShortName(shortname) {
        return null
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgCreatedWhenUuidDefined {
    constructor(){}

    async findOneByShortName(shortname) {
        return null
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgCreatedWhenRolesDefined {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async findOneByShortName(shortname) {
        expect(shortname).to.be.a('string')
        const org = await this.orgRepo.findOneByShortName(shortname)
        expect(org).to.be.a('null')
        return org
    }

    async updateByOrgUUID(uuid, org, settings) {
        expect(settings).to.have.property('upsert').and.to.be.a('boolean')
        await this.orgRepo.updateByOrgUUID(uuid, org, settings)
        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgCreatedWhenRolesUndefinedIdQuotaDefined {
    constructor(){}

    async findOneByShortName(shortname) {
        return null
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgCreatedWhenIdQuotaUndefined {
    constructor(){}

    async findOneByShortName(shortname) {
        return null
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgCreatedWhenIdQuotaNull {
    constructor(){}

    async findOneByShortName(shortname) {
        return null
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgNotCreatedAlreadyExists {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async findOneByShortName(shortname) {
        expect(shortname).to.be.a('string')
        const org = await this.orgRepo.findOneByShortName(shortname)
        expect(org).to.have.property('short_name').and.to.be.a('string')
        return org
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgNotUpdatedDoesNotExist {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async findOneByShortName(shortname) {
        expect(shortname).to.be.a('string')
        const org = await this.orgRepo.findOneByShortName(shortname)
        expect(org).to.be.a('null')
        return org
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgNotUpdatedShortNameExists {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async findOneByShortName(shortname) {
        expect(shortname).to.be.a('string')
        const org = await this.orgRepo.findOneByShortName(shortname)
        expect(org).to.have.property('short_name').and.to.be.a('string')
        return org
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgNotUpdatedIdQuotaUndefined {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async findOneByShortName(shortname) {
        expect(shortname).to.be.a('string')
        const org = await this.orgRepo.findOneByShortName(shortname)
        expect(org).to.have.property('short_name').and.to.be.a('string')
        return org
    }

    async updateByOrgUUID(uuid, org, settings) {
        expect(settings).to.be.an('undefined')
        expect(uuid).to.be.a('string')
        const result = await this.orgRepo.updateByOrgUUID(uuid, org, settings)
        return result
    }

    async getOrgUUID() {
        return null
    }
}

class OrgNotUpdatedNoQueryParameters {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async findOneByShortName(shortname) {
        const org = await this.orgRepo.findOneByShortName(shortname)
        return org
    }

    async updateByOrgUUID(uuid, org, settings) {
        const result = await this.orgRepo.updateByOrgUUID(uuid, org, settings)
        return result
    }

    async getOrgUUID() {
        return null
    }
}

class OrgCantGetDoesNotExist {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async aggregate(aggregation) {
        expect(aggregation).to.be.an('array')
        expect(aggregation[0]).to.have.property('$match')
        const result = await this.orgRepo.aggregate(aggregation)
        return result
    }

    async findOneByShortName(shortname) {
        return null
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgGetDoesExist {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async aggregate(aggregation) {
        expect(aggregation).to.be.an('array')
        expect(aggregation[0]).to.have.property('$match')
        const result = await this.orgRepo.aggregate(aggregation)
        return result
    }

    async findOneByShortName(shortname) {
        return null
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgSecretariatIdQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async isSecretariat(shortname) {
        const res = await this.orgRepo.isSecretariat(shortname)
        expect(res).to.be.a('boolean').and.to.equal(true)
        return res
    }

    async findOneByShortName(shortname) {
        const res = await this.orgRepo.findOneByShortName(shortname)
        expect(res).to.be.an('object')
        return res
    }

    async getOrgUUID(shortname) {
        const res = await this.orgRepo.getOrgUUID(shortname)
        return res
    }
}

class OrgOwnerIdQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async isSecretariat(shortname) {
        const res = await this.orgRepo.isSecretariat(shortname)
        expect(res).to.be.a('boolean').and.to.equal(false)
        return res
    }

    async findOneByShortName(shortname) {
        const res = await this.orgRepo.findOneByShortName(shortname)
        expect(res).to.be.an('object')
        return res
    }

    async getOrgUUID(shortname) {
        const res = await this.orgRepo.getOrgUUID(shortname)
        return res
    }
}

class OrgNotOwnerOrSecretariatIdQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async isSecretariat(shortname) {
        const res = await this.orgRepo.isSecretariat(shortname)
        expect(res).to.be.a('boolean').and.to.equal(false)
        return res
    }

    async findOneByShortName(shortname) {
        return null
    }

    async getOrgUUID(shortname) {
        return null
    }
}

class OrgDoesNotExistIdQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async isSecretariat(shortname) {
        const res = await this.orgRepo.isSecretariat(shortname)
        expect(res).to.be.a('boolean').and.to.equal(true)
        return res
    }

    async findOneByShortName(shortname) {
        const res = await this.orgRepo.findOneByShortName(shortname)
        expect(res).to.be.a('null')
        return res
    }
}

class OrgExceedsMinIdQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async isSecretariat(shortname) {
        const res = await this.orgRepo.isSecretariat(shortname)
        expect(res).to.be.a('boolean').and.to.equal(true)
        return res
    }

    async findOneByShortName(shortname) {
        const res = await this.orgRepo.findOneByShortName(shortname)
        expect(res).to.be.an('object')
        return res
    }

    async getOrgUUID(shortname) {
        const res = await this.orgRepo.getOrgUUID(shortname)
        expect(res).to.equal(orgWithNegativeIdQuota.UUID)
        return res
    }
}

class OrgExceedsMaxIdQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async isSecretariat(shortname) {
        const res = await this.orgRepo.isSecretariat(shortname)
        expect(res).to.be.a('boolean').and.to.equal(true)
        return res
    }

    async findOneByShortName(shortname) {
        const res = await this.orgRepo.findOneByShortName(shortname)
        expect(res).to.be.an('object')
        return res
    }

    async getOrgUUID(shortname) {
        const res = await this.orgRepo.getOrgUUID(shortname)
        expect(res).to.equal(orgExceedingMaxIdQuota.UUID)
        return res
    }
}

class OrgAllCnas {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async aggregate(aggregation) {
        expect(aggregation).to.be.an('array')
        expect(aggregation[0]).to.have.property('$project')
        const result = await this.orgRepo.aggregate(aggregation)
        return result
    }    
}

class OrgCnasDontExist {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async aggregate(aggregation) {
        expect(aggregation).to.be.an('array')
        expect(aggregation[0]).to.have.property('$project')
        const result = await this.orgRepo.aggregate(aggregation)
        return result
    }   
}

class OrgCantCreateUserCnaDoesNotExist {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async getOrgUUID(shortname) {
        expect(shortname).to.be.equal(nonExistentOrg.short_name)
        const res = await this.orgRepo.getOrgUUID(shortname)
        return res
    }
}

class OrgCantCreateUserCnaDoesNotMatch {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async getOrgUUID(shortname) {
        expect(shortname).to.be.equal(existentOrg.short_name)
        const res = await this.orgRepo.getOrgUUID(shortname)
        return res
    }
    
    async findOneByUUID(uuid) {
        expect(uuid).to.be.a('string').and.to.equal(owningOrg.UUID)
        const res = await this.orgRepo.findOneByUUID(uuid)
        return res
    }
}

// This test repo is also used for other tests that pass the same
// values
class OrgCreatedUserOrgUndefined {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async getOrgUUID(shortname) {
        expect(shortname).to.be.equal(existentOrg.short_name)
        const res = await this.orgRepo.getOrgUUID(shortname)
        return res
    }
    
    async findOneByUUID(uuid) {
        expect(uuid).to.equal(existentOrg.UUID)
        const res = await this.orgRepo.findOneByUUID(uuid)
        return res
    }
}

class OrgUserNotUpdatedOrgDoesntExist {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async getOrgUUID(shortname) {
        expect(shortname).to.be.equal(nonExistentOrg.short_name)
        const res = await this.orgRepo.getOrgUUID(shortname)
        return res
    }
}

class OrgUserNotUpdatedUserDoesntExist {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async getOrgUUID(shortname) {
        expect(shortname).to.be.equal(existentOrg.short_name)
        const res = await this.orgRepo.getOrgUUID(shortname)
        return res
    }
}

class OrgUserNotUpdatedOrgQueryDoesntExist {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async getOrgUUID(shortname) {
        expect(shortname).to.be.a('string')
        const res = await this.orgRepo.getOrgUUID(shortname)
        return res
    }
}

class OrgUserSecretNotResetOrgDoesntExist {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async getOrgUUID(shortname) {
        expect(shortname).to.equal(nonExistentOrg.short_name)
        const res = await this.orgRepo.getOrgUUID(shortname)
        return res
    }
}

class OrgUserSecretNotResetUserDoesntExist {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async getOrgUUID(shortname) {
        expect(shortname).to.equal(existentOrg.short_name)
        const res = await this.orgRepo.getOrgUUID(shortname)
        return res
    }
}

class OrgUserSecretReset {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async getOrgUUID(shortname) {
        expect(shortname).to.equal(existentOrg.short_name)
        const res = await this.orgRepo.getOrgUUID(shortname)
        return res
    }
}

class OrgGetUserOrgDoesntExist {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async getOrgUUID(shortname) {
        expect(shortname).to.equal(nonExistentOrg.short_name)
        const res = await this.orgRepo.getOrgUUID(shortname)
        return res
    }
}

class OrgGetUserUserDoesntExist {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async getOrgUUID(shortname) {
        expect(shortname).to.equal(existentOrg.short_name)
        const res = await this.orgRepo.getOrgUUID(shortname)
        return res
    }
}

class OrgGetUser extends OrgGetUserUserDoesntExist {}

/* -------- Cve Id Repositories -------- */
class NullCveIdRepo {
    constructor(){}

    async countDocuments(query) {
        return null
    }
}

class CveIdOwnerIdQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.cveIdRepo = this.repos.getCveIdRepository()
    }

    async countDocuments(query) {
        expect(query).to.have.property('owning_cna').and.to.equal(owningOrg.UUID)
        const res = await this.cveIdRepo.countDocuments(query)
        return res
    }
}

class CveIdSecretariatIdQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.cveIdRepo = this.repos.getCveIdRepository()
    }

    async countDocuments(query) {
        expect(query).to.have.property('owning_cna').and.to.equal(existentOrg.UUID)
        const res = await this.cveIdRepo.countDocuments(query)
        return res
    }
}

class CveIdExceedsMinQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.cveIdRepo = this.repos.getCveIdRepository()
    }

    async countDocuments(query) {
        expect(query).to.have.property('owning_cna').and.to.equal(orgWithNegativeIdQuota.UUID)
        const res = await this.cveIdRepo.countDocuments(query)
        return res
    }
}

class CveIdExceedsMaxQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.cveIdRepo = this.repos.getCveIdRepository()
    }

    async countDocuments(query) {
        expect(query).to.have.property('owning_cna').and.to.equal(orgExceedingMaxIdQuota.UUID)
        const res = await this.cveIdRepo.countDocuments(query)
        return res
    }
}

/* -------- User Repositories -------- */
class NullUserRepo {
    constructor(){}

    async getUserUUID() {
        return null
    }
}

class UserNotCreatedAlreadyExists {
    constructor() {
        this.repos = new RepositoryFactory()
        this.userRepo = this.repos.getUserRepository()
    }

    async findOneByUserNameAndOrgUUID(username, uuid) {
        expect(username).to.equal(existentUser.username)
        expect(uuid).to.be.a('string')
        const res = await this.userRepo.findOneByUserNameAndOrgUUID(username, uuid)
        return res
    }

}

// This test repo is also used for other tests that pass the same
// values
class UserCreatedOrgUndefined {
    constructor() {
        this.repos = new RepositoryFactory()
        this.userRepo = this.repos.getUserRepository()
    }

    async findOneByUserNameAndOrgUUID(username, uuid) {
        expect(username).to.equal(nonExistentUser.username)
        expect(uuid).to.be.a('string')
        const res = await this.userRepo.findOneByUserNameAndOrgUUID(username, uuid)
        return res
    }

    async updateByUserNameAndOrgUUID(username, uuid, user, options) {
        expect(options).to.have.property('upsert').and.to.equal(true)
        expect(username).to.equal(nonExistentUser.username)
        expect(uuid).to.equal(existentOrg.UUID)
        expect(user).to.be.an('object')
        const res = await this.userRepo.updateByUserNameAndOrgUUID(username, uuid, user, options)
        return res
    }
}

class UserNotUpdatedUserDoesntExist {
    constructor() {
        this.repos = new RepositoryFactory()
        this.userRepo = this.repos.getUserRepository()
    }

    async findOneByUserNameAndOrgUUID(username, uuid) {
        expect(username).to.equal(nonExistentUser.username)
        expect(uuid).to.be.a('string')
        const res = await this.userRepo.findOneByUserNameAndOrgUUID(username, uuid)
        return res
    }
}

class UserNotUpdatedOrgQueryDoesntExist {
    constructor() {
        this.repos = new RepositoryFactory()
        this.userRepo = this.repos.getUserRepository()
    }

    async findOneByUserNameAndOrgUUID(username, uuid) {
        expect(username).to.equal(existentUser.username)
        expect(uuid).to.be.a('string')
        const res = await this.userRepo.findOneByUserNameAndOrgUUID(username, uuid)
        return res
    }
    
}

class UserNotUpdatedNoQuery extends UserNotUpdatedOrgQueryDoesntExist {
    async updateByUserNameAndOrgUUID(username, uuid, user, options) {
        expect(options).to.be.an('undefined')
        expect(username).to.equal(existentUser.username)
        expect(uuid).to.equal(existentOrg.UUID)
        expect(user).to.be.an('object')
        const res = await this.userRepo.updateByUserNameAndOrgUUID(username, uuid, user, options)
        return res
    }

    async getUserUUID(user, uuid) {
        expect(uuid).to.be.a('string')
        expect(user).to.be.a('string')
        const res = await this.userRepo.getUserUUID(user, uuid)
        return res
    }

}

class UserSecretNotResetUserDoesntExist {
    constructor() {
        this.repos = new RepositoryFactory()
        this.userRepo = this.repos.getUserRepository()
    }

    async updateByUserNameAndOrgUUID(username, uuid, user, options) {
        expect(options).to.be.an('undefined')
        expect(username).to.equal(nonExistentUser.username)
        expect(uuid).to.equal(existentOrg.UUID)
        expect(user).to.be.an('object')
        const res = await this.userRepo.updateByUserNameAndOrgUUID(username, uuid, user, options)
        return res
    }
}

class UserSecretReset {
    constructor() {
        this.repos = new RepositoryFactory()
        this.userRepo = this.repos.getUserRepository()
    }

    async updateByUserNameAndOrgUUID(username, uuid, user, options) {
        expect(options).to.be.an('undefined')
        expect(username).to.equal(existentUser.username)
        expect(uuid).to.equal(existentOrg.UUID)
        expect(user).to.be.an('object')
        const res = await this.userRepo.updateByUserNameAndOrgUUID(username, uuid, user, options)
        return res
    }

    async getUserUUID(user, uuid) {
        expect(uuid).to.be.a('string')
        expect(user).to.be.a('string')
        const res = await this.userRepo.getUserUUID(user, uuid)
        return res
    }
}

class UserGetUserDoesntExist {
    constructor() {
        this.repos = new RepositoryFactory()
        this.userRepo = this.repos.getUserRepository()
    }

    async aggregate(aggregation) {
        expect(aggregation).to.be.an('array')
        expect(aggregation[0]).to.have.property('$match')
        const res = await this.userRepo.aggregate(aggregation)
        return res
    }
}

class UserGetUser extends UserGetUserDoesntExist {}

module.exports = {
    OrgCreatedWhenUuidUndefined,
    OrgCreatedWhenUuidNull,
    OrgCreatedWhenUuidDefined,
    OrgCreatedWhenRolesDefined,
    OrgCreatedWhenRolesUndefinedIdQuotaDefined,
    OrgCreatedWhenIdQuotaUndefined,
    OrgCreatedWhenIdQuotaNull,
    OrgNotCreatedAlreadyExists,
    OrgNotUpdatedDoesNotExist,
    OrgNotUpdatedShortNameExists,
    OrgNotUpdatedIdQuotaUndefined,
    OrgNotUpdatedNoQueryParameters,
    OrgCantGetDoesNotExist,
    OrgGetDoesExist,
    OrgSecretariatIdQuota,
    OrgOwnerIdQuota,
    OrgNotOwnerOrSecretariatIdQuota,
    OrgDoesNotExistIdQuota,
    OrgExceedsMinIdQuota,
    OrgExceedsMaxIdQuota,
    OrgAllCnas,
    OrgCnasDontExist,
    OrgCantCreateUserCnaDoesNotExist,
    OrgCantCreateUserCnaDoesNotMatch,
    OrgCreatedUserOrgUndefined,
    OrgUserNotUpdatedOrgDoesntExist,
    OrgUserNotUpdatedUserDoesntExist,
    OrgUserNotUpdatedOrgQueryDoesntExist,
    OrgUserSecretNotResetOrgDoesntExist,
    OrgUserSecretNotResetUserDoesntExist,
    OrgUserSecretReset,
    OrgGetUserOrgDoesntExist,
    OrgGetUserUserDoesntExist,
    OrgGetUser,
    NullCveIdRepo,
    CveIdSecretariatIdQuota,
    CveIdOwnerIdQuota,
    CveIdExceedsMinQuota,
    CveIdExceedsMaxQuota,
    NullUserRepo,
    UserCreatedOrgUndefined,
    UserNotCreatedAlreadyExists,
    UserNotUpdatedUserDoesntExist,
    UserNotUpdatedOrgQueryDoesntExist,
    UserNotUpdatedNoQuery,
    UserSecretNotResetUserDoesntExist,
    UserSecretReset,
    UserGetUserDoesntExist,
    UserGetUser,
}
