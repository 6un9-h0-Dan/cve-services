// unique name endpoints
// repository per test
// register each endpoint
const RepositoryFactory = require('../src/repositories/repositoryFactory')
const chai = require('chai')
const { existentOrg, existentUser, owningOrg, orgWithNegativeIdQuota, orgExceedingMaxIdQuota, nonExistentUser } = require('../test/unit-tests/org/mockObjects.org')
const expect = chai.expect
const { cveDummy5, cveId, orgHeader, owningOrgHeader, owningOrgUser, secretariatHeader, cveIdYear, org, cveReserved, cveReject, cvePublic, secretariatOrg, secretariatUser, cveDummy1, cveDummy2, cveDummy3, cveDummy4 } = require('../test/unit-tests/cve-id/mockObjects.cve-id')
const { orgB } = require('../test/unit-tests/cve-id/mockObjects.non-sequential')

/* -------- Org Repositories -------- */
class OrgCreated {
  async findOneByShortName (shortname) {
    return null
  }

  async updateByOrgUUID (uuid, org, settings) {
    // This is where you can actually write some test assertions!
    // For instance, you can even inspect the settings object to make sure the code passes upsert as true.
    // Or more importantly, you can make sure UUID isn't null or something and you can inspect all the fields on the org object
    // to make sure it's exactly what should be sent to the database.
    // But at a bare minimum, you can simply return null because the code isn't actually inspecting the return here.
    return null
  }

  // Notice that the following two functions are used to get information for logging. We aren't examining the logs in this test,
  // so we can again get by with returning null.
  async getOrgUUID () {
    return null
  }
}

class NullOrgRepo {
  async findOneByShortName (shortname) {
    return null
  }

  async updateByOrgUUID (uuid, org, settings) {
    return null
  }

  async getOrgUUID () {
    return null
  }

  async isSecretariat (shortname) {
    return null
  }

  async isSecretariatUUID (uuid) {
    return null
  }
}

class OrgCreatedWhenRolesDefined {
  async findOneByShortName (shortname) {
    return null
  }

  async updateByOrgUUID (uuid, org, settings) {
    expect(settings).to.have.property('upsert').and.to.be.a('boolean')
    expect(uuid).to.be.a('string')
    expect(org).to.be.a('object')
    return null
  }

  async getOrgUUID () {
    return null
  }
}

class OrgNotCreatedAlreadyExists {
  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    return existentOrg // return non-null objects
  }
}

class OrgNotUpdatedDoesNotExist {
  async findOneByShortName (shortname) {
    return null
  }
}

class OrgNotUpdatedShortNameExists {
  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    return existentOrg // return non-null objects
  }
}

class OrgNotUpdatedIdQuotaUndefined {
  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    existentOrg.policies.id_quota = 1000
    return existentOrg // return non-null objects
  }

  async updateByOrgUUID (uuid, org, settings) {
    expect(settings).to.be.an('undefined')
    expect(uuid).to.be.a('string')
    expect(org).to.be.a('object')
    const result = { n: 1 } // TODO: update org object
    return result // return non-null objects
  }

  async getOrgUUID () {
    return null
  }
}

class OrgNotUpdatedNoQueryParameters {
  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(existentOrg.short_name)
    return existentOrg // return non-null objects
  }

  async updateByOrgUUID (uuid, org, settings) {
    expect(settings).to.be.a('undefined')
    expect(uuid).to.be.a('string')
    expect(org).to.be.a('object')
    var result = { n: 1 } // TODO: update org object
    return result // return non-null objects
  }

  async getOrgUUID () {
    return null
  }
}

class OrgGet {
  async aggregate (aggregation) {
    expect(aggregation).to.be.an('array')
    expect(aggregation[0]).to.have.property('$match')
    if (aggregation[0].$match.short_name == existentOrg.short_name) {
      return [existentOrg]
    } else {
      return []
    }
    // return non-null objects
  }
}

class OrgSecretariatIdQuota {
  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    return existentOrg // return non-null objects
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    return existentOrg.UUID // return non-null objects
  }
}

class OrgOwnerIdQuota {
  async isSecretariat (shortname) {
    return false
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    return owningOrg // return non-null objects
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    return owningOrg.UUID // return non-null objects
  }
}

class OrgNotOwnerOrSecretariatIdQuota {
  async isSecretariat (shortname) {
    return false
  }
}

class OrgDoesNotExistIdQuota {
  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    return null
  }
}

class OrgExceedsMinIdQuota {
  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    return orgWithNegativeIdQuota // return non-null objects
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    return orgWithNegativeIdQuota.UUID // return non-null objects
  }
}

class OrgExceedsMaxIdQuota {
  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    return orgExceedingMaxIdQuota // return non-null objects
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    return orgExceedingMaxIdQuota.UUID // return non-null objects
  }
}

class OrgsGet {
  async aggregate (aggregation) {
    expect(aggregation).to.be.an('array')
    expect(aggregation[0]).to.have.property('$project')
    return [0, 1, 2, 3, 4, 5, 6] // return any array of length 7
  }
}

class OrgsCantGet {
  async aggregate (aggregation) {
    expect(aggregation).to.be.an('array')
    expect(aggregation[0]).to.have.property('$project')

    return []
  }
}

class OrgCantCreateUserCnaDoesNotExist {
  async getOrgUUID (shortname) {
    return null
  }
}

class OrgCantCreateUserCnaDoesNotMatch {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.be.equal(existentOrg.short_name)
    return existentOrg.UUID// return non-null objects
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string').and.to.equal(owningOrg.UUID)
    return owningOrg // return non-null objects
  }
}

// This test repo is also used for other tests that pass the same values
class OrgCreatedUserOrgUndefined {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.equal(existentOrg.short_name)
    return existentOrg.UUID // return non-null objects
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string').and.to.equal(existentOrg.UUID)
    return existentOrg // return non-null objects
  }
}

class OrgUserNotUpdatedOrgDoesntExist {
  async getOrgUUID (shortname) {
    return null
  }
}

class OrgUserNotUpdatedUserDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(existentOrg.short_name)
    return existentOrg // non-null objects
  }
}

class OrgUserNotUpdatedOrgQueryDoesntExist {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    if (shortname == existentOrg.short_name) {
      return existentOrg.UUID
    }
    return null
    // return null and non-null objects
  }
}

class OrgUserSecretNotResetOrgDoesntExist {
  async getOrgUUID (shortname) {
    return null
  }
}

class OrgUserSecretNotResetUserDoesntExist {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(existentOrg.short_name)
    return existentOrg.UUID // return non-null objects
  }
}

class OrgUserSecretReset {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(existentOrg.short_name)
    return existentOrg.UUID // return non-null objects
  }
}

class OrgGetUserOrgDoesntExist {
  async getOrgUUID (shortname) {
    return null
  }
}

class OrgGetUser {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(existentOrg.short_name)
    return existentOrg.UUID // return non-null objects
  }
}

class OrgGetUserUpdated {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(org.short_name)
    return org.UUID // return non-null objects
  }
}

class OrgGetCveIdNotOwnerOrgReserved {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(orgHeader['CVE-API-ORG'])
    return org.UUID // return non-null objects
  }

  async isSecretariatUUID (uuid) {
    return false
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    return existentOrg // return non-null objects
  }
}

class OrgGetCveIdNotOwnerOrgNotReserved {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(orgHeader['CVE-API-ORG'])
    return org.UUID // return non-null objects
  }

  async isSecretariatUUID (uuid) {
    return false
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    return owningOrg // return non-null objects
  }
}

class OrgGetCveIdOwningOrg {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(owningOrgHeader['CVE-API-ORG'])
    return owningOrg.UUID // return non-null objects
  }

  async isSecretariatUUID (uuid) {
    return false
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    return owningOrg // return non-null objects
  }
}

class OrgGetCveIdRequestorSecretariat {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(secretariatHeader['CVE-API-ORG'])
    return secretariatOrg.UUID // return non-null objects
  }

  async isSecretariatUUID (uuid) {
    return true
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    if (uuid == secretariatOrg.UUID) {
      return secretariatOrg
    } else {
      return owningOrg
    }
    // return non-null objects
  }
}

class OrgGetCveIdNoCveIdsWithParams {
  async isSecretariat (shortname) {
    return false
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(owningOrgHeader['CVE-API-ORG'])
    return owningOrg.UUID // return non-null objects
  }
}

class OrgGetCveIdRequestorSecretariatNoQuery {

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(secretariatHeader['CVE-API-ORG'])
    return secretariatOrg.UUID // return non-null objects
  }

  async isSecretariat (shortname) {
    return true
  }
}

class OrgGetCveIdRequestedNotChanged {

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(owningOrgHeader['CVE-API-ORG'])
    return owningOrg.UUID // return non-null objects
  }

  async isSecretariat (shortname) {
    return false
  }
}

class OrgModifyCveIdDoesntExist {
  async getOrgUUID (shortname) {
    return null
  }
}

class OrgModifyCveIdCnaDoesntExist {
  async getOrgUUID (shortname) {
    return null
  }
}

class OrgModifyCveIdCnaAndStateModified {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    return org.UUID // return non-null objects
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    if (uuid == org.UUID) {
      return org // return non-null objects
    } else {
      return owningOrg
    }
  }
}

class OrgReserveNotOwningOrg {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return false
  }
}

class OrgReserveShortNameUndefined {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return true
  }
}

class OrgReserveOrgDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    return null
  }
}

class OrgReserveAmountLargerThanNonSequential {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(org.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res // return non-null objects
  }
}
class OrgReserveAmountGreaterIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(org.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }
}

class OrgReserveYear2025RangeDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(owningOrg.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res // return non-null objects
  }
}

class OrgReserveSequentialPriorityIsFull {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return false
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(owningOrg.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res // return non-null objects
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

class OrgReserveSequentialIsFull {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return false
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(owningOrg.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res // return non-null objects
  }
}

class OrgReserveYear2025RangeDoesntExistSequential {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(owningOrg.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res // return non-null objects
  }
}

class OrgReserveUserB10Ids {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return false
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(orgB.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res // return non-null objects
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

class OrgReserveBase {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return false
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res // return non-null objects
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

/* -------- Cve Id Repositories -------- */
class NullCveIdRepo {
  async countDocuments (query) {
    return null
  }
}

class CveIdOwnerIdQuota {

  async countDocuments (query) {
    return 0
  }
}

class CveIdSecretariatIdQuota {

  async countDocuments (query) {
    return 0
  }
}

class CveIdExceedsMinQuota {

  async countDocuments (query) {
    return 0
  }
}

class CveIdExceedsMaxQuota {

  async countDocuments (query) {
    return 0
  }
}

class CveIdGetCveIdDoesntExist {
  async findOneByCveId (id) {
    return null
  }
}

class CveIdGetCveIdAvailable {

  async findOneByCveId (id) {
    expect(id).to.be.a('string').and.to.equal(cveDummy5.cve_id)
    return cveDummy5 // return non-null objects
  }
}

class CveIdGetCveIdNotOwningOrg {
  async findOneByCveId (id) {
    expect(id).to.be.a('string').and.to.equal(cveId)
    return cveReserved // return non-null objects
  }
}

class CveIdGetCveIdNotOwningOrgNotReserved {
  async findOneByCveId (id) {
    expect(id).to.be.a('string').and.to.equal(cveId)
    return cveReject // return non-null objects
  }
}

class CveIdGetCveIdOwningOrg {
  async findOneByCveId (id) {
    expect(id).to.be.a('string').and.to.equal(cveId)
    return cvePublic // return non-null objects
  }
}

class CveIdGetCveIdNoResultsWithParams {
  async aggregate (aggregation) {
    return []
  }
}

class CveIdGetCveIdStateProvided {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    expect(aggregation[0].$match).to.have.property('state').and.to.equal('PUBLIC')
    var testRes = cvePublic
    testRes.requested_by.cna = owningOrg.short_name
    testRes.requested_by.user = owningOrgUser.username
    testRes.owning_cna = owningOrg.short_name
    return [testRes] // return non-null objects
  }
}

class CveIdGetCveIdNoAvailableCves {
  async aggregate (aggregation) {
    return []
  }
}

class CveIdGetCveIdYearProvided {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    expect(aggregation[0].$match).to.have.property('cve_year').and.to.equal(cveIdYear)
    return [cvePublic] // return non-null objects
  }
}

class CveIdGetCveIdNotSecretariatNoQuery {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    var testRes1 = cvePublic
    testRes1.owning_cna = owningOrg.short_name
    testRes1.requested_by.cna = owningOrg.short_name
    testRes1.requested_by.user = owningOrgUser.username
    var testRes2 = cveDummy1
    testRes2.owning_cna = owningOrg.short_name
    testRes2.requested_by.cna = secretariatOrg.short_name
    testRes2.requested_by.user = secretariatUser.username
    return [testRes1, testRes2] // return non-null objects
  }
}

class CveIdGetCveIdSecretariatNoQuery {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    var testRes1 = cvePublic
    testRes1.owning_cna = owningOrg.short_name
    testRes1.requested_by.cna = owningOrg.short_name
    testRes1.requested_by.user = owningOrgUser.username
    var testRes2 = cveDummy1
    testRes2.owning_cna = owningOrg.short_name
    testRes2.requested_by.cna = secretariatOrg.short_name
    testRes2.requested_by.user = secretariatUser.username
    var testRes3 = cveDummy2
    testRes3.owning_cna = secretariatOrg.short_name
    testRes3.requested_by.cna = secretariatOrg.short_name
    testRes3.requested_by.user = secretariatUser.username
    var testRes4 = cveDummy3
    testRes4.owning_cna = secretariatOrg.short_name
    testRes4.requested_by.cna = secretariatOrg.short_name
    testRes4.requested_by.user = secretariatUser.username
    var testRes5 = cveDummy4
    testRes5.owning_cna = org.short_name
    testRes5.requested_by.cna = secretariatOrg.short_name
    testRes5.requested_by.user = secretariatUser.username
    return [testRes1, testRes2, testRes3, testRes4, testRes5] // return non-null objects
  }
}

class CveIdGetCveIdRequestedNotChanged {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    var testRes1 = cvePublic
    var testRes2 = cveDummy1
    return [testRes1, testRes2] // return non-null objects
  }
}

class CveIdModifyCveIdDoesntExist {
  async findOneByCveId (id) {
    return null
  }
}

class CveIdModifyCveIdCnaAndStateModified {
  async findOneByCveId (id) {
    expect(id).to.be.a('string').and.to.equal(cveId)
    return cveReserved // return non-null objects
  }

  async findOneAndUpdate (query, updatedCveId, options) {
    expect(query.cve_id).to.be.a('string').and.to.equal(cveId)
    expect(updatedCveId).to.be.an('object')
    expect(options).to.have.property('new')
    var testRes = updatedCveId
    return testRes // return non-null objects
  }
}

class CveIdModifyCveIdNoQuery {
  async findOneByCveId (id) {
    expect(id).to.be.a('string').and.to.equal(cveId)
    var testRes = cveReject
    testRes.owning_cna = org.UUID
    return testRes // return non-null objects
  }

  async findOneAndUpdate (query, updatedCveId, options) {
    expect(query.cve_id).to.be.a('string').and.to.equal(cveId)
    expect(updatedCveId).to.be.an('object')
    expect(options).to.have.property('new')
    var testRes = updatedCveId
    return testRes // return non-null objects
  }
}

class CveIdReserveSequentialPriorityIsFull {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async insertMany (documents) {
    expect(documents).to.be.an('array')
    const res = await this.cveIdRepo.insertMany(documents)
    expect(documents).to.be.an('array').and.to.have.lengthOf.above(0)
    return res // return non-null objects
  }

  async countDocuments (query) {
    expect(query).to.have.property('owning_cna')
    expect(query).to.have.property('state').and.to.be.equal('RESERVED')
    const res = await this.cveIdRepo.countDocuments(query)
    return res // return different count values
  }
}

class CveIdReservePoolIncremented10Ids {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async insertMany (documents) {
    expect(documents).to.be.an('array')
    const res = await this.cveIdRepo.insertMany(documents)
    expect(documents).to.be.an('array').and.to.have.lengthOf.above(0)
    return res // return non-null objects
  }

  async countDocuments (query) {
    expect(query).to.have.property('owning_cna')
    expect(query).to.have.property('state').and.to.be.equal('RESERVED')
    const res = await this.cveIdRepo.countDocuments(query)
    return res // return different count values
  }

  async find (query, options) {
    expect(options).to.be.an('object').and.to.have.property('limit')
    const res = await this.cveIdRepo.find(query, options)
    return res // return empty and not empty arrays
  }

  async findOneAndUpdate (query, updatedCveId, options) {
    expect(query.cve_id).to.be.a('string')
    expect(updatedCveId).to.be.an('object')
    expect(options).to.have.property('new')
    const res = await this.cveIdRepo.findOneAndUpdate(query, updatedCveId, options)
    expect(res).to.have.property('cve_id').and.to.be.a('string')
    return res // return non-null objects
  }
}

/* -------- Cve Id Range Repositories -------- */
class CveIdRangeReserveYearDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
  }

  async findOne (query) {
    return null
  }
}

class CveIdRangeReserveSequentialPriorityIsFull {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
  }

  async findOne (query) {
    expect(query).to.have.property('cve_year').and.to.be.a('string')
    const res = await this.cveIdRangeRepo.findOne(query)
    expect(res).to.have.property('cve_year').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.be.an('object')
    expect(set).to.be.an('object')
    expect(options).to.be.an('object')
    const res = await this.cveIdRangeRepo.findOneAndUpdate(query, set, options)
    return res // return null and non-null objects
  }
}

class CveIdRangeReserveSequentialIsFull {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
  }

  async findOne (query) {
    return null
  }
}

class CveIdRangeReserveNonSequentialIsFull {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
  }

  async findOne (query) {
    return null
  }
}

class CveIdRange2022NotExists {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
  }

  async findOne (query) {
    return null
  }

  async findOneAndUpdate (query, set, options) {
    await this.cveIdRangeRepo.findOneAndUpdate(query, set, options)
    return null
  }
}

class CveIdRange2022Exists {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
  }

  async findOne (query) {
    expect(query).to.have.property('cve_year').and.to.be.a('string')
    const res = await this.cveIdRangeRepo.findOne(query)
    expect(res).to.have.property('cve_year').and.to.be.a('string')
    return res // return non-null objects
  }
}

/* -------- User Repositories -------- */
class NullUserRepo {
  async getUserUUID () {
    return null
  }
}

class UserNotCreatedAlreadyExists {
  async findOneByUserNameAndOrgUUID (username, uuid) {
    expect(username).to.be.a('string').and.to.equal(existentUser.username)
    expect(uuid).to.be.a('string')
    return existentUser // return non-null objects
  }
}

// This test repo is also used for other tests that pass the same values
class UserCreatedOrgUndefined {
  async findOneByUserNameAndOrgUUID (username, uuid) {
    return null
  }

  async updateByUserNameAndOrgUUID (username, uuid, user, options) {
    expect(options).to.have.property('upsert').and.to.equal(true)
    expect(username).to.equal(nonExistentUser.username)
    expect(uuid).to.equal(existentOrg.UUID)
    expect(user).to.be.an('object')
    return null
  }
}

class UserNotUpdatedUserDoesntExist {
  async findOneByUserNameAndOrgUUID (username, uuid) {
    return null
  }
}

class UserNotUpdatedOrgQueryDoesntExist {
  async findOneByUserNameAndOrgUUID (username, uuid) {
    expect(username).to.be.a('string').and.to.equal(existentUser.username)
    expect(uuid).to.be.a('string')
    return existentUser // return non-null objects
  }
}

class UserNotUpdatedNoQuery {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async findOneByUserNameAndOrgUUID (username, uuid) {
    expect(username).to.be.a('string').and.to.equal(existentUser.username)
    expect(uuid).to.be.a('string')
    return existentUser // return non-null objects
  }

  async updateByUserNameAndOrgUUID (username, uuid, user, options) {
    expect(options).to.be.an('undefined')
    expect(username).to.equal(existentUser.username)
    expect(uuid).to.equal(existentOrg.UUID)
    expect(user).to.be.an('object')
    return { n: 1, nModified: 1, ok: 1 } // return non-null objects
  }

  async getUserUUID (user, uuid) {
    expect(uuid).to.be.a('string')
    expect(user).to.be.a('string')
    return existentUser.UUID // return non-null objects
  }
}

class UserSecretNotResetUserDoesntExist {
  async updateByUserNameAndOrgUUID (username, uuid, user, options) {
    expect(options).to.be.an('undefined')
    expect(username).to.equal(nonExistentUser.username)
    expect(uuid).to.equal(existentOrg.UUID)
    expect(user).to.be.an('object')
    const res = { n: 0, nModified: 0, ok: 1 }
    return res // return non-null objects
  }
}

class UserSecretReset {
  async updateByUserNameAndOrgUUID (username, uuid, user, options) {
    expect(options).to.be.an('undefined')
    expect(username).to.equal(existentUser.username)
    expect(uuid).to.equal(existentOrg.UUID)
    expect(user).to.be.an('object')
    const res = { n: 1, nModified: 1, ok: 1 }
    return res // return non-null objects
  }

  async getUserUUID (user, uuid) {
    expect(uuid).to.be.a('string')
    expect(user).to.be.a('string')
    return existentUser.UUID // return non-null objects
  }
}

class UserGetUser {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    return [existentUser] // return non-null objects
  }
}

class UserGetUserUpdated {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    var testRes = owningOrgUser
    testRes.org_UUID = org.UUID
    return [testRes] // return non-null objects
  }
}

class UserGetUserDoesntExist {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    return []
  }
}

class UserGetCveIdOwningOrg {
  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string').and.to.equal(owningOrgUser.UUID)
    return owningOrgUser // return non-null objects
  }
}

class UserGetCveIdRequestorSecretariat {
  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    if (uuid == secretariatUser.UUID) {
      return secretariatUser
    } else {
      return owningOrgUser
    } // return non-null objects
  }
}

class UserModifyCveIdCnaAndStateModified {
  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    return owningOrgUser // return non-null objects
  }

  async getUserUUID (user, orgUUID) {
    expect(user).to.be.a('string').and.to.equal(secretariatHeader['CVE-API-USER'])
    expect(orgUUID).to.be.a('string')
    return secretariatUser.UUID // return non-null objects
  }
}

class UserReserveSequentialPriorityIsFull {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async findOneByUserNameAndOrgUUID (username, orgUUID) {
    expect(username).to.be.a('string')
    expect(orgUUID).to.be.a('string')
    const res = await this.userRepo.findOneByUserNameAndOrgUUID(username, orgUUID)
    expect(res).to.have.property('username').and.to.be.a('string')
    return res // return non-null objects
  }
}

module.exports = {
  NullOrgRepo,
  OrgCreated,
  OrgCreatedWhenRolesDefined,
  OrgNotCreatedAlreadyExists,
  OrgNotUpdatedDoesNotExist,
  OrgNotUpdatedShortNameExists,
  OrgNotUpdatedIdQuotaUndefined,
  OrgNotUpdatedNoQueryParameters,
  OrgGet,
  OrgSecretariatIdQuota,
  OrgOwnerIdQuota,
  OrgNotOwnerOrSecretariatIdQuota,
  OrgDoesNotExistIdQuota,
  OrgExceedsMinIdQuota,
  OrgExceedsMaxIdQuota,
  OrgsGet,
  OrgsCantGet,
  OrgCantCreateUserCnaDoesNotExist,
  OrgCantCreateUserCnaDoesNotMatch,
  OrgCreatedUserOrgUndefined,
  OrgUserNotUpdatedOrgDoesntExist,
  OrgUserNotUpdatedUserDoesntExist,
  OrgUserNotUpdatedOrgQueryDoesntExist,
  OrgUserSecretNotResetOrgDoesntExist,
  OrgUserSecretNotResetUserDoesntExist,
  OrgUserSecretReset,
  OrgGetUserOrgDoesntExist,
  OrgGetUser,
  OrgGetUserUpdated,
  OrgGetCveIdNotOwnerOrgNotReserved,
  OrgGetCveIdNotOwnerOrgReserved,
  OrgGetCveIdOwningOrg,
  OrgGetCveIdRequestorSecretariat,
  OrgGetCveIdNoCveIdsWithParams,
  OrgGetCveIdRequestorSecretariatNoQuery,
  OrgGetCveIdRequestedNotChanged,
  OrgModifyCveIdDoesntExist,
  OrgModifyCveIdCnaDoesntExist,
  OrgModifyCveIdCnaAndStateModified,
  OrgReserveNotOwningOrg,
  OrgReserveShortNameUndefined,
  OrgReserveOrgDoesntExist,
  OrgReserveAmountLargerThanNonSequential,
  OrgReserveAmountGreaterIdQuota,
  OrgReserveYear2025RangeDoesntExist,
  OrgReserveSequentialPriorityIsFull,
  OrgReserveSequentialIsFull,
  OrgReserveYear2025RangeDoesntExistSequential,
  OrgReserveBase,
  OrgReserveUserB10Ids,
  NullCveIdRepo,
  CveIdGetCveIdDoesntExist,
  CveIdGetCveIdAvailable,
  CveIdGetCveIdNotOwningOrg,
  CveIdGetCveIdNotOwningOrgNotReserved,
  CveIdGetCveIdOwningOrg,
  CveIdSecretariatIdQuota,
  CveIdOwnerIdQuota,
  CveIdExceedsMinQuota,
  CveIdExceedsMaxQuota,
  CveIdGetCveIdNoResultsWithParams,
  CveIdGetCveIdStateProvided,
  CveIdGetCveIdNoAvailableCves,
  CveIdGetCveIdYearProvided,
  CveIdGetCveIdNotSecretariatNoQuery,
  CveIdGetCveIdSecretariatNoQuery,
  CveIdGetCveIdRequestedNotChanged,
  CveIdModifyCveIdDoesntExist,
  CveIdModifyCveIdCnaAndStateModified,
  CveIdModifyCveIdNoQuery,
  CveIdRangeReserveYearDoesntExist,
  CveIdReserveSequentialPriorityIsFull,
  CveIdRangeReserveSequentialIsFull,
  CveIdRangeReserveNonSequentialIsFull,
  CveIdReservePoolIncremented10Ids,
  CveIdRangeReserveSequentialPriorityIsFull,
  CveIdRange2022NotExists,
  CveIdRange2022Exists,
  NullUserRepo,
  UserCreatedOrgUndefined,
  UserNotCreatedAlreadyExists,
  UserNotUpdatedUserDoesntExist,
  UserNotUpdatedOrgQueryDoesntExist,
  UserNotUpdatedNoQuery,
  UserSecretNotResetUserDoesntExist,
  UserSecretReset,
  UserGetUser,
  UserGetUserUpdated,
  UserGetUserDoesntExist,
  UserGetCveIdOwningOrg,
  UserGetCveIdRequestorSecretariat,
  UserModifyCveIdCnaAndStateModified,
  UserReserveSequentialPriorityIsFull
}
