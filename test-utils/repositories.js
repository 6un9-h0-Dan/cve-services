// unique name endpoints
// repository per test
// register each endpoint
const chai = require('chai')
const expect = chai.expect
const CONSTANTS = require('../src/constants')
const RepositoryFactory = require('../src/repositories/repositoryFactory')
const orgMockObj = require('../test/unit-tests/org/mockObjects.org')
const cveIdMockObj = require('../test/unit-tests/cve-id/mockObjects.cve-id')
const cveIdNonSeqMockObj = require('../test/unit-tests/cve-id/mockObjects.non-sequential')
const { aggregate } = require('../src/model/org')
const mwMockObj = require('../test/unit-tests/middleware/mockObjects.middleware')
const mwCnaMockObj = require('../test/unit-tests/middleware/onlyCnas.fixtures')
const mwSecretariatMockObj = require('../test/unit-tests/middleware/onlySecretariat.fixtures')

// const { cveDummy5, cveId, orgHeader, owningOrgHeader, owningOrgUser, secretariatHeader, cveIdYear, org, cveReserved, cveReject, cvePublic, secretariatOrg, secretariatUser, cveDummy1, cveDummy2, cveDummy3, cveDummy4 } = require('../test/unit-tests/cve-id/mockObjects.cve-id')
// const { orgB } = require('../test/unit-tests/cve-id/mockObjects.non-sequential')
// const { deactivatedUser } = require('../test/unit-tests/middleware/mockObjects.middleware')
// const { cnaOrg, secretariatAndCnaOrg, notCnaOrg } = require('../test/unit-tests/middleware/onlyCnas.fixtures')
// const { notSecretariatOrg } = require('../test/unit-tests/middleware/onlySecretariat.fixtures')

/* -------- Org Repositories -------- */
class OrgCreated {
  async findOneByShortName (shortname) {
    return null
  }

  async updateByOrgUUID (uuid, org, settings) {
    // This is where you can actually write some test assertions!
    // For instance, you can even inspect the settings object to make sure the code passes upsert as true.
    // Or more importantly, you can make sure UUID isn't null or something and you can inspect all the fields on the org object
    // to make sure it's exactly what should be sent to the database.
    // But at a bare minimum, you can simply return null because the code isn't actually inspecting the return here.
    return null
  }

  // Notice that the following two functions are used to get information for logging. We aren't examining the logs in this test,
  // so we can again get by with returning null.
  async getOrgUUID () {
    return null
  }
}

class NullOrgRepo {
  async findOneByShortName (shortname) {
    return null
  }

  async updateByOrgUUID (uuid, org, settings) {
    return null
  }

  async getOrgUUID () {
    return null
  }

  async isSecretariat (shortname) {
    return null
  }

  async isSecretariatUUID (uuid) {
    return null
  }
}

class OrgCreatedWhenRolesDefined {
  async findOneByShortName (shortname) {
    return null
  }

  async updateByOrgUUID (uuid, org, settings) {
    return null
  }

  async getOrgUUID () {
    return null
  }
}

class OrgNotCreatedAlreadyExists {
  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    return orgMockObj.existentOrg
  }
}

class OrgNotUpdatedDoesNotExist {
  async findOneByShortName (shortname) {
    return null
  }
}

class OrgNotUpdatedShortNameExists {
  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    return orgMockObj.existentOrg
  }
}

class OrgNotUpdatedIdQuotaUndefined {
  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    orgMockObj.existentOrg.policies.id_quota = 1000 // TODO: move to constructor
    return orgMockObj.existentOrg
  }

  async updateByOrgUUID (uuid, org, settings) {
    expect(settings).to.be.an('undefined')
    expect(uuid).to.be.a('string')
    expect(org).to.be.a('object')
    const result = { n: 1 }
    return result
  }

  async getOrgUUID () {
    return null
  }
}

class OrgNotUpdatedNoQueryParameters {
  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(orgMockObj.existentOrg.short_name)
    return orgMockObj.existentOrg
  }

  async updateByOrgUUID (uuid, org, settings) {
    expect(settings).to.be.a('undefined')
    expect(uuid).to.be.a('string')
    expect(org).to.be.a('object')
    var result = { n: 1 }
    return result
  }

  async getOrgUUID () {
    return null
  }
}

class OrgGet {
  async aggregate (aggregation) {
    expect(aggregation).to.be.an('array')
    expect(aggregation[0]).to.have.property('$match')
    if (aggregation[0].$match.short_name === orgMockObj.existentOrg.short_name) {
      return [orgMockObj.existentOrg]
    }

    return []
  }
}

class OrgSecretariatIdQuota {
  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    return orgMockObj.existentOrg
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    return orgMockObj.existentOrg.UUID
  }
}

class OrgOwnerIdQuota {
  async isSecretariat (shortname) {
    return false
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    return orgMockObj.owningOrg
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    return orgMockObj.owningOrg.UUID
  }
}

class OrgNotOwnerOrSecretariatIdQuota {
  async isSecretariat (shortname) {
    return false
  }
}

class OrgDoesNotExistIdQuota {
  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    return null
  }
}

class OrgExceedsMinIdQuota {
  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    return orgMockObj.orgWithNegativeIdQuota
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    return orgMockObj.orgWithNegativeIdQuota.UUID
  }
}

class OrgExceedsMaxIdQuota {
  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    return orgMockObj.orgExceedingMaxIdQuota
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    return orgMockObj.orgExceedingMaxIdQuota.UUID
  }
}

class OrgsGet {
  async aggregate (aggregation) {
    expect(aggregation).to.be.an('array')
    expect(aggregation[0]).to.have.property('$project')
    return new Array(7) // TODO: return the actual array
  }
}

class OrgsCantGet {
  async aggregate (aggregation) {
    expect(aggregation).to.be.an('array')
    expect(aggregation[0]).to.have.property('$project')
    return []
  }
}

class OrgCantCreateUserCnaDoesNotExist {
  async getOrgUUID (shortname) {
    return null
  }
}

class OrgCantCreateUserCnaDoesNotMatch {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.be.equal(orgMockObj.existentOrg.short_name)
    return orgMockObj.existentOrg.UUID
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string').and.to.equal(orgMockObj.owningOrg.UUID)
    return orgMockObj.owningOrg
  }
}

// This test repo is also used for other tests that pass the same values
class OrgCreatedUserOrgUndefined {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.equal(orgMockObj.existentOrg.short_name)
    return orgMockObj.existentOrg.UUID
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string').and.to.equal(orgMockObj.existentOrg.UUID)
    return orgMockObj.existentOrg
  }
}

class OrgUserNotUpdatedOrgDoesntExist {
  async getOrgUUID (shortname) {
    return null
  }
}

class OrgUserNotUpdatedUserDoesntExist {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(orgMockObj.existentOrg.short_name)
    return orgMockObj.existentOrg
  }
}

class OrgUserNotUpdatedOrgQueryDoesntExist {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    if (shortname === orgMockObj.existentOrg.short_name) {
      return orgMockObj.existentOrg.UUID
    }
    return null
  }
}

class OrgUserCveIdUpdated {
  // constructor () {
  //   this.repos = new RepositoryFactory()
  //   this.orgRepo = this.repos.getOrgRepository()
  // }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    // const res = await this.orgRepo.getOrgUUID(shortname)
    // console.log(res)
    // return res

    if (shortname === cveIdMockObj.owningOrg.short_name) {
      // console.log(cveIdMockObj.owningOrg.UUID)
      return cveIdMockObj.owningOrg.UUID
    } else if (shortname === cveIdMockObj.org.short_name) {
      // console.log(cveIdMockObj.org.UUID)
      return cveIdMockObj.org.UUID
    }
    // console.log(null)
    return null
  }
}

class OrgGetUserCveIdUpdated {
  constructor () {
    // this.repos = new RepositoryFactory()
    // this.orgRepo = this.repos.getOrgRepository()
    cveIdMockObj.owningOrgUser.org_UUID = cveIdMockObj.org.UUID
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(cveIdMockObj.org.short_name)
    // console.log(cveIdMockObj.org.UUID)
    return cveIdMockObj.org.UUID
  }
}

class OrgUserSecretNotResetOrgDoesntExist {
  async getOrgUUID (shortname) {
    return null
  }
}

class OrgUserSecretNotResetUserDoesntExist {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(orgMockObj.existentOrg.short_name)
    return orgMockObj.existentOrg.UUID
  }
}

class OrgUserSecretReset {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(orgMockObj.existentOrg.short_name)
    return orgMockObj.existentOrg.UUID
  }
}

class OrgGetUserOrgDoesntExist {
  async getOrgUUID (shortname) {
    return null
  }
}

class OrgGetUser {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(orgMockObj.existentOrg.short_name)
    return orgMockObj.existentOrg.UUID
  }
}

class OrgGetUserUpdated {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(orgMockObj.org.short_name)
    return orgMockObj.org.UUID // return non-null objects
  }
}

class OrgGetCveIdNotOwnerOrgReserved {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(cveIdMockObj.orgHeader['CVE-API-ORG'])
    return cveIdMockObj.org.UUID
  }

  async isSecretariatUUID (uuid) {
    return false
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    return cveIdMockObj.existentOrg
  }
}

class OrgGetCveIdNotOwnerOrgNotReserved {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(cveIdMockObj.orgHeader['CVE-API-ORG'])
    return cveIdMockObj.org.UUID
  }

  async isSecretariatUUID (uuid) {
    return false
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    return cveIdMockObj.owningOrg
  }
}

class OrgGetCveIdOwningOrg {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(cveIdMockObj.owningOrgHeader['CVE-API-ORG'])
    return cveIdMockObj.owningOrg.UUID
  }

  async isSecretariatUUID (uuid) {
    return false
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    return cveIdMockObj.owningOrg
  }
}

class OrgGetCveIdRequestorSecretariat {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(cveIdMockObj.secretariatHeader['CVE-API-ORG'])
    return cveIdMockObj.secretariatOrg.UUID
  }

  async isSecretariatUUID (uuid) {
    return true
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    if (uuid === cveIdMockObj.secretariatOrg.UUID) {
      return cveIdMockObj.secretariatOrg
    } else {
      return cveIdMockObj.owningOrg
    }
  }
}

class OrgGetCveIdNoCveIdsWithParams {
  async isSecretariat (shortname) {
    return false
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(cveIdMockObj.owningOrgHeader['CVE-API-ORG'])
    return cveIdMockObj.owningOrg.UUID
  }
}

class OrgGetCveIdRequestorSecretariatNoQuery {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(cveIdMockObj.secretariatHeader['CVE-API-ORG'])
    return cveIdMockObj.secretariatOrg.UUID // return non-null objects
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    return cveIdMockObj.secretariatOrg
    // const res = await this.orgRepo.findOneByUUID(uuid)
    // expect(res).to.have.property('short_name').and.to.be.a('string')
    // return res // return non-null objects
  }

  async isSecretariat (shortname) {
    return true
  }
}

class OrgGetCveIdRequestedNotChanged {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(cveIdMockObj.owningOrgHeader['CVE-API-ORG'])
    return cveIdMockObj.owningOrg.UUID // return non-null objects
  }

  async isSecretariat (shortname) {
    return false
  }
}

class OrgModifyCveIdDoesntExist {
  async getOrgUUID (shortname) {
    return null
  }
}

class OrgModifyCveIdCnaDoesntExist {
  async getOrgUUID (shortname) {
    return null
  }
}

class OrgModifyCveIdCnaAndStateModified {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    return cveIdMockObj.org.UUID
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    if (uuid === cveIdMockObj.org.UUID) {
      return cveIdMockObj.org
    } else {
      return cveIdMockObj.owningOrg
    }
  }
}

class OrgReserveNotOwningOrg {
  async isSecretariat (shortname) {
    return false
  }
}

class OrgReserveShortNameUndefined {
  async isSecretariat (shortname) {
    return true
  }
}

class OrgReserveOrgDoesntExist {
  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    return null
  }
}

class OrgReserveAmountLargerThanNonSequential {
  // constructor () {
  //   this.repos = new RepositoryFactory()
  //   this.orgRepo = this.repos.getOrgRepository()
  // }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(cveIdMockObj.org.short_name)
    return cveIdMockObj.org
    // const res = await this.orgRepo.findOneByShortName(shortname)
    // expect(res).to.have.property('short_name').and.to.be.a('string')
    // console.log(res)
    // console.log(org)
    // return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    // const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    // return res // return non-null objects

    if (query.short_name === cveIdMockObj.org.short_name && cveIdMockObj.org.inUse === false) {
      cveIdMockObj.org.inUse = true
      return cveIdMockObj.org
    } else if (query.short_name === cveIdMockObj.org.short_name && cveIdMockObj.org.inUse === true) {
      cveIdMockObj.org.inUse = false
      return null
    }
  }
}
class OrgReserveAmountGreaterIdQuota {
  // constructor () {
  //   this.repos = new RepositoryFactory()
  //   this.orgRepo = this.repos.getOrgRepository()
  // }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(cveIdMockObj.org.short_name)
    return cveIdMockObj.org
    // const res = await this.orgRepo.findOneByShortName(shortname)
    // expect(res).to.have.property('short_name').and.to.be.a('string')
    // return res // return non-null objects
  }
}

class OrgReserveYear2025RangeDoesntExist {
  // constructor () {
  // this.repos = new RepositoryFactory()
  // this.orgRepo = this.repos.getOrgRepository()
  // cveIdMockObj.owningOrg.policies.id_quota = 1000
  // }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(cveIdMockObj.owningOrg.short_name)
    cveIdMockObj.owningOrg.inUse = false
    return cveIdMockObj.owningOrg
    // const res = await this.orgRepo.findOneByShortName(shortname)
    // expect(res).to.have.property('short_name').and.to.be.a('string')
    // console.log(res)
    // console.log(owningOrg)
    // return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    // const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    // return res // return non-null objects

    if (query.short_name === cveIdMockObj.owningOrg.short_name && cveIdMockObj.owningOrg.inUse === false) {
      cveIdMockObj.owningOrg.inUse = true
      return cveIdMockObj.owningOrg
    } else if (query.short_name === cveIdMockObj.owningOrg.short_name && cveIdMockObj.owningOrg.inUse === true) {
      cveIdMockObj.owningOrg.inUse = false
      return null
    }
  }
}

class OrgReserveSequentialPriorityIsFull {
  // constructor () {
  //   this.repos = new RepositoryFactory()
  //   this.orgRepo = this.repos.getOrgRepository()
  // }

  async isSecretariat (shortname) {
    return false
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(cveIdMockObj.owningOrg.short_name)
    // const res = await this.orgRepo.findOneByShortName(shortname)
    // expect(res).to.have.property('short_name').and.to.be.a('string')
    // return res // return non-null objects
    return cveIdMockObj.owningOrg
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    // const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    // return res // return non-null objects

    if (query.short_name === cveIdMockObj.owningOrg.short_name && cveIdMockObj.owningOrg.inUse === false) {
      cveIdMockObj.owningOrg.inUse = true
      return cveIdMockObj.owningOrg
    } else if (query.short_name === cveIdMockObj.owningOrg.short_name && cveIdMockObj.owningOrg.inUse === true) {
      cveIdMockObj.owningOrg.inUse = false
      return null
    }
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    return cveIdMockObj.owningOrg.UUID
    // const res = await this.orgRepo.getOrgUUID(shortname)
    // expect(res).to.be.a('string')
    // return res // return non-null objects
  }
}

class OrgReserveSequentialIsFull {
  // constructor () {
  //   this.repos = new RepositoryFactory()
  //   this.orgRepo = this.repos.getOrgRepository()
  // }

  async isSecretariat (shortname) {
    return false
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(cveIdMockObj.owningOrg.short_name)
    // const res = await this.orgRepo.findOneByShortName(shortname)
    // expect(res).to.have.property('short_name').and.to.be.a('string')
    // return res // return non-null objects
    return cveIdMockObj.owningOrg
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    // const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    // return res // return non-null objects

    if (query.short_name === cveIdMockObj.owningOrg.short_name && cveIdMockObj.owningOrg.inUse === false) {
      cveIdMockObj.owningOrg.inUse = true
      return cveIdMockObj.owningOrg
    } else if (query.short_name === cveIdMockObj.owningOrg.short_name && cveIdMockObj.owningOrg.inUse === true) {
      cveIdMockObj.owningOrg.inUse = false
      return null
    }
  }
}

class OrgReserveNonSequentialYearDoesntExist {
  // constructor () {
  //   this.repos = new RepositoryFactory()
  //   this.orgRepo = this.repos.getOrgRepository()
  // }

  async isSecretariat (shortname) {
    return false
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(cveIdNonSeqMockObj.orgA.short_name)
    // const res = await this.orgRepo.findOneByShortName(shortname)
    // expect(res).to.have.property('short_name').and.to.be.a('string')
    // return res // return non-null objects
    return cveIdNonSeqMockObj.orgA
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    // const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    // return res // return non-null objects

    if (query.short_name === cveIdNonSeqMockObj.orgA.short_name && cveIdNonSeqMockObj.orgA.inUse === false) {
      cveIdNonSeqMockObj.orgA.inUse = true
      return cveIdNonSeqMockObj.orgA
    } else if (query.short_name === cveIdNonSeqMockObj.orgA.short_name && cveIdNonSeqMockObj.orgA.inUse === true) {
      cveIdNonSeqMockObj.orgA.inUse = false
      return null
    }
  }
}

class OrgReserveYear2025RangeDoesntExistSequential {

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(cveIdMockObj.owningOrg.short_name)
    return cveIdMockObj.owningOrg // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    return { n: 1 } // return non-null objects
  }
}

class OrgReserveUserB10Ids {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return false
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(cveIdNonSeqMockObj.orgB.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res // return non-null objects
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

class OrgReserveBase {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return false
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res // return non-null objects
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

class OrgValidateUserSuccess {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(mwMockObj.secretariatHeaders['CVE-API-ORG'])
    return mwMockObj.existentOrg.UUID
  }
}

class OrgValidateOrgDoesntExist {
  async getOrgUUID (shortname) {
    return null
  }
}

class OrgOnlyCnasOrgCnaPass {
  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(mwCnaMockObj.cnaOrg.short_name)
    return mwCnaMockObj.cnaOrg
  }
}

class OrgOnlyCnasOrgCnaSecretariatPass {
  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(mwCnaMockObj.secretariatAndCnaOrg.short_name)
    return mwCnaMockObj.secretariatAndCnaOrg
  }
}

class OrgOnlyCnasOrgSecretariatPass {
  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(mwCnaMockObj.secretariatOrg.short_name)
    return mwCnaMockObj.secretariatOrg
  }
}

class OrgOnlyCnasOrgNotCnaReject {
  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(mwCnaMockObj.notCnaOrg.short_name)
    return mwCnaMockObj.notCnaOrg
  }
}

class OrgOnlySecretariatPass {
  async isSecretariat (shortname) {
    return true
  }
}

class OrgOnlySecretariatReject {
  async isSecretariat (shortname) {
    return false
  }
}

/* -------- Cve Id Repositories -------- */
class NullCveIdRepo {
  async countDocuments (query) {
    return null
  }
}

class CveIdOwnerIdQuota {
  async countDocuments (query) {
    return 0
  }
}

class CveIdSecretariatIdQuota {
  async countDocuments (query) {
    return 0
  }
}

class CveIdExceedsMinQuota {
  async countDocuments (query) {
    return 0
  }
}

class CveIdExceedsMaxQuota {
  async countDocuments (query) {
    return 0
  }
}

class CveIdGetCveIdDoesntExist {
  async findOneByCveId (id) {
    return null
  }
}

class CveIdGetCveIdAvailable {
  async findOneByCveId (id) {
    expect(id).to.be.a('string').and.to.equal(cveIdMockObj.cveDummy5.cve_id)
    return cveIdMockObj.cveDummy5
  }
}

class CveIdGetCveIdNotOwningOrg {
  async findOneByCveId (id) {
    expect(id).to.be.a('string').and.to.equal(cveIdMockObj.cveId)
    return cveIdMockObj.cveReserved
  }
}

class CveIdGetCveIdNotOwningOrgNotReserved {
  async findOneByCveId (id) {
    expect(id).to.be.a('string').and.to.equal(cveIdMockObj.cveId)
    return cveIdMockObj.cveReject
  }
}

class CveIdGetCveIdOwningOrg {
  async findOneByCveId (id) {
    expect(id).to.be.a('string').and.to.equal(cveIdMockObj.cveId)
    return cveIdMockObj.cvePublic
  }
}

class CveIdGetCveIdNoResultsWithParams {
  async aggregate (aggregation) {
    return []
  }
}

class CveIdGetCveIdStateProvided {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    expect(aggregation[0].$match).to.have.property('state').and.to.equal('PUBLIC')
    var testRes = cveIdMockObj.cvePublic
    testRes.requested_by.cna = cveIdMockObj.owningOrg.short_name
    testRes.requested_by.user = cveIdMockObj.owningOrgUser.username
    testRes.owning_cna = cveIdMockObj.owningOrg.short_name
    return [testRes]
  }
}

class CveIdGetCveIdNoAvailableCves {
  async aggregate (aggregation) {
    return []
  }
}

class CveIdGetCveIdYearProvided {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    expect(aggregation[0].$match).to.have.property('cve_year').and.to.equal(cveIdMockObj.cveIdYear)
    return [cveIdMockObj.cvePublic]
  }
}

class CveIdGetCveIdNotSecretariatNoQuery {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    var testRes1 = cveIdMockObj.cvePublic
    testRes1.owning_cna = cveIdMockObj.owningOrg.short_name
    testRes1.requested_by.cna = cveIdMockObj.owningOrg.short_name
    testRes1.requested_by.user = cveIdMockObj.owningOrgUser.username
    var testRes2 = cveIdMockObj.cveDummy1
    testRes2.owning_cna = cveIdMockObj.owningOrg.short_name
    testRes2.requested_by.cna = cveIdMockObj.secretariatOrg.short_name
    testRes2.requested_by.user = cveIdMockObj.secretariatUser.username
    return [testRes1, testRes2]
  }
}

class CveIdGetCveIdSecretariatNoQuery {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    var testRes1 = cveIdMockObj.cvePublic
    testRes1.owning_cna = cveIdMockObj.owningOrg.short_name
    testRes1.requested_by.cna = cveIdMockObj.owningOrg.short_name
    testRes1.requested_by.user = cveIdMockObj.owningOrgUser.username
    var testRes2 = cveIdMockObj.cveDummy1
    testRes2.owning_cna = cveIdMockObj.owningOrg.short_name
    testRes2.requested_by.cna = cveIdMockObj.secretariatOrg.short_name
    testRes2.requested_by.user = cveIdMockObj.secretariatUser.username
    var testRes3 = cveIdMockObj.cveDummy2
    testRes3.owning_cna = cveIdMockObj.secretariatOrg.short_name
    testRes3.requested_by.cna = cveIdMockObj.secretariatOrg.short_name
    testRes3.requested_by.user = cveIdMockObj.secretariatUser.username
    var testRes4 = cveIdMockObj.cveDummy3
    testRes4.owning_cna = cveIdMockObj.secretariatOrg.short_name
    testRes4.requested_by.cna = cveIdMockObj.secretariatOrg.short_name
    testRes4.requested_by.user = cveIdMockObj.secretariatUser.username
    var testRes5 = cveIdMockObj.cveDummy4
    testRes5.owning_cna = cveIdMockObj.org.short_name
    testRes5.requested_by.cna = cveIdMockObj.secretariatOrg.short_name
    testRes5.requested_by.user = cveIdMockObj.secretariatUser.username
    return [testRes1, testRes2, testRes3, testRes4, testRes5]
  }
}

class CveIdGetCveIdRequestedNotChanged {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    var testRes1 = cveIdMockObj.cvePublic
    var testRes2 = cveIdMockObj.cveDummy1
    return [testRes1, testRes2] // return non-null objects
  }
}

class CveIdModifyCveIdDoesntExist {
  async findOneByCveId (id) {
    return null
  }
}

class CveIdModifyCveIdCnaAndStateModified {
  async findOneByCveId (id) {
    expect(id).to.be.a('string').and.to.equal(cveIdMockObj.cveId)
    return cveIdMockObj.cveReserved
  }

  async findOneAndUpdate (query, updatedCveId, options) {
    expect(query.cve_id).to.be.a('string').and.to.equal(cveIdMockObj.cveId)
    expect(updatedCveId).to.be.an('object')
    expect(options).to.have.property('new')
    var testRes = updatedCveId
    return testRes
  }
}

class CveIdModifyCveIdNoQuery {
  async findOneByCveId (id) {
    expect(id).to.be.a('string').and.to.equal(cveIdMockObj.cveId)
    var testRes = cveIdMockObj.cveReject
    testRes.owning_cna = cveIdMockObj.org.UUID
    return testRes
  }

  async findOneAndUpdate (query, updatedCveId, options) {
    expect(query.cve_id).to.be.a('string').and.to.equal(cveIdMockObj.cveId)
    expect(updatedCveId).to.be.an('object')
    expect(options).to.have.property('new')
    var testRes = updatedCveId
    return testRes
  }
}

class CveIdReserveSequentialYearDoesntExist {

  async insertMany (documents) {
    return null
  }

  async countDocuments (query) {
    return 2
  }
}

class CveIdReserveSequentialPriorityIsFull {
  // constructor () {
  //   this.repos = new RepositoryFactory()
  //   this.cveIdRepo = this.repos.getCveIdRepository()
  // }

  async insertMany (documents) {
    // expect(documents).to.be.an('array').and.to.have.lengthOf.above(0)
    // const res = await this.cveIdRepo.insertMany(documents)
    // console.log(res)
    // return res // return non-null objects
    return null
  }

  async countDocuments (query) {
    // expect(query).to.have.property('owning_cna')
    // expect(query).to.have.property('state').and.to.be.equal('RESERVED')
    // const res = await this.cveIdRepo.countDocuments(query)
    // console.log(res)
    // return res // return different count values
    return 0
  }
}

class CveIdReserveSequentialIsFull {

  async insertMany (documents) {
    expect(documents).to.be.an('array').and.to.have.lengthOf.above(0)
    return null
  }

  async countDocuments (query) {
    expect(query).to.have.property('owning_cna')
    expect(query).to.have.property('state').and.to.be.equal('RESERVED')
    return 2
  }
}

class CveIdReserveSequential {

  async insertMany (documents) {
    expect(documents).to.be.an('array').and.to.have.lengthOf.above(0)
    return null
  }

  async countDocuments (query) {
    expect(query).to.have.property('owning_cna')
    expect(query).to.have.property('state').and.to.be.equal('RESERVED')
    return 2
  }
}

class CveIdReserveNonSequentialIsFull {
  async countDocuments (query) {
    return 0
  }
}

class CveIdReservePoolIncremented10Ids {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async insertMany (documents) {
    expect(documents).to.be.an('array')
    const res = await this.cveIdRepo.insertMany(documents)
    expect(documents).to.be.an('array').and.to.have.lengthOf.above(0)
    return res // return non-null objects
  }

  async countDocuments (query) {
    expect(query).to.have.property('owning_cna')
    expect(query).to.have.property('state').and.to.be.equal('RESERVED')
    const res = await this.cveIdRepo.countDocuments(query)
    return res // return different count values
  }

  async find (query, options) {
    expect(options).to.be.an('object').and.to.have.property('limit')
    const res = await this.cveIdRepo.find(query, options)
    return res // return empty and not empty arrays
  }

  async findOneAndUpdate (query, updatedCveId, options) {
    expect(query.cve_id).to.be.a('string')
    expect(updatedCveId).to.be.an('object')
    expect(options).to.have.property('new')
    const res = await this.cveIdRepo.findOneAndUpdate(query, updatedCveId, options)
    expect(res).to.have.property('cve_id').and.to.be.a('string')
    return res // return non-null objects
  }
}

/* -------- Cve Id Range Repositories -------- */
class CveIdRangeReserveYearDoesntExist {
  async findOne (query) {
    return null
  }
}

class CveIdRangeReserveSequentialPriorityIsFull {
  constructor () {
    this.year = '2021'
    this.cveIdRange = Object.assign({}, CONSTANTS.DEFAULT_CVE_ID_RANGE)
    this.cveIdRange.cve_year = this.year
    this.cveIdRange.ranges.priority.top_id = this.cveIdRange.ranges.priority.end
    this.cveIdRange.ranges.general.top_id = this.cveIdRange.ranges.general.end - 1
  }

  async findOne (query) {
    expect(query).to.have.property('cve_year').and.to.be.a('string')
    // const res = await this.cveIdRangeRepo.findOne(query)
    // expect(res).to.have.property('cve_year').and.to.be.a('string')
    // return res // return non-null objects

    // const cveIdRange = Object.assign({}, CONSTANTS.DEFAULT_CVE_ID_RANGE)
    // cveIdRange.cve_year = '2021'
    // cveIdRange.ranges.priority.top_id = cveIdRange.ranges.priority.end
    // cveIdRange.ranges.general.top_id = cveIdRange.ranges.general.end - 1
    return this.cveIdRange
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.be.an('object')
    expect(set).to.be.an('object')
    expect(options).to.be.an('object')

    // const res = await this.cveIdRangeRepo.findOneAndUpdate(query, set, options)
    // return res // return null and non-null objects

    if (query.$and[0].cve_year === this.year && query.$and[1]['ranges.priority.top_id'] !== undefined &&
    this.cveIdRange.ranges.priority.top_id < this.cveIdRange.ranges.priority.end) {
      this.cveIdRange.ranges.priority.top_id++
      return this.cveIdRange
    } else if (query.$and[0].cve_year === this.year && query.$and[1]['ranges.general.end'] !== undefined &&
    this.cveIdRange.ranges.general.end > this.cveIdRange.ranges.general.top_id) {
      this.cveIdRange.ranges.general.top_id++
      return this.cveIdRange
    }

    return null
  }
}

class CveIdRangeReserveSequentialIsFull {
  constructor () {
    this.year = '2021'
    this.cveIdRange = Object.assign({}, CONSTANTS.DEFAULT_CVE_ID_RANGE)
    this.cveIdRange.cve_year = this.year
    this.cveIdRange.ranges.priority.top_id = this.cveIdRange.ranges.priority.end
    this.cveIdRange.ranges.general.top_id = this.cveIdRange.ranges.general.end
  }

  async findOne (query) {
    expect(query).to.have.property('cve_year').and.to.be.a('string')
    return this.cveIdRange
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.be.an('object')
    expect(set).to.be.an('object')
    expect(options).to.be.an('object')

    return null
  }
}

class CveIdRangeReserveSequential {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
    this.year = '2020'
    this.cveIdRange = Object.assign({}, CONSTANTS.DEFAULT_CVE_ID_RANGE)
    this.cveIdRange.cve_year = this.year
    this.cveIdRange.ranges.priority.top_id = this.cveIdRange.ranges.priority.end
    this.cveIdRange.ranges.general.top_id = this.cveIdRange.ranges.general.end
  }

  async findOne (query) {
    expect(query).to.have.property('cve_year').and.to.be.a('string')

    const cveIdRange = Object.assign({}, CONSTANTS.DEFAULT_CVE_ID_RANGE)
    cveIdRange.cve_year = '2021'
    cveIdRange.ranges.priority.top_id = cveIdRange.ranges.priority.end
    cveIdRange.ranges.general.top_id = cveIdRange.ranges.general.end - 1
    return this.cveIdRange
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.be.an('object')
    expect(set).to.be.an('object')
    expect(options).to.be.an('object')

    return {
      ranges: {
        priority: { top_id: 0, start: 0, end: 20000 },
        general: { top_id: 15, start: 10, end: 15 }
      },
      cve_year: '2020',
    } // return null and non-null objects
  }
}

class CveIdRangeReserveSequentialPriority {
  constructor () {
    // this.repos = new RepositoryFactory()
    // this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
    this.year = '2020'
    this.cveIdRange = Object.assign({}, CONSTANTS.DEFAULT_CVE_ID_RANGE)
    this.cveIdRange.cve_year = this.year
    this.cveIdRange.ranges.priority.top_id = 0
    this.cveIdRange.ranges.general.top_id = this.cveIdRange.ranges.priority.end
  }

  async findOne (query) {
    expect(query).to.have.property('cve_year').and.to.be.a('string')
    return this.cveIdRange
    // const res = await this.cveIdRangeRepo.findOne(query)
    // expect(res).to.have.property('cve_year').and.to.be.a('string')
    // console.log(res)
    // return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.be.an('object')
    expect(set).to.be.an('object')
    expect(options).to.be.an('object')

    // const res = await this.cveIdRangeRepo.findOneAndUpdate(query, set, options)
    // return res // return null and non-null objects

    if (query.$and[0].cve_year === this.year && query.$and[1]['ranges.priority.top_id'] !== undefined &&
    this.cveIdRange.ranges.priority.top_id < this.cveIdRange.ranges.priority.end) {
      this.cveIdRange.ranges.priority.top_id++
      return this.cveIdRange
    } else if (query.$and[0].cve_year === this.year && query.$and[1]['ranges.general.end'] !== undefined &&
    this.cveIdRange.ranges.general.end > this.cveIdRange.ranges.general.top_id) {
      this.cveIdRange.ranges.general.top_id++
      return this.cveIdRange
    }

    return null
  }
}

class CveIdRange2022NotExists {
  // constructor () {
  //   this.repos = new RepositoryFactory()
  //   this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
  // }

  async findOne (query) {
    return null
  }

  async findOneAndUpdate (query, set, options) {
    // const res = await this.cveIdRangeRepo.findOneAndUpdate(query, set, options)
    return null
  }
}

class CveIdRange2022Exists {
  constructor () {
    // this.repos = new RepositoryFactory()
    // this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
    this.cveIdRange = Object.assign({}, CONSTANTS.DEFAULT_CVE_ID_RANGE)
    this.cveIdRange.cve_year = '2022'
  }

  async findOne (query) {
    expect(query).to.have.property('cve_year').and.to.be.a('string')
    return this.cveIdRange
    // const res = await this.cveIdRangeRepo.findOne(query)
    // expect(res).to.have.property('cve_year').and.to.be.a('string')
    // return res // return non-null objects
  }
}

/* -------- User Repositories -------- */
class NullUserRepo {
  async getUserUUID () {
    return null
  }

  async findOneByUserNameAndOrgUUID (username, uuid) {
    return null
  }
}

class UserNotCreatedAlreadyExists {
  async findOneByUserNameAndOrgUUID (username, uuid) {
    expect(username).to.be.a('string').and.to.equal(orgMockObj.existentUser.username)
    expect(uuid).to.be.a('string')
    return orgMockObj.existentUser // return non-null objects
  }
}

// This test repo is also used for other tests that pass the same values
class UserCreatedOrgUndefined {
  async findOneByUserNameAndOrgUUID (username, uuid) {
    return null
  }

  async updateByUserNameAndOrgUUID (username, uuid, user, options) {
    expect(options).to.have.property('upsert').and.to.equal(true)
    expect(username).to.equal(orgMockObj.nonExistentUser.username)
    expect(uuid).to.equal(orgMockObj.existentOrg.UUID)
    expect(user).to.be.an('object')
    return null
  }
}

class UserNotUpdatedUserDoesntExist {
  async findOneByUserNameAndOrgUUID (username, uuid) {
    return null
  }
}

class UserNotUpdatedOrgQueryDoesntExist {
  async findOneByUserNameAndOrgUUID (username, uuid) {
    expect(username).to.be.a('string').and.to.equal(orgMockObj.existentUser.username)
    expect(uuid).to.be.a('string')
    return orgMockObj.existentUser
  }
}

class UserNotUpdatedNoQuery {
  async findOneByUserNameAndOrgUUID (username, uuid) {
    expect(username).to.be.a('string').and.to.equal(orgMockObj.existentUser.username)
    expect(uuid).to.be.a('string')
    return orgMockObj.existentUser
  }

  async updateByUserNameAndOrgUUID (username, uuid, user, options) {
    expect(options).to.be.an('undefined')
    expect(username).to.equal(orgMockObj.existentUser.username)
    expect(uuid).to.equal(orgMockObj.existentOrg.UUID)
    expect(user).to.be.an('object')
    return { n: 1, nModified: 1, ok: 1 }
  }

  async getUserUUID (user, uuid) {
    expect(uuid).to.be.a('string')
    expect(user).to.be.a('string')
    return orgMockObj.existentUser.UUID
  }
}

class UserOrgCveIdUpdated {
  async findOneByUserNameAndOrgUUID (username, uuid) {
    expect(username).to.be.a('string').and.to.equal(cveIdMockObj.owningOrgUser.username)
    expect(uuid).to.be.a('string')
    return cveIdMockObj.owningOrgUser
  }

  async find (query) {
    expect(query).to.have.property('org_UUID').and.to.be.a('string')
    expect(query).to.have.property('username').and.to.be.a('string')
    return []
  }

  async updateByUserNameAndOrgUUID (username, uuid, user) {
    expect(username).to.be.a('string').and.to.equal(cveIdMockObj.owningOrgUser.username)
    expect(uuid).to.equal(cveIdMockObj.owningOrgUser.org_UUID)
    expect(user).to.be.an('object')
    cveIdMockObj.owningOrgUser.org_UUID = cveIdMockObj.org.UUID
    const res = { n: 1, nModified: 1, ok: 1 }
    return res
  }

  async getUserUUID (user, uuid) {
    return null
  }
}

class UserGetUserCveIdUpdated {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    expect(aggregation[0].$match).to.have.property('username').and.to.equal(cveIdMockObj.owningOrgUser.username)
    expect(aggregation[0].$match).to.have.property('org_UUID').and.to.equal(cveIdMockObj.org.UUID)
    return [cveIdMockObj.owningOrgUser]
  }
}

class UserSecretNotResetUserDoesntExist {
  async updateByUserNameAndOrgUUID (username, uuid, user, options) {
    expect(options).to.be.an('undefined')
    expect(username).to.equal(orgMockObj.nonExistentUser.username)
    expect(uuid).to.equal(orgMockObj.existentOrg.UUID)
    expect(user).to.be.an('object')
    const res = { n: 0, nModified: 0, ok: 1 }
    return res
  }
}

class UserSecretReset {
  async updateByUserNameAndOrgUUID (username, uuid, user, options) {
    expect(options).to.be.an('undefined')
    expect(username).to.equal(orgMockObj.existentUser.username)
    expect(uuid).to.equal(orgMockObj.existentOrg.UUID)
    expect(user).to.be.an('object')
    const res = { n: 1, nModified: 1, ok: 1 }
    return res
  }

  async getUserUUID (user, uuid) {
    expect(uuid).to.be.a('string')
    expect(user).to.be.a('string')
    return orgMockObj.existentUser.UUID
  }
}

class UserGetUser {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    return [orgMockObj.existentUser]
  }
}

class UserGetUserUpdated {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    var testRes = orgMockObj.owningOrgUser
    testRes.org_UUID = orgMockObj.org.UUID
    return [testRes] // return non-null objects
  }
}

class UserGetUserDoesntExist {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    return []
  }
}

class UserGetCveIdOwningOrg {
  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string').and.to.equal(cveIdMockObj.owningOrgUser.UUID)
    return cveIdMockObj.owningOrgUser
  }
}

class UserGetCveIdRequestorSecretariat {
  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    if (uuid === cveIdMockObj.secretariatUser.UUID) {
      return cveIdMockObj.secretariatUser
    } else {
      return cveIdMockObj.owningOrgUser
    }
  }
}

class UserModifyCveIdCnaAndStateModified {
  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    return cveIdMockObj.owningOrgUser
  }

  async getUserUUID (user, orgUUID) {
    expect(user).to.be.a('string').and.to.equal(cveIdMockObj.secretariatHeader['CVE-API-USER'])
    expect(orgUUID).to.be.a('string')
    return cveIdMockObj.secretariatUser.UUID
  }
}

class UserReserveSequentialPriorityIsFull {
  // constructor () {
  //   this.repos = new RepositoryFactory()
  //   this.userRepo = this.repos.getUserRepository()
  // }

  async findOneByUserNameAndOrgUUID (username, orgUUID) {
    expect(username).to.be.a('string')
    expect(orgUUID).to.be.a('string')
    return cveIdMockObj.owningOrgUser

    // const res = await this.userRepo.findOneByUserNameAndOrgUUID(username, orgUUID)
    // expect(res).to.have.property('username').and.to.be.a('string')
    // console.log(res)
    // return res // return non-null objects
  }
}

// class UserReserveNonSequentialPriorityIsFull {
//   constructor () {
//     this.repos = new RepositoryFactory()
//     this.userRepo = this.repos.getUserRepository()
//   }

//   async findOneByUserNameAndOrgUUID (username, orgUUID) {
//     expect(username).to.be.a('string')
//     expect(orgUUID).to.be.a('string')
//     const res = await this.userRepo.findOneByUserNameAndOrgUUID(username, orgUUID)
//     expect(res).to.have.property('username').and.to.be.a('string')
//     return res // return non-null objects
//   }
// }

class UserValidateUserSuccess {
  async findOneByUserNameAndOrgUUID (username, uuid) {
    expect(username).to.be.a('string').and.to.equal(mwMockObj.secretariatHeaders['CVE-API-USER'])
    expect(uuid).to.be.a('string').and.to.equal(mwMockObj.existentOrg.UUID)
    return mwMockObj.existentUser
  }
}

class UserValidateUserDeactivated {
  async findOneByUserNameAndOrgUUID (username, orgUUID) {
    return mwMockObj.deactivatedUser
  }
}

module.exports = {
  NullOrgRepo,
  OrgCreated,
  OrgCreatedWhenRolesDefined,
  OrgNotCreatedAlreadyExists,
  OrgNotUpdatedDoesNotExist,
  OrgNotUpdatedShortNameExists,
  OrgNotUpdatedIdQuotaUndefined,
  OrgNotUpdatedNoQueryParameters,
  OrgGet,
  OrgSecretariatIdQuota,
  OrgOwnerIdQuota,
  OrgNotOwnerOrSecretariatIdQuota,
  OrgDoesNotExistIdQuota,
  OrgExceedsMinIdQuota,
  OrgExceedsMaxIdQuota,
  OrgsGet,
  OrgsCantGet,
  OrgCantCreateUserCnaDoesNotExist,
  OrgCantCreateUserCnaDoesNotMatch,
  OrgCreatedUserOrgUndefined,
  OrgUserNotUpdatedOrgDoesntExist,
  OrgUserNotUpdatedUserDoesntExist,
  OrgUserNotUpdatedOrgQueryDoesntExist,
  OrgUserCveIdUpdated,
  OrgGetUserCveIdUpdated,
  OrgUserSecretNotResetOrgDoesntExist,
  OrgUserSecretNotResetUserDoesntExist,
  OrgUserSecretReset,
  OrgGetUserOrgDoesntExist,
  OrgGetUser,
  OrgGetUserUpdated,
  OrgGetCveIdNotOwnerOrgNotReserved,
  OrgGetCveIdNotOwnerOrgReserved,
  OrgGetCveIdOwningOrg,
  OrgGetCveIdRequestorSecretariat,
  OrgGetCveIdNoCveIdsWithParams,
  OrgGetCveIdRequestorSecretariatNoQuery,
  OrgGetCveIdRequestedNotChanged,
  OrgModifyCveIdDoesntExist,
  OrgModifyCveIdCnaDoesntExist,
  OrgModifyCveIdCnaAndStateModified,
  OrgReserveNotOwningOrg,
  OrgReserveShortNameUndefined,
  OrgReserveOrgDoesntExist,
  OrgReserveAmountLargerThanNonSequential,
  OrgReserveAmountGreaterIdQuota,
  OrgReserveYear2025RangeDoesntExist,
  OrgReserveSequentialPriorityIsFull,
  OrgReserveSequentialIsFull,
  OrgReserveNonSequentialYearDoesntExist,
  OrgReserveYear2025RangeDoesntExistSequential,
  OrgReserveBase,
  OrgReserveUserB10Ids,
  OrgValidateUserSuccess,
  OrgValidateOrgDoesntExist,
  OrgOnlyCnasOrgCnaPass,
  OrgOnlyCnasOrgCnaSecretariatPass,
  OrgOnlyCnasOrgSecretariatPass,
  OrgOnlyCnasOrgNotCnaReject,
  OrgOnlySecretariatPass,
  OrgOnlySecretariatReject,
  NullCveIdRepo,
  CveIdGetCveIdDoesntExist,
  CveIdGetCveIdAvailable,
  CveIdGetCveIdNotOwningOrg,
  CveIdGetCveIdNotOwningOrgNotReserved,
  CveIdGetCveIdOwningOrg,
  CveIdSecretariatIdQuota,
  CveIdOwnerIdQuota,
  CveIdExceedsMinQuota,
  CveIdExceedsMaxQuota,
  CveIdGetCveIdNoResultsWithParams,
  CveIdGetCveIdStateProvided,
  CveIdGetCveIdNoAvailableCves,
  CveIdGetCveIdYearProvided,
  CveIdGetCveIdNotSecretariatNoQuery,
  CveIdGetCveIdSecretariatNoQuery,
  CveIdGetCveIdRequestedNotChanged,
  CveIdModifyCveIdDoesntExist,
  CveIdModifyCveIdCnaAndStateModified,
  CveIdModifyCveIdNoQuery,
  CveIdRangeReserveYearDoesntExist,
  CveIdReserveSequentialYearDoesntExist,
  CveIdReserveSequentialPriorityIsFull,
  CveIdReserveSequential,
  CveIdReserveNonSequentialIsFull,
  CveIdReserveSequentialIsFull,
  CveIdRangeReserveSequentialIsFull,
  CveIdRangeReserveSequential,
  CveIdReservePoolIncremented10Ids,
  CveIdRangeReserveSequentialPriorityIsFull,
  CveIdRangeReserveSequentialPriority,
  CveIdRange2022NotExists,
  CveIdRange2022Exists,
  NullUserRepo,
  UserCreatedOrgUndefined,
  UserNotCreatedAlreadyExists,
  UserNotUpdatedUserDoesntExist,
  UserNotUpdatedOrgQueryDoesntExist,
  UserNotUpdatedNoQuery,
  UserOrgCveIdUpdated,
  UserGetUserCveIdUpdated,
  UserSecretNotResetUserDoesntExist,
  UserSecretReset,
  UserGetUser,
  UserGetUserUpdated,
  UserGetUserDoesntExist,
  UserGetCveIdOwningOrg,
  UserGetCveIdRequestorSecretariat,
  UserModifyCveIdCnaAndStateModified,
  UserReserveSequentialPriorityIsFull,
  UserValidateUserSuccess,
  UserValidateUserDeactivated
}
