// unique name endpoints
// repository per test
// register each endpoint
const RepositoryFactory = require('../src/repositories/repositoryFactory')
const chai = require('chai')
const { existentOrg, owningOrg, orgWithNegativeIdQuota, orgExceedingMaxIdQuota, nonExistentOrg } = require('../test/unit-tests/org/mockObjects.org')
const expect = chai.expect

/* -------- Org Repositories -------- */
class OrgCreatedWhenUuidUndefined {
    constructor(){}

    async findOneByShortName(shortname) {
        return null
    }

    async updateByOrgUUID(uuid, org, settings) {
        // This is where you can actually write some test assertions!

        // For instance, you can even inspect the settings object to make sure the code passes upsert as true.

        // Or more importantly, you can make sure UUID isn't null or something and you can inspect all the fields on the org object
        // to make sure it's exactly what should be sent to the database.

        // But at a bare minimum, you can simply return null because the code isn't actually inspecting the return here.
        return null
    }

    // Notice that the following two functions are used to get information for logging. We aren't examining the logs in this test,
    // so we can again get by with returning null.
    async getOrgUUID() {
        return null
    }

}

class OrgCreatedWhenUuidNull {
    constructor(){}

    async findOneByShortName(shortname) {
        return null
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgCreatedWhenUuidDefined {
    constructor(){}

    async findOneByShortName(shortname) {
        return null
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgCreatedWhenRolesDefined {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async findOneByShortName(shortname) {
        expect(shortname).to.be.a('string')
        const org = await this.orgRepo.findOneByShortName(shortname)
        expect(org).to.be.a('null')
        return org
    }

    async updateByOrgUUID(uuid, org, settings) {
        expect(settings).to.have.property('upsert').and.to.be.a('boolean')
        await this.orgRepo.updateByOrgUUID(uuid, org, settings)
        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgCreatedWhenRolesUndefinedIdQuotaDefined {
    constructor(){}

    async findOneByShortName(shortname) {
        return null
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgCreatedWhenIdQuotaUndefined {
    constructor(){}

    async findOneByShortName(shortname) {
        return null
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgCreatedWhenIdQuotaNull {
    constructor(){}

    async findOneByShortName(shortname) {
        return null
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgNotCreatedAlreadyExists {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async findOneByShortName(shortname) {
        expect(shortname).to.be.a('string')
        const org = await this.orgRepo.findOneByShortName(shortname)
        expect(org).to.have.property('short_name').and.to.be.a('string')
        return org
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgNotUpdatedDoesNotExist {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async findOneByShortName(shortname) {
        expect(shortname).to.be.a('string')
        const org = await this.orgRepo.findOneByShortName(shortname)
        expect(org).to.be.a('null')
        return org
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgNotUpdatedShortNameExists {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async findOneByShortName(shortname) {
        expect(shortname).to.be.a('string')
        const org = await this.orgRepo.findOneByShortName(shortname)
        expect(org).to.have.property('short_name').and.to.be.a('string')
        return org
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgNotUpdatedIdQuotaUndefined {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async findOneByShortName(shortname) {
        expect(shortname).to.be.a('string')
        const org = await this.orgRepo.findOneByShortName(shortname)
        expect(org).to.have.property('short_name').and.to.be.a('string')
        return org
    }

    async updateByOrgUUID(uuid, org, settings) {
        expect(settings).to.be.an('undefined')
        expect(uuid).to.be.a('string')
        const result = await this.orgRepo.updateByOrgUUID(uuid, org, settings)
        return result
    }

    async getOrgUUID() {
        return null
    }
}

class OrgNotUpdatedNoQueryParameters {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async findOneByShortName(shortname) {
        const org = await this.orgRepo.findOneByShortName(shortname)
        return org
    }

    async updateByOrgUUID(uuid, org, settings) {
        const result = await this.orgRepo.updateByOrgUUID(uuid, org, settings)
        return result
    }

    async getOrgUUID() {
        return null
    }
}

class OrgCantGetDoesNotExist {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async aggregate(aggregation) {
        expect(aggregation).to.be.an('array')
        expect(aggregation[0]).to.have.property('$match')
        const result = await this.orgRepo.aggregate(aggregation)
        return result
    }

    async findOneByShortName(shortname) {
        return null
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgGetDoesExist {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async aggregate(aggregation) {
        expect(aggregation).to.be.an('array')
        expect(aggregation[0]).to.have.property('$match')
        const result = await this.orgRepo.aggregate(aggregation)
        return result
    }

    async findOneByShortName(shortname) {
        return null
    }

    async updateByOrgUUID(uuid, org, settings) {

        return null
    }

    async getOrgUUID() {
        return null
    }
}

class OrgSecretariatIdQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async isSecretariat(shortname) {
        const res = await this.orgRepo.isSecretariat(shortname)
        expect(res).to.be.a('boolean').and.to.equal(true)
        return res
    }

    async findOneByShortName(shortname) {
        const res = await this.orgRepo.findOneByShortName(shortname)
        expect(res).to.be.an('object')
        return res
    }

    async getOrgUUID(shortname) {
        const res = await this.orgRepo.getOrgUUID(shortname)
        return res
    }
}

class OrgOwnerIdQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async isSecretariat(shortname) {
        const res = await this.orgRepo.isSecretariat(shortname)
        expect(res).to.be.a('boolean').and.to.equal(false)
        return res
    }

    async findOneByShortName(shortname) {
        const res = await this.orgRepo.findOneByShortName(shortname)
        expect(res).to.be.an('object')
        return res
    }

    async getOrgUUID(shortname) {
        const res = await this.orgRepo.getOrgUUID(shortname)
        return res
    }
}

class OrgNotOwnerOrSecretariatIdQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async isSecretariat(shortname) {
        const res = await this.orgRepo.isSecretariat(shortname)
        expect(res).to.be.a('boolean').and.to.equal(false)
        return res
    }

    async findOneByShortName(shortname) {
        return null
    }

    async getOrgUUID(shortname) {
        return null
    }
}

class OrgDoesNotExistIdQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async isSecretariat(shortname) {
        const res = await this.orgRepo.isSecretariat(shortname)
        expect(res).to.be.a('boolean').and.to.equal(true)
        return res
    }

    async findOneByShortName(shortname) {
        const res = await this.orgRepo.findOneByShortName(shortname)
        expect(res).to.be.a('null')
        return res
    }
}

class OrgExceedsMinIdQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async isSecretariat(shortname) {
        const res = await this.orgRepo.isSecretariat(shortname)
        expect(res).to.be.a('boolean').and.to.equal(true)
        return res
    }

    async findOneByShortName(shortname) {
        const res = await this.orgRepo.findOneByShortName(shortname)
        expect(res).to.be.an('object')
        return res
    }

    async getOrgUUID(shortname) {
        const res = await this.orgRepo.getOrgUUID(shortname)
        expect(res).to.equal(orgWithNegativeIdQuota.UUID)
        return res
    }
}

class OrgExceedsMaxIdQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async isSecretariat(shortname) {
        const res = await this.orgRepo.isSecretariat(shortname)
        expect(res).to.be.a('boolean').and.to.equal(true)
        return res
    }

    async findOneByShortName(shortname) {
        const res = await this.orgRepo.findOneByShortName(shortname)
        expect(res).to.be.an('object')
        return res
    }

    async getOrgUUID(shortname) {
        const res = await this.orgRepo.getOrgUUID(shortname)
        expect(res).to.equal(orgExceedingMaxIdQuota.UUID)
        return res
    }
}

class OrgAllCnas {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async aggregate(aggregation) {
        expect(aggregation).to.be.an('array')
        expect(aggregation[0]).to.have.property('$project')
        const result = await this.orgRepo.aggregate(aggregation)
        return result
    }    
}

class OrgCnasDontExist {
    constructor(){
        this.repos = new RepositoryFactory()
        this.orgRepo = this.repos.getOrgRepository()
    }

    async aggregate(aggregation) {
        expect(aggregation).to.be.an('array')
        expect(aggregation[0]).to.have.property('$project')
        const result = await this.orgRepo.aggregate(aggregation)
        return result
    }   
}

/* -------- Cve Id Repositories -------- */
class NullCveIdRepo {
    constructor(){}

    async countDocuments(query) {
        return null
    }
}

class CveIdOwnerIdQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.cveIdRepo = this.repos.getCveIdRepository()
    }

    async countDocuments(query) {
        expect(query).to.have.property('owning_cna').and.to.equal(owningOrg.UUID)
        const res = await this.cveIdRepo.countDocuments(query)
        return res
    }
}

class CveIdSecretariatIdQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.cveIdRepo = this.repos.getCveIdRepository()
    }

    async countDocuments(query) {
        expect(query).to.have.property('owning_cna').and.to.equal(existentOrg.UUID)
        const res = await this.cveIdRepo.countDocuments(query)
        return res
    }
}

class CveIdExceedsMinQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.cveIdRepo = this.repos.getCveIdRepository()
    }

    async countDocuments(query) {
        expect(query).to.have.property('owning_cna').and.to.equal(orgWithNegativeIdQuota.UUID)
        const res = await this.cveIdRepo.countDocuments(query)
        return res
    }
}

class CveIdExceedsMaxQuota {
    constructor(){
        this.repos = new RepositoryFactory()
        this.cveIdRepo = this.repos.getCveIdRepository()
    }

    async countDocuments(query) {
        expect(query).to.have.property('owning_cna').and.to.equal(orgExceedingMaxIdQuota.UUID)
        const res = await this.cveIdRepo.countDocuments(query)
        return res
    }
}

/* -------- User Repositories -------- */
class NullUserRepo {
    constructor(){}

    async getUserUUID() {
        return null
    }
}

module.exports = {
    OrgCreatedWhenUuidUndefined,
    OrgCreatedWhenUuidNull,
    OrgCreatedWhenUuidDefined,
    OrgCreatedWhenRolesDefined,
    OrgCreatedWhenRolesUndefinedIdQuotaDefined,
    OrgCreatedWhenIdQuotaUndefined,
    OrgCreatedWhenIdQuotaNull,
    OrgNotCreatedAlreadyExists,
    OrgNotUpdatedDoesNotExist,
    OrgNotUpdatedShortNameExists,
    OrgNotUpdatedIdQuotaUndefined,
    OrgNotUpdatedNoQueryParameters,
    OrgCantGetDoesNotExist,
    OrgGetDoesExist,
    OrgSecretariatIdQuota,
    OrgOwnerIdQuota,
    OrgNotOwnerOrSecretariatIdQuota,
    OrgDoesNotExistIdQuota,
    OrgExceedsMinIdQuota,
    OrgExceedsMaxIdQuota,
    OrgAllCnas,
    OrgCnasDontExist,
    NullCveIdRepo,
    CveIdSecretariatIdQuota,
    CveIdOwnerIdQuota,
    CveIdExceedsMinQuota,
    CveIdExceedsMaxQuota,
    NullUserRepo
}
