// unique name endpoints
// repository per test
// register each endpoint
const RepositoryFactory = require('../src/repositories/repositoryFactory')
const chai = require('chai')
const { existentOrg, existentUser, owningOrg, orgWithNegativeIdQuota, orgExceedingMaxIdQuota, nonExistentOrg, nonExistentUser } = require('../test/unit-tests/org/mockObjects.org')
const expect = chai.expect
const { cveIdDummy5, cveId, orgHeader, owningOrgHeader, owningOrgUser, secretariatHeader, cveIdYear, org } = require('../test/unit-tests/cve-id/mockObjects.cve-id')
const { orgB } = require('../test/unit-tests/cve-id/mockObjects.non-sequential')

const nonExistentCveId = 'CVE-2017-35437'

/* -------- Org Repositories -------- */
class OrgCreatedWhenUuidUndefined {
  async findOneByShortName (shortname) {
    return null
  }

  async updateByOrgUUID (uuid, org, settings) {
    // This is where you can actually write some test assertions!

    // For instance, you can even inspect the settings object to make sure the code passes upsert as true.

    // Or more importantly, you can make sure UUID isn't null or something and you can inspect all the fields on the org object
    // to make sure it's exactly what should be sent to the database.

    // But at a bare minimum, you can simply return null because the code isn't actually inspecting the return here.
    return null
  }

  // Notice that the following two functions are used to get information for logging. We aren't examining the logs in this test,
  // so we can again get by with returning null.
  async getOrgUUID () {
    return null
  }
}

class NullOrgRepo extends OrgCreatedWhenUuidUndefined {
  async isSecretariat (shortname) {
    return null
  }

  async isSecretariatUUID (uuid) {
    return null
  }
}

class OrgCreatedWhenUuidNull {
  async findOneByShortName (shortname) {
    return null
  }

  async updateByOrgUUID (uuid, org, settings) {
    return null
  }

  async getOrgUUID () {
    return null
  }
}

class OrgCreatedWhenUuidDefined {
  async findOneByShortName (shortname) {
    return null
  }

  async updateByOrgUUID (uuid, org, settings) {
    return null
  }

  async getOrgUUID () {
    return null
  }
}

class OrgCreatedWhenRolesDefined {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const org = await this.orgRepo.findOneByShortName(shortname)
    expect(org).to.be.a('null')
    return org
  }

  async updateByOrgUUID (uuid, org, settings) {
    expect(settings).to.have.property('upsert').and.to.be.a('boolean')
    await this.orgRepo.updateByOrgUUID(uuid, org, settings)
    return null
  }

  async getOrgUUID () {
    return null
  }
}

class OrgCreatedWhenRolesUndefinedIdQuotaDefined {
  async findOneByShortName (shortname) {
    return null
  }

  async updateByOrgUUID (uuid, org, settings) {
    return null
  }

  async getOrgUUID () {
    return null
  }
}

class OrgCreatedWhenIdQuotaUndefined {
  async findOneByShortName (shortname) {
    return null
  }

  async updateByOrgUUID (uuid, org, settings) {
    return null
  }

  async getOrgUUID () {
    return null
  }
}

class OrgCreatedWhenIdQuotaNull {
  async findOneByShortName (shortname) {
    return null
  }

  async updateByOrgUUID (uuid, org, settings) {
    return null
  }

  async getOrgUUID () {
    return null
  }
}

class OrgNotCreatedAlreadyExists {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const org = await this.orgRepo.findOneByShortName(shortname)
    expect(org).to.have.property('short_name').and.to.be.a('string')
    return org
  }

  async updateByOrgUUID (uuid, org, settings) {
    return null
  }

  async getOrgUUID () {
    return null
  }
}

class OrgNotUpdatedDoesNotExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const org = await this.orgRepo.findOneByShortName(shortname)
    expect(org).to.be.a('null')
    return org
  }

  async updateByOrgUUID (uuid, org, settings) {
    return null
  }

  async getOrgUUID () {
    return null
  }
}

class OrgNotUpdatedShortNameExists {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const org = await this.orgRepo.findOneByShortName(shortname)
    expect(org).to.have.property('short_name').and.to.be.a('string')
    return org
  }

  async updateByOrgUUID (uuid, org, settings) {
    return null
  }

  async getOrgUUID () {
    return null
  }
}

class OrgNotUpdatedIdQuotaUndefined {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const org = await this.orgRepo.findOneByShortName(shortname)
    expect(org).to.have.property('short_name').and.to.be.a('string')
    return org
  }

  async updateByOrgUUID (uuid, org, settings) {
    expect(settings).to.be.an('undefined')
    expect(uuid).to.be.a('string')
    const result = await this.orgRepo.updateByOrgUUID(uuid, org, settings)
    return result
  }

  async getOrgUUID () {
    return null
  }
}

class OrgNotUpdatedNoQueryParameters {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.equal(existentOrg.short_name)
    const org = await this.orgRepo.findOneByShortName(shortname)
    return org
  }

  async updateByOrgUUID (uuid, org, settings) {
    const result = await this.orgRepo.updateByOrgUUID(uuid, org, settings)
    return result
  }

  async getOrgUUID () {
    return null
  }
}

class OrgCantGetDoesNotExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async aggregate (aggregation) {
    expect(aggregation).to.be.an('array')
    expect(aggregation[0]).to.have.property('$match')
    const result = await this.orgRepo.aggregate(aggregation)
    return result
  }
}

class OrgGetDoesExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async aggregate (aggregation) {
    expect(aggregation).to.be.an('array')
    expect(aggregation[0]).to.have.property('$match')
    const result = await this.orgRepo.aggregate(aggregation)
    return result
  }
}

class OrgSecretariatIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    const res = await this.orgRepo.isSecretariat(shortname)
    expect(res).to.be.a('boolean').and.to.equal(true)
    return res
  }

  async findOneByShortName (shortname) {
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.be.an('object')
    return res
  }

  async getOrgUUID (shortname) {
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgOwnerIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.isSecretariat(shortname)
    expect(res).to.be.a('boolean').and.to.equal(false)
    return res
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.be.an('object')
    return res
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgNotOwnerOrSecretariatIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.isSecretariat(shortname)
    expect(res).to.be.a('boolean').and.to.equal(false)
    return res
  }

  async findOneByShortName (shortname) {
    return null
  }

  async getOrgUUID (shortname) {
    return null
  }
}

class OrgDoesNotExistIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    const res = await this.orgRepo.isSecretariat(shortname)
    expect(res).to.be.a('boolean').and.to.equal(true)
    return res
  }

  async findOneByShortName (shortname) {
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.be.a('null')
    return res
  }
}

class OrgExceedsMinIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    const res = await this.orgRepo.isSecretariat(shortname)
    expect(res).to.be.a('boolean').and.to.equal(true)
    return res
  }

  async findOneByShortName (shortname) {
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.be.an('object')
    return res
  }

  async getOrgUUID (shortname) {
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.equal(orgWithNegativeIdQuota.UUID)
    return res
  }
}

class OrgExceedsMaxIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    const res = await this.orgRepo.isSecretariat(shortname)
    expect(res).to.be.a('boolean').and.to.equal(true)
    return res
  }

  async findOneByShortName (shortname) {
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.be.an('object')
    return res
  }

  async getOrgUUID (shortname) {
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.equal(orgExceedingMaxIdQuota.UUID)
    return res
  }
}

class OrgAllCnas {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async aggregate (aggregation) {
    expect(aggregation).to.be.an('array')
    expect(aggregation[0]).to.have.property('$project')
    const result = await this.orgRepo.aggregate(aggregation)
    return result
  }
}

class OrgCnasDontExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async aggregate (aggregation) {
    expect(aggregation).to.be.an('array')
    expect(aggregation[0]).to.have.property('$project')
    const result = await this.orgRepo.aggregate(aggregation)
    return result
  }
}

class OrgCantCreateUserCnaDoesNotExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.equal(nonExistentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgCantCreateUserCnaDoesNotMatch {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.equal(existentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string').and.to.equal(owningOrg.UUID)
    const res = await this.orgRepo.findOneByUUID(uuid)
    return res
  }
}

// This test repo is also used for other tests that pass the same
// values
class OrgCreatedUserOrgUndefined {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.equal(existentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.equal(existentOrg.UUID)
    const res = await this.orgRepo.findOneByUUID(uuid)
    return res
  }
}

class OrgUserNotUpdatedOrgDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.equal(nonExistentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgUserNotUpdatedUserDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.equal(existentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgUserNotUpdatedOrgQueryDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgUserSecretNotResetOrgDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.equal(nonExistentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgUserSecretNotResetUserDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.equal(existentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgUserSecretReset {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.equal(existentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgGetUserOrgDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.equal(nonExistentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgGetUserUserDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.equal(existentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgGetUser extends OrgGetUserUserDoesntExist {}

class OrgGetCveIdNotOwnerOrgNotReserved {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.equal(orgHeader['CVE-API-ORG'])
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }

  async isSecretariatUUID (uuid) {
    expect(uuid).to.be.a('string')
    const res = await this.orgRepo.isSecretariatUUID(uuid)
    expect(res).to.be.a('boolean').and.to.equal(false)
    return res
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    const res = await this.orgRepo.findOneByUUID(uuid)
    return res
  }
}

class OrgGetCveIdOwningOrg extends OrgGetCveIdNotOwnerOrgNotReserved {
  async getOrgUUID (shortname) {
    expect(shortname).to.equal(owningOrgHeader['CVE-API-ORG'])
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgGetCveIdRequestorSecretariat extends OrgGetCveIdNotOwnerOrgNotReserved {
  async getOrgUUID (shortname) {
    expect(shortname).to.equal(secretariatHeader['CVE-API-ORG'])
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }

  async isSecretariatUUID (uuid) {
    expect(uuid).to.be.a('string')
    const res = await this.orgRepo.isSecretariatUUID(uuid)
    expect(res).to.be.a('boolean').and.to.equal(true)
    return res
  }
}

class OrgGetCveIdNoCveIdsWithParams {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    expect(shortname).to.equal(owningOrgHeader['CVE-API-ORG'])
    const res = await this.orgRepo.isSecretariat(shortname)
    return res
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.equal(owningOrgHeader['CVE-API-ORG'])
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgGetCveIdRequestorSecretariatNoQuery extends OrgGetCveIdRequestorSecretariat {
  async isSecretariat (shortname) {
    expect(shortname).to.equal(secretariatHeader['CVE-API-ORG'])
    const res = await this.orgRepo.isSecretariat(shortname)
    return res
  }
}

class OrgModifyCveIdDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.equal(secretariatHeader['CVE-API-ORG'])
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgModifyCveIdCnaDoesntExist extends OrgModifyCveIdDoesntExist {
  async getOrgUUID (shortname) {
    expect(shortname).to.equal(nonExistentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgModifyCveIdCnaAndStateModified extends OrgModifyCveIdDoesntExist {
  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    const res = await this.orgRepo.findOneByUUID(uuid)
    return res
  }
}

class OrgReserveNotOwningOrg {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    expect(shortname).to.equal(orgHeader['CVE-API-ORG'])
    const res = await this.orgRepo.isSecretariat(shortname)
    return res
  }
}

class OrgReserveShortNameUndefined extends OrgReserveNotOwningOrg {
  async isSecretariat (shortname) {
    expect(shortname).to.equal(secretariatHeader['CVE-API-ORG'])
    const res = await this.orgRepo.isSecretariat(shortname)
    return res
  }
}

class OrgReserveOrgDoesntExist extends OrgReserveShortNameUndefined {
  async findOneByShortName (shortname) {
    expect(shortname).to.equal(nonExistentOrg.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    return res
  }
}

class OrgReserveAmountLargerThanNonSequential extends OrgReserveOrgDoesntExist {
  async findOneByShortName (shortname) {
    expect(shortname).to.equal(org.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    return res
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res
  }
}

class OrgReserveYear2025RangeDoesntExist extends OrgReserveAmountLargerThanNonSequential {
  async findOneByShortName (shortname) {
    expect(shortname).to.equal(owningOrg.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    return res
  }
}

class OrgReserveSequentialPriorityIsFull extends OrgReserveYear2025RangeDoesntExist {
  async isSecretariat (shortname) {
    expect(shortname).to.equal(owningOrgHeader['CVE-API-ORG'])
    const res = await this.orgRepo.isSecretariat(shortname)
    return res
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgReserveYear2025RangeDoesntExistSequential extends OrgReserveYear2025RangeDoesntExist {
  async findOneByShortName (shortname) {
    expect(shortname).to.equal(owningOrg.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    return res
  }
}

class OrgReserveYear2020Sequential extends OrgReserveSequentialPriorityIsFull {}

class OrgCveIdRange2022 {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    expect(shortname).to.equal(secretariatHeader['CVE-API-ORG'])
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res
  }
}

class OrgReserveUserB10Ids extends OrgReserveYear2020Sequential {
  async isSecretariat (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.isSecretariat(shortname)
    return res
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.equal(orgB.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    return res
  }
}

class OrgReserveBase extends OrgReserveYear2020Sequential {
  async isSecretariat (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.isSecretariat(shortname)
    return res
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.findOneByShortName(shortname)
    return res
  }
}

/* -------- Cve Id Repositories -------- */
class NullCveIdRepo {
  async countDocuments (query) {
    return null
  }
}

class CveIdOwnerIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async countDocuments (query) {
    expect(query).to.have.property('owning_cna').and.to.equal(owningOrg.UUID)
    const res = await this.cveIdRepo.countDocuments(query)
    return res
  }
}

class CveIdSecretariatIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async countDocuments (query) {
    expect(query).to.have.property('owning_cna').and.to.equal(existentOrg.UUID)
    const res = await this.cveIdRepo.countDocuments(query)
    return res
  }
}

class CveIdExceedsMinQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async countDocuments (query) {
    expect(query).to.have.property('owning_cna').and.to.equal(orgWithNegativeIdQuota.UUID)
    const res = await this.cveIdRepo.countDocuments(query)
    return res
  }
}

class CveIdExceedsMaxQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async countDocuments (query) {
    expect(query).to.have.property('owning_cna').and.to.equal(orgExceedingMaxIdQuota.UUID)
    const res = await this.cveIdRepo.countDocuments(query)
    return res
  }
}

class CveIdGetCveIdDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async findOneByCveId (id) {
    expect(id).to.be.a('string')
    const res = await this.cveIdRepo.findOneByCveId(id)
    return res
  }
}

class CveIdGetCveIdAvailable extends CveIdGetCveIdDoesntExist {
  async findOneByCveId (id) {
    expect(id).to.equal(cveIdDummy5.cve_id)
    const res = await this.cveIdRepo.findOneByCveId(id)
    return res
  }
}

class CveIdGetCveIdNotOwningOrg extends CveIdGetCveIdDoesntExist {
  async findOneByCveId (id) {
    expect(id).to.equal(cveId)
    const res = await this.cveIdRepo.findOneByCveId(id)
    return res
  }
}

class CveIdGetCveIdNoResultsWithParams {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    expect(aggregation[0].$match).to.have.property('state').and.to.equal('public')
    expect(aggregation[0].$match).to.have.property('cve_year').and.to.equal('2010')
    const res = await this.cveIdRepo.aggregate(aggregation)
    return res
  }
}

class CveIdGetCveIdStateProvided extends CveIdGetCveIdNoResultsWithParams {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    expect(aggregation[0].$match).to.have.property('state').and.to.equal('PUBLIC')
    const res = await this.cveIdRepo.aggregate(aggregation)
    return res
  }
}

class CveIdGetCveIdNoAvailableCves extends CveIdGetCveIdNoResultsWithParams {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    expect(aggregation[0].$match).to.have.property('state').and.to.equal('AVAILABLE')
    const res = await this.cveIdRepo.aggregate(aggregation)
    return res
  }
}

class CveIdGetCveIdYearProvided extends CveIdGetCveIdNoResultsWithParams {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    expect(aggregation[0].$match).to.have.property('cve_year').and.to.equal(cveIdYear)
    const res = await this.cveIdRepo.aggregate(aggregation)
    return res
  }
}

class CveIdGetCveIdNotSecretariatNoQuery extends CveIdGetCveIdNoResultsWithParams {
  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    const res = await this.cveIdRepo.aggregate(aggregation)
    return res
  }
}

class CveIdModifyCveIdDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async findOneByCveId (id) {
    expect(id).to.equal(nonExistentCveId)
    const res = this.cveIdRepo.findOneByCveId(id)
    return res
  }
}

class CveIdModifyCveIdCnaAndStateModified extends CveIdModifyCveIdDoesntExist {
  async findOneByCveId (id) {
    expect(id).to.equal(cveId)
    const res = this.cveIdRepo.findOneByCveId(id)
    return res
  }

  async findOneAndUpdate (query, updated_cve_id, options) {
    expect(query.cve_id).to.equal(cveId)
    const res = this.cveIdRepo.findOneAndUpdate(query, updated_cve_id, options)
    return res
  }
}

class CveIdReserveSequentialPriorityIsFull {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async insertMany (documents) {
    expect(documents).to.be.an('array')
    const res = await this.cveIdRepo.insertMany(documents)
    return res
  }

  async countDocuments (query) {
    expect(query).to.have.property('owning_cna')
    expect(query).to.have.property('state').and.to.be.equal('RESERVED')
    const res = await this.cveIdRepo.countDocuments(query)
    return res
  }
}

class CveIdReservePoolIncremented10Ids extends CveIdReserveSequentialPriorityIsFull {
  async find (query, options) {
    expect(options).to.be.an('object').and.to.have.property('limit')
    const res = await this.cveIdRepo.find(query, options)
    return res
  }

  async findOneAndUpdate (query, updated_cve_id, options) {
    expect(query).to.have.property('cve_id')
    expect(updated_cve_id).to.be.an('object')
    expect(options).to.have.property('new')
    const res = await this.cveIdRepo.findOneAndUpdate(query, updated_cve_id, options)
    return res
  }
}

class CveIdReserveBase extends CveIdReservePoolIncremented10Ids {}

/* -------- Cve Id Repositories -------- */
class CveIdRangeReserveYearDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
  }

  async findOne (query) {
    expect(query).to.have.property('cve_year').and.to.be.a('number')
    const res = await this.cveIdRangeRepo.findOne(query)
    return res
  }
}

class CveIdRangeReserveSequentialPriorityIsFull extends CveIdRangeReserveYearDoesntExist {
  async findOneAndUpdate (query, set, options) {
    expect(query).to.be.an('object')
    expect(set).to.be.an('object')
    expect(options).to.be.an('object')
    const res = await this.cveIdRangeRepo.findOneAndUpdate(query, set, options)
    return res
  }
}

class CveIdRange2022 extends CveIdRangeReserveSequentialPriorityIsFull {}

class CveIdRangeReserveBase extends CveIdRangeReserveSequentialPriorityIsFull {}

/* -------- User Repositories -------- */
class NullUserRepo {
  constructor () {}

  async getUserUUID () {
    return null
  }
}

class UserNotCreatedAlreadyExists {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async findOneByUserNameAndOrgUUID (username, uuid) {
    expect(username).to.equal(existentUser.username)
    expect(uuid).to.be.a('string')
    const res = await this.userRepo.findOneByUserNameAndOrgUUID(username, uuid)
    return res
  }
}

// This test repo is also used for other tests that pass the same
// values
class UserCreatedOrgUndefined {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async findOneByUserNameAndOrgUUID (username, uuid) {
    expect(username).to.equal(nonExistentUser.username)
    expect(uuid).to.be.a('string')
    const res = await this.userRepo.findOneByUserNameAndOrgUUID(username, uuid)
    return res
  }

  async updateByUserNameAndOrgUUID (username, uuid, user, options) {
    expect(options).to.have.property('upsert').and.to.equal(true)
    expect(username).to.equal(nonExistentUser.username)
    expect(uuid).to.equal(existentOrg.UUID)
    expect(user).to.be.an('object')
    const res = await this.userRepo.updateByUserNameAndOrgUUID(username, uuid, user, options)
    return res
  }
}

class UserNotUpdatedUserDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async findOneByUserNameAndOrgUUID (username, uuid) {
    expect(username).to.equal(nonExistentUser.username)
    expect(uuid).to.be.a('string')
    const res = await this.userRepo.findOneByUserNameAndOrgUUID(username, uuid)
    return res
  }
}

class UserNotUpdatedOrgQueryDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async findOneByUserNameAndOrgUUID (username, uuid) {
    expect(username).to.equal(existentUser.username)
    expect(uuid).to.be.a('string')
    const res = await this.userRepo.findOneByUserNameAndOrgUUID(username, uuid)
    return res
  }
}

class UserNotUpdatedNoQuery extends UserNotUpdatedOrgQueryDoesntExist {
  async updateByUserNameAndOrgUUID (username, uuid, user, options) {
    expect(options).to.be.an('undefined')
    expect(username).to.equal(existentUser.username)
    expect(uuid).to.equal(existentOrg.UUID)
    expect(user).to.be.an('object')
    const res = await this.userRepo.updateByUserNameAndOrgUUID(username, uuid, user, options)
    return res
  }

  async getUserUUID (user, uuid) {
    expect(uuid).to.be.a('string')
    expect(user).to.be.a('string')
    const res = await this.userRepo.getUserUUID(user, uuid)
    return res
  }
}

class UserSecretNotResetUserDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async updateByUserNameAndOrgUUID (username, uuid, user, options) {
    expect(options).to.be.an('undefined')
    expect(username).to.equal(nonExistentUser.username)
    expect(uuid).to.equal(existentOrg.UUID)
    expect(user).to.be.an('object')
    const res = await this.userRepo.updateByUserNameAndOrgUUID(username, uuid, user, options)
    return res
  }
}

class UserSecretReset {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async updateByUserNameAndOrgUUID (username, uuid, user, options) {
    expect(options).to.be.an('undefined')
    expect(username).to.equal(existentUser.username)
    expect(uuid).to.equal(existentOrg.UUID)
    expect(user).to.be.an('object')
    const res = await this.userRepo.updateByUserNameAndOrgUUID(username, uuid, user, options)
    return res
  }

  async getUserUUID (user, uuid) {
    expect(uuid).to.be.a('string')
    expect(user).to.be.a('string')
    const res = await this.userRepo.getUserUUID(user, uuid)
    return res
  }
}

class UserGetUserDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async aggregate (aggregation) {
    expect(aggregation).to.be.an('array')
    expect(aggregation[0]).to.have.property('$match')
    const res = await this.userRepo.aggregate(aggregation)
    return res
  }
}

class UserGetUser extends UserGetUserDoesntExist {}

class UserGetCveIdOwningOrg {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.equal(owningOrgUser.UUID)
    const res = await this.userRepo.findOneByUUID(uuid)
    return res
  }
}

class UserModifyCveIdCnaAndStateModified extends UserGetCveIdOwningOrg {
  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    const res = await this.userRepo.findOneByUUID(uuid)
    return res
  }

  async getUserUUID (user, org_uuid) {
    expect(user).to.equal(secretariatHeader['CVE-API-USER'])
    expect(org_uuid).to.be.a('string')
    const res = await this.userRepo.getUserUUID(user, org_uuid)
    return res
  }
}

class UserReserveSequentialPriorityIsFull {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async findOneByUserNameAndOrgUUID (username, org_uuid) {
    expect(username).to.be.a('string')
    expect(org_uuid).to.be.a('string')
    const res = await this.userRepo.findOneByUserNameAndOrgUUID(username, org_uuid)
    return res
  }
}

class UserReserveBase extends UserReserveSequentialPriorityIsFull {}

class UserCveIdRange2022 {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async getUserUUID (user, org_uuid) {
    expect(user).to.equal(secretariatHeader['CVE-API-USER'])
    expect(org_uuid).to.be.a('string')
    const res = await this.userRepo.getUserUUID(user, org_uuid)
    return res
  }
}

module.exports = {
  NullOrgRepo,
  OrgCreatedWhenUuidUndefined,
  OrgCreatedWhenUuidNull,
  OrgCreatedWhenUuidDefined,
  OrgCreatedWhenRolesDefined,
  OrgCreatedWhenRolesUndefinedIdQuotaDefined,
  OrgCreatedWhenIdQuotaUndefined,
  OrgCreatedWhenIdQuotaNull,
  OrgNotCreatedAlreadyExists,
  OrgNotUpdatedDoesNotExist,
  OrgNotUpdatedShortNameExists,
  OrgNotUpdatedIdQuotaUndefined,
  OrgNotUpdatedNoQueryParameters,
  OrgCantGetDoesNotExist,
  OrgGetDoesExist,
  OrgSecretariatIdQuota,
  OrgOwnerIdQuota,
  OrgNotOwnerOrSecretariatIdQuota,
  OrgDoesNotExistIdQuota,
  OrgExceedsMinIdQuota,
  OrgExceedsMaxIdQuota,
  OrgAllCnas,
  OrgCnasDontExist,
  OrgCantCreateUserCnaDoesNotExist,
  OrgCantCreateUserCnaDoesNotMatch,
  OrgCreatedUserOrgUndefined,
  OrgUserNotUpdatedOrgDoesntExist,
  OrgUserNotUpdatedUserDoesntExist,
  OrgUserNotUpdatedOrgQueryDoesntExist,
  OrgUserSecretNotResetOrgDoesntExist,
  OrgUserSecretNotResetUserDoesntExist,
  OrgUserSecretReset,
  OrgGetUserOrgDoesntExist,
  OrgGetUserUserDoesntExist,
  OrgGetUser,
  OrgGetCveIdNotOwnerOrgNotReserved,
  OrgGetCveIdOwningOrg,
  OrgGetCveIdRequestorSecretariat,
  OrgGetCveIdNoCveIdsWithParams,
  OrgGetCveIdRequestorSecretariatNoQuery,
  OrgModifyCveIdDoesntExist,
  OrgModifyCveIdCnaDoesntExist,
  OrgModifyCveIdCnaAndStateModified,
  OrgReserveNotOwningOrg,
  OrgReserveShortNameUndefined,
  OrgReserveOrgDoesntExist,
  OrgReserveAmountLargerThanNonSequential,
  OrgReserveYear2025RangeDoesntExist,
  OrgReserveSequentialPriorityIsFull,
  OrgReserveYear2025RangeDoesntExistSequential,
  OrgReserveYear2020Sequential,
  OrgReserveBase,
  OrgCveIdRange2022,
  OrgReserveUserB10Ids,
  NullCveIdRepo,
  CveIdGetCveIdDoesntExist,
  CveIdGetCveIdAvailable,
  CveIdGetCveIdNotOwningOrg,
  CveIdSecretariatIdQuota,
  CveIdOwnerIdQuota,
  CveIdExceedsMinQuota,
  CveIdExceedsMaxQuota,
  CveIdGetCveIdNoResultsWithParams,
  CveIdGetCveIdStateProvided,
  CveIdGetCveIdNoAvailableCves,
  CveIdGetCveIdYearProvided,
  CveIdGetCveIdNotSecretariatNoQuery,
  CveIdModifyCveIdDoesntExist,
  CveIdModifyCveIdCnaAndStateModified,
  CveIdRangeReserveYearDoesntExist,
  CveIdReserveSequentialPriorityIsFull,
  CveIdReservePoolIncremented10Ids,
  CveIdReserveBase,
  CveIdRangeReserveSequentialPriorityIsFull,
  CveIdRange2022,
  CveIdRangeReserveBase,
  NullUserRepo,
  UserCreatedOrgUndefined,
  UserNotCreatedAlreadyExists,
  UserNotUpdatedUserDoesntExist,
  UserNotUpdatedOrgQueryDoesntExist,
  UserNotUpdatedNoQuery,
  UserSecretNotResetUserDoesntExist,
  UserSecretReset,
  UserGetUserDoesntExist,
  UserGetUser,
  UserGetCveIdOwningOrg,
  UserModifyCveIdCnaAndStateModified,
  UserReserveSequentialPriorityIsFull,
  UserReserveBase,
  UserCveIdRange2022
}
