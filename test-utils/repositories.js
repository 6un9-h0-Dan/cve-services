// unique name endpoints
// repository per test
// register each endpoint
const RepositoryFactory = require('../src/repositories/repositoryFactory')
const chai = require('chai')
const { existentOrg, existentUser, owningOrg, orgWithNegativeIdQuota, orgExceedingMaxIdQuota, nonExistentUser } = require('../test/unit-tests/org/mockObjects.org')
const expect = chai.expect
const { cveDummy5, cveId, orgHeader, owningOrgHeader, owningOrgUser, secretariatHeader, cveIdYear, org } = require('../test/unit-tests/cve-id/mockObjects.cve-id')
const { orgB } = require('../test/unit-tests/cve-id/mockObjects.non-sequential')

/* -------- Org Repositories -------- */
class OrgCreated {
  async findOneByShortName (shortname) {
    return null
  }

  async updateByOrgUUID (uuid, org, settings) {
    // This is where you can actually write some test assertions!
    // For instance, you can even inspect the settings object to make sure the code passes upsert as true.
    // Or more importantly, you can make sure UUID isn't null or something and you can inspect all the fields on the org object
    // to make sure it's exactly what should be sent to the database.
    // But at a bare minimum, you can simply return null because the code isn't actually inspecting the return here.
    return null
  }

  // Notice that the following two functions are used to get information for logging. We aren't examining the logs in this test,
  // so we can again get by with returning null.
  async getOrgUUID () {
    return null
  }
}

class NullOrgRepo {
  async findOneByShortName (shortname) {
    return null
  }

  async updateByOrgUUID (uuid, org, settings) {
    return null
  }

  async getOrgUUID () {
    return null
  }

  async isSecretariat (shortname) {
    return null
  }

  async isSecretariatUUID (uuid) {
    return null
  }
}

class OrgCreatedWhenRolesDefined {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async findOneByShortName (shortname) {
    return null
  }

  async updateByOrgUUID (uuid, org, settings) {
    expect(settings).to.have.property('upsert').and.to.be.a('boolean')
    expect(uuid).to.be.a('string')
    expect(org).to.be.a('object')
    await this.orgRepo.updateByOrgUUID(uuid, org, settings) // TODO: update org object
    return null
  }

  async getOrgUUID () {
    return null
  }
}

class OrgNotCreatedAlreadyExists {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const org = await this.orgRepo.findOneByShortName(shortname)
    expect(org).to.have.property('short_name').and.to.be.a('string')
    return org // return non-null objects
  }
}

class OrgNotUpdatedDoesNotExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async findOneByShortName (shortname) {
    return null
  }
}

class OrgNotUpdatedShortNameExists {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const org = await this.orgRepo.findOneByShortName(shortname)
    expect(org).to.have.property('short_name').and.to.be.a('string')
    return org // return non-null objects
  }
}

class OrgNotUpdatedIdQuotaUndefined {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const org = await this.orgRepo.findOneByShortName(shortname)
    expect(org).to.have.property('short_name').and.to.be.a('string')
    return org // return non-null objects
  }

  async updateByOrgUUID (uuid, org, settings) {
    expect(settings).to.be.an('undefined')
    expect(uuid).to.be.a('string')
    expect(org).to.be.a('object')
    const result = await this.orgRepo.updateByOrgUUID(uuid, org, settings) // TODO: update org object
    return result // return non-null objects
  }

  async getOrgUUID () {
    return null
  }
}

class OrgNotUpdatedNoQueryParameters {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(existentOrg.short_name)
    const org = await this.orgRepo.findOneByShortName(shortname)
    expect(org).to.have.property('short_name').and.to.be.a('string')
    return org // return non-null objects
  }

  async updateByOrgUUID (uuid, org, settings) {
    expect(settings).to.be.a('undefined')
    expect(uuid).to.be.a('string')
    expect(org).to.be.a('object')
    const result = await this.orgRepo.updateByOrgUUID(uuid, org, settings) // TODO: update org object
    return result // return non-null objects
  }

  async getOrgUUID () {
    return null
  }
}

class OrgGet {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async aggregate (aggregation) {
    expect(aggregation).to.be.an('array')
    expect(aggregation[0]).to.have.property('$match')
    const result = await this.orgRepo.aggregate(aggregation)
    return result // return non-null objects
  }
}

class OrgSecretariatIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

class OrgOwnerIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return false
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

class OrgNotOwnerOrSecretariatIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return false
  }
}

class OrgDoesNotExistIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    return null
  }
}

class OrgExceedsMinIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string').and.to.equal(orgWithNegativeIdQuota.UUID)
    return res // return non-null objects
  }
}

class OrgExceedsMaxIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string').and.to.equal(orgExceedingMaxIdQuota.UUID)
    return res // return non-null objects
  }
}

class OrgsGet {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async aggregate (aggregation) {
    expect(aggregation).to.be.an('array')
    expect(aggregation[0]).to.have.property('$project')
    const result = await this.orgRepo.aggregate(aggregation)
    return result // return non-null objects
  }
}

class OrgCantCreateUserCnaDoesNotExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    return null
  }
}

class OrgCantCreateUserCnaDoesNotMatch {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.be.equal(existentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string').and.to.equal(owningOrg.UUID)
    const res = await this.orgRepo.findOneByUUID(uuid)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }
}

// This test repo is also used for other tests that pass the same values
class OrgCreatedUserOrgUndefined {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.equal(existentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string').and.to.equal(existentOrg.UUID)
    const res = await this.orgRepo.findOneByUUID(uuid)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }
}

class OrgUserNotUpdatedOrgDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    return null
  }
}

class OrgUserNotUpdatedUserDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(existentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // non-null objects
  }
}

class OrgUserNotUpdatedOrgQueryDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    return res // return null and non-null objects
  }
}

class OrgUserSecretNotResetOrgDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    return null
  }
}

class OrgUserSecretNotResetUserDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(existentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

class OrgUserSecretReset {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(existentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

class OrgGetUserOrgDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    return null
  }
}

class OrgGetUser {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(existentOrg.short_name)
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

class OrgGetCveIdNotOwnerOrgReserved {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(orgHeader['CVE-API-ORG'])
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }

  async isSecretariatUUID (uuid) {
    return false
  }
}

class OrgGetCveIdNotOwnerOrgNotReserved {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(orgHeader['CVE-API-ORG'])
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }

  async isSecretariatUUID (uuid) {
    return false
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    const res = await this.orgRepo.findOneByUUID(uuid)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }
}

class OrgGetCveIdOwningOrg {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(owningOrgHeader['CVE-API-ORG'])
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }

  async isSecretariatUUID (uuid) {
    return false
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    const res = await this.orgRepo.findOneByUUID(uuid)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }
}

class OrgGetCveIdRequestorSecretariat {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(secretariatHeader['CVE-API-ORG'])
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }

  async isSecretariatUUID (uuid) {
    return true
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    const res = await this.orgRepo.findOneByUUID(uuid)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }
}

class OrgGetCveIdNoCveIdsWithParams {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return false
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(owningOrgHeader['CVE-API-ORG'])
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

class OrgGetCveIdRequestorSecretariatNoQuery {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(secretariatHeader['CVE-API-ORG'])
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }

  async isSecretariatUUID (uuid) {
    return true
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    const res = await this.orgRepo.findOneByUUID(uuid)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async isSecretariat (shortname) {
    return true
  }
}

class OrgModifyCveIdDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    return null
  }
}

class OrgModifyCveIdCnaDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    return null
  }
}

class OrgModifyCveIdCnaAndStateModified {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    const res = await this.orgRepo.findOneByUUID(uuid)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }
}

class OrgReserveNotOwningOrg {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return false
  }
}

class OrgReserveShortNameUndefined {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return true
  }
}

class OrgReserveOrgDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    return null
  }
}

class OrgReserveAmountLargerThanNonSequential {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(org.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res // return non-null objects
  }
}
class OrgReserveAmountGreaterIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(org.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }
}

class OrgReserveYear2025RangeDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(owningOrg.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res // return non-null objects
  }
}

class OrgReserveSequentialPriorityIsFull {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return false
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(owningOrg.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res // return non-null objects
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

class OrgReserveSequentialIsFull {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return false
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(owningOrg.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res // return non-null objects
  }
}

class OrgReserveYear2025RangeDoesntExistSequential {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return true
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(owningOrg.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res // return non-null objects
  }
}

class OrgReserveUserB10Ids {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return false
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string').and.to.equal(orgB.short_name)
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res // return non-null objects
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

class OrgReserveBase {
  constructor () {
    this.repos = new RepositoryFactory()
    this.orgRepo = this.repos.getOrgRepository()
  }

  async isSecretariat (shortname) {
    return false
  }

  async findOneByShortName (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.findOneByShortName(shortname)
    expect(res).to.have.property('short_name').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.have.property('short_name')
    expect(query).to.have.property('inUse')
    expect(set).to.have.property('$set').and.to.have.property('inUse')
    expect(options).to.have.property('new')
    const res = await this.orgRepo.findOneAndUpdate(query, set, options)
    return res // return non-null objects
  }

  async getOrgUUID (shortname) {
    expect(shortname).to.be.a('string')
    const res = await this.orgRepo.getOrgUUID(shortname)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

/* -------- Cve Id Repositories -------- */
class NullCveIdRepo {
  async countDocuments (query) {
    return null
  }
}

class CveIdOwnerIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async countDocuments (query) {
    return 0
  }
}

class CveIdSecretariatIdQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async countDocuments (query) {
    return 0
  }
}

class CveIdExceedsMinQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async countDocuments (query) {
    return 0
  }
}

class CveIdExceedsMaxQuota {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async countDocuments (query) {
    return 0
  }
}

class CveIdGetCveIdDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async findOneByCveId (id) {
    return null
  }
}

class CveIdGetCveIdAvailable {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async findOneByCveId (id) {
    expect(id).to.be.a('string').and.to.equal(cveDummy5.cve_id)
    const res = await this.cveIdRepo.findOneByCveId(id)
    expect(res).to.have.property('cve_id').and.to.be.a('string')
    return res // return non-null objects
  }
}

class CveIdGetCveIdNotOwningOrg {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async findOneByCveId (id) {
    expect(id).to.be.a('string').and.to.equal(cveId)
    const res = await this.cveIdRepo.findOneByCveId(id)
    expect(res).to.have.property('cve_id').and.to.be.a('string')
    return res // return non-null objects
  }
}

class CveIdGetCveIdNoResultsWithParams {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async aggregate (aggregation) {
    return []
  }
}

class CveIdGetCveIdStateProvided {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    expect(aggregation[0].$match).to.have.property('state').and.to.equal('PUBLIC')
    const res = await this.cveIdRepo.aggregate(aggregation)
    return res // return non-null objects
  }
}

class CveIdGetCveIdNoAvailableCves {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async aggregate (aggregation) {
    return []
  }
}

class CveIdGetCveIdYearProvided {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    expect(aggregation[0].$match).to.have.property('cve_year').and.to.equal(cveIdYear)
    const res = await this.cveIdRepo.aggregate(aggregation)
    return res // return non-null objects
  }
}

class CveIdGetCveIdNotSecretariatNoQuery {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    const res = await this.cveIdRepo.aggregate(aggregation)
    return res // return non-null objects
  }
}

class CveIdModifyCveIdDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async findOneByCveId (id) {
    return null
  }
}

class CveIdModifyCveIdCnaAndStateModified {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async findOneByCveId (id) {
    expect(id).to.be.a('string').and.to.equal(cveId)
    const res = await this.cveIdRepo.findOneByCveId(id)
    expect(res).to.have.property('cve_id').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, updatedCveId, options) {
    expect(query.cve_id).to.be.a('string').and.to.equal(cveId)
    expect(updatedCveId).to.be.an('object')
    expect(options).to.have.property('new')
    const res = await this.cveIdRepo.findOneAndUpdate(query, updatedCveId, options)
    expect(res).to.have.property('cve_id').and.to.be.a('string')
    return res // return non-null objects
  }
}

class CveIdReserveSequentialPriorityIsFull {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async insertMany (documents) {
    expect(documents).to.be.an('array')
    const res = await this.cveIdRepo.insertMany(documents)
    expect(documents).to.be.an('array').and.to.have.lengthOf.above(0)
    return res // return non-null objects
  }

  async countDocuments (query) {
    expect(query).to.have.property('owning_cna')
    expect(query).to.have.property('state').and.to.be.equal('RESERVED')
    const res = await this.cveIdRepo.countDocuments(query)
    return res // return different count values
  }
}

class CveIdReservePoolIncremented10Ids {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRepo = this.repos.getCveIdRepository()
  }

  async insertMany (documents) {
    expect(documents).to.be.an('array')
    const res = await this.cveIdRepo.insertMany(documents)
    expect(documents).to.be.an('array').and.to.have.lengthOf.above(0)
    return res // return non-null objects
  }

  async countDocuments (query) {
    expect(query).to.have.property('owning_cna')
    expect(query).to.have.property('state').and.to.be.equal('RESERVED')
    const res = await this.cveIdRepo.countDocuments(query)
    return res // return different count values
  }

  async find (query, options) {
    expect(options).to.be.an('object').and.to.have.property('limit')
    const res = await this.cveIdRepo.find(query, options)
    return res // return empty and not empty arrays
  }

  async findOneAndUpdate (query, updatedCveId, options) {
    expect(query.cve_id).to.be.a('string')
    expect(updatedCveId).to.be.an('object')
    expect(options).to.have.property('new')
    const res = await this.cveIdRepo.findOneAndUpdate(query, updatedCveId, options)
    expect(res).to.have.property('cve_id').and.to.be.a('string')
    return res // return non-null objects
  }
}

/* -------- Cve Id Range Repositories -------- */
class CveIdRangeReserveYearDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
  }

  async findOne (query) {
    return null
  }
}

class CveIdRangeReserveSequentialPriorityIsFull {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
  }

  async findOne (query) {
    expect(query).to.have.property('cve_year').and.to.be.a('string')
    const res = await this.cveIdRangeRepo.findOne(query)
    expect(res).to.have.property('cve_year').and.to.be.a('string')
    return res // return non-null objects
  }

  async findOneAndUpdate (query, set, options) {
    expect(query).to.be.an('object')
    expect(set).to.be.an('object')
    expect(options).to.be.an('object')
    const res = await this.cveIdRangeRepo.findOneAndUpdate(query, set, options)
    return res // return null and non-null objects
  }
}

class CveIdRangeReserveSequentialIsFull {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
  }

  async findOne (query) {
    return null
  }
}

class CveIdRangeReserveNonSequentialIsFull {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
  }

  async findOne (query) {
    return null
  }
}

class CveIdRange2022NotExists {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
  }

  async findOne (query) {
    return null
  }

  async findOneAndUpdate (query, set, options) {
    await this.cveIdRangeRepo.findOneAndUpdate(query, set, options)
    return null
  }
}

class CveIdRange2022Exists {
  constructor () {
    this.repos = new RepositoryFactory()
    this.cveIdRangeRepo = this.repos.getCveIdRangeRepository()
  }

  async findOne (query) {
    expect(query).to.have.property('cve_year').and.to.be.a('string')
    const res = await this.cveIdRangeRepo.findOne(query)
    expect(res).to.have.property('cve_year').and.to.be.a('string')
    return res // return non-null objects
  }
}

/* -------- User Repositories -------- */
class NullUserRepo {
  async getUserUUID () {
    return null
  }
}

class UserNotCreatedAlreadyExists {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async findOneByUserNameAndOrgUUID (username, uuid) {
    expect(username).to.be.a('string').and.to.equal(existentUser.username)
    expect(uuid).to.be.a('string')
    const res = await this.userRepo.findOneByUserNameAndOrgUUID(username, uuid)
    expect(res).to.have.property('username').and.to.be.a('string')
    return res // return non-null objects
  }
}

// This test repo is also used for other tests that pass the same values
class UserCreatedOrgUndefined {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async findOneByUserNameAndOrgUUID (username, uuid) {
    return null
  }

  async updateByUserNameAndOrgUUID (username, uuid, user, options) {
    expect(options).to.have.property('upsert').and.to.equal(true)
    expect(username).to.equal(nonExistentUser.username)
    expect(uuid).to.equal(existentOrg.UUID)
    expect(user).to.be.an('object')
    await this.userRepo.updateByUserNameAndOrgUUID(username, uuid, user, options)
    return null
  }
}

class UserNotUpdatedUserDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async findOneByUserNameAndOrgUUID (username, uuid) {
    return null
  }
}

class UserNotUpdatedOrgQueryDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async findOneByUserNameAndOrgUUID (username, uuid) {
    expect(username).to.be.a('string').and.to.equal(existentUser.username)
    expect(uuid).to.be.a('string')
    const res = await this.userRepo.findOneByUserNameAndOrgUUID(username, uuid)
    expect(res).to.have.property('username').and.to.be.a('string')
    return res // return non-null objects
  }
}

class UserNotUpdatedNoQuery {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async findOneByUserNameAndOrgUUID (username, uuid) {
    expect(username).to.be.a('string').and.to.equal(existentUser.username)
    expect(uuid).to.be.a('string')
    const res = await this.userRepo.findOneByUserNameAndOrgUUID(username, uuid)
    expect(res).to.have.property('username').and.to.be.a('string')
    return res // return non-null objects
  }

  async updateByUserNameAndOrgUUID (username, uuid, user, options) {
    expect(options).to.be.an('undefined')
    expect(username).to.equal(existentUser.username)
    expect(uuid).to.equal(existentOrg.UUID)
    expect(user).to.be.an('object')
    const res = await this.userRepo.updateByUserNameAndOrgUUID(username, uuid, user, options)
    return res // return non-null objects
  }

  async getUserUUID (user, uuid) {
    expect(uuid).to.be.a('string')
    expect(user).to.be.a('string')
    const res = await this.userRepo.getUserUUID(user, uuid)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

class UserSecretNotResetUserDoesntExist {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async updateByUserNameAndOrgUUID (username, uuid, user, options) {
    expect(options).to.be.an('undefined')
    expect(username).to.equal(nonExistentUser.username)
    expect(uuid).to.equal(existentOrg.UUID)
    expect(user).to.be.an('object')
    const res = await this.userRepo.updateByUserNameAndOrgUUID(username, uuid, user, options)
    return res // return non-null objects
  }
}

class UserSecretReset {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async updateByUserNameAndOrgUUID (username, uuid, user, options) {
    expect(options).to.be.an('undefined')
    expect(username).to.equal(existentUser.username)
    expect(uuid).to.equal(existentOrg.UUID)
    expect(user).to.be.an('object')
    const res = await this.userRepo.updateByUserNameAndOrgUUID(username, uuid, user, options)
    return res // return non-null objects
  }

  async getUserUUID (user, uuid) {
    expect(uuid).to.be.a('string')
    expect(user).to.be.a('string')
    const res = await this.userRepo.getUserUUID(user, uuid)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

class UserGetUser {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async aggregate (aggregation) {
    expect(aggregation[0]).to.have.property('$match')
    const res = await this.userRepo.aggregate(aggregation)
    return res // return non-null objects
  }
}

class UserGetCveIdOwningOrg {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string').and.to.equal(owningOrgUser.UUID)
    const res = await this.userRepo.findOneByUUID(uuid)
    expect(res).to.have.property('username').and.to.be.a('string')
    return res // return non-null objects
  }
}

class UserModifyCveIdCnaAndStateModified {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async findOneByUUID (uuid) {
    expect(uuid).to.be.a('string')
    const res = await this.userRepo.findOneByUUID(uuid)
    expect(res).to.have.property('username').and.to.be.a('string')
    return res // return non-null objects
  }

  async getUserUUID (user, orgUUID) {
    expect(user).to.be.a('string').and.to.equal(secretariatHeader['CVE-API-USER'])
    expect(orgUUID).to.be.a('string')
    const res = await this.userRepo.getUserUUID(user, orgUUID)
    expect(res).to.be.a('string')
    return res // return non-null objects
  }
}

class UserReserveSequentialPriorityIsFull {
  constructor () {
    this.repos = new RepositoryFactory()
    this.userRepo = this.repos.getUserRepository()
  }

  async findOneByUserNameAndOrgUUID (username, orgUUID) {
    expect(username).to.be.a('string')
    expect(orgUUID).to.be.a('string')
    const res = await this.userRepo.findOneByUserNameAndOrgUUID(username, orgUUID)
    expect(res).to.have.property('username').and.to.be.a('string')
    return res // return non-null objects
  }
}

module.exports = {
  NullOrgRepo,
  OrgCreated,
  OrgCreatedWhenRolesDefined,
  OrgNotCreatedAlreadyExists,
  OrgNotUpdatedDoesNotExist,
  OrgNotUpdatedShortNameExists,
  OrgNotUpdatedIdQuotaUndefined,
  OrgNotUpdatedNoQueryParameters,
  OrgGet,
  OrgSecretariatIdQuota,
  OrgOwnerIdQuota,
  OrgNotOwnerOrSecretariatIdQuota,
  OrgDoesNotExistIdQuota,
  OrgExceedsMinIdQuota,
  OrgExceedsMaxIdQuota,
  OrgsGet,
  OrgCantCreateUserCnaDoesNotExist,
  OrgCantCreateUserCnaDoesNotMatch,
  OrgCreatedUserOrgUndefined,
  OrgUserNotUpdatedOrgDoesntExist,
  OrgUserNotUpdatedUserDoesntExist,
  OrgUserNotUpdatedOrgQueryDoesntExist,
  OrgUserSecretNotResetOrgDoesntExist,
  OrgUserSecretNotResetUserDoesntExist,
  OrgUserSecretReset,
  OrgGetUserOrgDoesntExist,
  OrgGetUser,
  OrgGetCveIdNotOwnerOrgNotReserved,
  OrgGetCveIdNotOwnerOrgReserved,
  OrgGetCveIdOwningOrg,
  OrgGetCveIdRequestorSecretariat,
  OrgGetCveIdNoCveIdsWithParams,
  OrgGetCveIdRequestorSecretariatNoQuery,
  OrgModifyCveIdDoesntExist,
  OrgModifyCveIdCnaDoesntExist,
  OrgModifyCveIdCnaAndStateModified,
  OrgReserveNotOwningOrg,
  OrgReserveShortNameUndefined,
  OrgReserveOrgDoesntExist,
  OrgReserveAmountLargerThanNonSequential,
  OrgReserveAmountGreaterIdQuota,
  OrgReserveYear2025RangeDoesntExist,
  OrgReserveSequentialPriorityIsFull,
  OrgReserveSequentialIsFull,
  OrgReserveYear2025RangeDoesntExistSequential,
  OrgReserveBase,
  OrgReserveUserB10Ids,
  NullCveIdRepo,
  CveIdGetCveIdDoesntExist,
  CveIdGetCveIdAvailable,
  CveIdGetCveIdNotOwningOrg,
  CveIdSecretariatIdQuota,
  CveIdOwnerIdQuota,
  CveIdExceedsMinQuota,
  CveIdExceedsMaxQuota,
  CveIdGetCveIdNoResultsWithParams,
  CveIdGetCveIdStateProvided,
  CveIdGetCveIdNoAvailableCves,
  CveIdGetCveIdYearProvided,
  CveIdGetCveIdNotSecretariatNoQuery,
  CveIdModifyCveIdDoesntExist,
  CveIdModifyCveIdCnaAndStateModified,
  CveIdRangeReserveYearDoesntExist,
  CveIdReserveSequentialPriorityIsFull,
  CveIdRangeReserveSequentialIsFull,
  CveIdRangeReserveNonSequentialIsFull,
  CveIdReservePoolIncremented10Ids,
  CveIdRangeReserveSequentialPriorityIsFull,
  CveIdRange2022NotExists,
  CveIdRange2022Exists,
  NullUserRepo,
  UserCreatedOrgUndefined,
  UserNotCreatedAlreadyExists,
  UserNotUpdatedUserDoesntExist,
  UserNotUpdatedOrgQueryDoesntExist,
  UserNotUpdatedNoQuery,
  UserSecretNotResetUserDoesntExist,
  UserSecretReset,
  UserGetUser,
  UserGetCveIdOwningOrg,
  UserModifyCveIdCnaAndStateModified,
  UserReserveSequentialPriorityIsFull
}
