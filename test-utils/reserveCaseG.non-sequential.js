
require('dotenv').config()
const CveId = require('../src/model/cve-id')
const CveIdRange = require('../src/model/cve-id-range')
const Org = require('../src/model/org')
const logger = require('../src/middleware/logger')
const CONSTANTS = require('../src/constants')
const util = require('../src/utils/utils')
const reservedByOther = []
const CONSOLE_OUTPUT = false

async function reserveCveId (req, res) {
  const requester = req.header(CONSTANTS.AUTH_HEADERS.USER)
  const cnaShortName = req.header(CONSTANTS.AUTH_HEADERS.ORG)
  let returned = false
  let batchType
  let amount
  let shortName
  let year
  let cveId

  Object.keys(req.query).forEach(k => {
    const key = k.toLowerCase()

    if (key === 'amount') {
      amount = req.query.amount.replace(/["']/g, '')
    } else if (key === 'batch_type') {
      batchType = req.query.batch_type.replace(/["']/g, '').toLowerCase()
    } else if (key === 'short_name') {
      shortName = req.query.short_name.replace(/["']/g, '').toLowerCase()
    } else if (key === 'cve_year') {
      year = req.query.cve_year.replace(/["']/g, '')
    } else {
      if (!returned) {
        returned = true
        return res.status(400).json({ message: 'Invalid query parameter \'' + key + '\'' })
      }
    }
  })

  const isSecretariat = await util.isSecretariat(cnaShortName)
  if (cnaShortName !== shortName && !isSecretariat && !returned) {
    returned = true
    return res.status(403).json(CONSTANTS.CNA_CANNOT_RESERVE_FOR_OTHER)
  }

  if (shortName === undefined && !returned) {
    returned = true
    return res.status(400).json(CONSTANTS.NO_CNA_SHORTNAME)
  }

  if (year === undefined && !returned) {
    returned = true
    return res.status(400).json(CONSTANTS.NO_YEAR)
  }

  if (amount === undefined && !returned) {
    returned = true
    return res.status(400).json(CONSTANTS.NO_AMOUNT)
  }

  if (amount <= 0 && !returned) {
    returned = true
    return res.status(400).json(CONSTANTS.INVALID_AMOUNT)
  }

  if (amount > 1 && batchType === undefined && !returned) {
    returned = true
    return res.status(400).json(CONSTANTS.NO_BATCH_TYPE)
  }

  let result = await Org.findOne().byShortName(shortName)
  if (!result && !returned) {
    returned = true
    logger.info(shortName + ' CNA does not exist.')
    return res.status(403).json(CONSTANTS.CNA_DNE)
  }

  let payload

  if (!returned) {
    payload = {
      id_quota: result.policies.id_quota
    }

    result = await CveId.countDocuments({ owning_cna: shortName, state: 'RESERVED' })
    payload.total_reserved = result
    payload.available = (payload.id_quota - payload.total_reserved)
  }

  if (!returned && amount > payload.available) {
    returned = true
    CONSTANTS.OVER_ID_QUOTA.details = payload
    return res.status(403).json(CONSTANTS.OVER_ID_QUOTA)
  }

  if (!returned) {
    if (batchType === 'non-sequential' || batchType === 'nonsequential') {
      await nonSequentialReservation(year, amount, cveId, shortName, cnaShortName, requester, payload.available, res)
    } else {
      return res.status(400).json(CONSTANTS.INVALID_BATCH_TYPE)
    }
  }
}

async function nonSequentialReservation (year, amount, cveId, shortName, cnaShortName, requester, availableIds, res) {
  let isFull = false
  let returned = false
  let available
  amount = parseInt(amount)
  let availableLimit = Math.max(3 * amount, CONSTANTS.DEFAULT_AVAILABLE_POOL)
  let result = await CveIdRange.findOne({ cve_year: year })

  if (CONSOLE_OUTPUT) {
    console.log('amount = ' + amount)
    console.log('availableLimit = ' + availableLimit)
  }

  // Cve Id Range for 'year' does not exists
  if (!result) {
    returned = true
    logger.info('CVE IDs for year ' + year + ' cannot be reserved at this time.')
    res.header(CONSTANTS.QUOTA_HEADER, availableIds)
    return res.status(403).json(CONSTANTS.CANNOT_RESERVE_FOR_YEAR)
  }

  if (!returned) {
    if (CONSOLE_OUTPUT) {
      console.log('available count (uncapped) = ' + (await CveId.find({ cve_year: year, state: 'AVAILABLE' })).length) // get available ids
    }

    available = await CveId.find({ cve_year: year, state: 'AVAILABLE' }).limit(availableLimit) // get available ids

    if (CONSOLE_OUTPUT) {
      console.log('available count (capped) = ' + available.length) // get available ids
    }

    // Case 1: Not enough IDs in the 'AVAILABLE' pool
    if (available.length < availableLimit) {
      result = await incrementNonSequentialPool(availableLimit, result.ranges.general.end, result.ranges.general.top_id, amount, available.length, year)
      isFull = result.isFull
      returned = result.returned

      if (isFull || returned) {
        logger.error('The cve id non-sequential block is full for year ' + year + '. No more sequential ids can be reserved at this time.')
        res.header(CONSTANTS.QUOTA_HEADER, availableIds)
        return res.status(403).json(CONSTANTS.YEAR_RANGE_FULL)
      }

      await allocateAvailableCveIds(result.ids, cveId, year) // Pool was incremented. Create 'AVAILABLE' cve ids.

      if (CONSOLE_OUTPUT) {
        console.log('available count (uncapped) = ' + (await CveId.find({ cve_year: year, state: 'AVAILABLE' })).length) // get available ids
      }

      available = await CveId.find({ cve_year: year, state: 'AVAILABLE' }).limit(availableLimit) // get available ids

      if (CONSOLE_OUTPUT) {
        console.log('available count (capped) = ' + available.length) // get available ids
      }
    }
  }

  // Case 2: Enough IDs in the 'AVAILABLE' pool
  let index
  let counter = 0
  const cveIdDocuments = []

  if (CONSOLE_OUTPUT) {
    console.log('counter = ' + counter)
  }

  while ((counter < amount) && (!isFull && !returned)) {
    index = getRandomInt(0, available.length) // get random index in the available array
    result = await reserveNonSequentialCveId(index, available, cveId, year, shortName, cnaShortName, requester)

    if (CONSOLE_OUTPUT && !result.isReserved) {
      console.log('isReserved: ' + result.isReserved)
    }

    if (result.isReserved) {
      cveIdDocuments.push(result.cveId) // add reserved cve id to the array of reserved cve ids
      available.splice(index, 1) // remove reserved cve id from the 'AVAILABLE' pool
      counter++

      if (CONSOLE_OUTPUT) {
        console.log('cveIdDocuments: ' + cveIdDocuments.length + ', available: ' + available.length + ', counter = ' + counter)
      }
    } else {
      if (CONSOLE_OUTPUT) {
        console.log('available = ' + available.length)
        console.log('available count (uncapped) = ' + (await CveId.find({ cve_year: year, state: 'AVAILABLE' })).length) // get available ids
      }

      available = await CveId.find({ cve_year: year, state: 'AVAILABLE' }).limit(availableLimit) // get available ids

      if (CONSOLE_OUTPUT) {
        console.log('available count (capped) = ' + available.length) // get available ids
      }

      availableLimit = Math.max(3 * (amount - counter), CONSTANTS.DEFAULT_AVAILABLE_POOL) // recalculate the available limit since some ids might have been reserved

      if (CONSOLE_OUTPUT) {
        console.log('availableLimit = ' + availableLimit)
      }

      // Case 1: Not enough IDs in the 'AVAILABLE' pool
      if (available.length < availableLimit) {
        result = await CveIdRange.findOne({ cve_year: year })
        result = await incrementNonSequentialPool(availableLimit, result.ranges.general.end, result.ranges.general.top_id, amount - counter, available.length, year)
        isFull = result.isFull
        returned = result.returned

        if (isFull || returned) {
          logger.info({ message: 'Only ' + counter + ' cve ids were reserved because there are not enough ids in the CVE ID non-sequential block.' })
          const partialError = CONSTANTS.RESERVED_PARTIAL_AMOUNT
          partialError.details = { amount_reserved: counter }
          partialError.cve_ids = cveIdDocuments
          res.header(CONSTANTS.QUOTA_HEADER, availableIds - counter)
          return res.status(206).json(partialError)
        }

        await allocateAvailableCveIds(result.ids, cveId, year) // Pool was incremented. Create 'AVAILABLE' cve ids.

        if (CONSOLE_OUTPUT) {
          console.log('available count (uncapped) = ' + (await CveId.find({ cve_year: year, state: 'AVAILABLE' })).length) // get available ids
        }

        available = await CveId.find({ cve_year: year, state: 'AVAILABLE' }).limit(availableLimit) // get available ids

        if (CONSOLE_OUTPUT) {
          console.log('available count (capped) = ' + available.length) // get available ids
        }
      }
    }
  }

  if (!isFull && !returned) {
    logger.info({ message: 'Non-sequential CVE IDs were reserved for \'' + shortName + '\' org on behalf of \'' + cnaShortName + '\' org.', cve_ids: cveIdDocuments })
    res.header(CONSTANTS.QUOTA_HEADER, availableIds - amount)
    return res.status(200).json({ cve_ids: cveIdDocuments })
  }
}

async function incrementNonSequentialPool (availableLimit, end, top, amount, available, year) {
  let increment = availableLimit - available + amount // the amount is the increment amount
  const endRange = parseInt(end)
  const topId = parseInt(top)

  if (CONSOLE_OUTPUT) {
    console.log('increment = ' + increment)
    console.log('endRange = ' + endRange)
    console.log('topId = ' + topId)
  }

  // Cap increment to end of general CVE ID block
  if (endRange < (topId + increment)) {
    increment = endRange - topId
  }

  if (CONSOLE_OUTPUT) {
    console.log('increment = ' + increment)
  }

  const result = {
    isFull: false,
    returned: false,
    ids: null
  }

  // ---- Reserve 10 cve ids ----
  let cveId
  let temp = await CveIdRange.findOneAndUpdate({ $and: [{ cve_year: year }, { 'ranges.general.end': { $gte: increment } }] }, { $inc: { 'ranges.general.top_id': increment } }, { new: true })

  if (CONSOLE_OUTPUT) {
    console.log('top_id = ' + temp.ranges.general.top_id)
  }

  temp = generateSequentialIds(year, temp.ranges.general.top_id, increment)
  await allocateAvailableCveIds(temp, cveId, year) // Pool was incremented. Create 'AVAILABLE' cve ids.

  if (CONSOLE_OUTPUT) {
    console.log('available count (uncapped) = ' + (await CveId.find({ cve_year: year, state: 'AVAILABLE' })).length) // get available ids
  }

  available = await CveId.find({ cve_year: year, state: 'AVAILABLE' }).limit(availableLimit) // get available ids

  if (CONSOLE_OUTPUT) {
    console.log('available count (capped) = ' + available.length) // get available ids
  }

  for (let i = 0; i < 10; i++) {
    const r = getRandomInt(0, available.length)
    temp = await reserveNonSequentialCveId(r, available, cveId, year, 'mitre', 'mitre', 'cpadro')
    available.splice(r, 1) // remove reserved cve id from the 'AVAILABLE' pool
    reservedByOther.push(temp.cveId.cve_id)

    if (CONSOLE_OUTPUT) {
      console.log('* available = ' + available.length)
      console.log('* available count (uncapped) = ' + (await CveId.find({ cve_year: year, state: 'AVAILABLE' })).length) // get available ids
      console.log('* available count (capped) = ' + (await CveId.find({ cve_year: year, state: 'AVAILABLE' }).limit(availableLimit)).length) // get available ids
    }
  }
  // ----------------------------

  if (increment > 0) {
    let r = await CveIdRange.findOneAndUpdate({ $and: [{ cve_year: year }, { 'ranges.general.end': { $gt: increment } }] }, { $inc: { 'ranges.general.top_id': increment } }, { new: true })

    if (CONSOLE_OUTPUT) {
      console.log('top_id = ' + r.ranges.general.top_id)
    }

    // Cap increment because it went over end of general block
    //  -------------------- F - G ----------------------
    if (r.ranges.general.top_id > endRange) {
      if (CONSOLE_OUTPUT) {
        console.log('increment = ' + increment)
      }

      increment = increment - (r.ranges.general.top_id - endRange) // adjusting real increment
      r = await CveIdRange.findOneAndUpdate({ cve_year: year }, { $set: { 'ranges.general.top_id': endRange } }, { new: true }) // Cap top_id to end of the block

      if (CONSOLE_OUTPUT) {
        console.log('top_id = ' + r.ranges.general.top_id)
      }
    }
    //  -----------------------------------------------

    if (CONSOLE_OUTPUT) {
      console.log('increment = ' + increment)
    }

    if (increment > 0) {
      result.ids = generateSequentialIds(year, r.ranges.general.top_id, increment)
    } else if (available < amount) { // You hit the end of the boundary
      //  ------------------- F -------------------------
      result.isFull = true
      result.returned = true
      //  -----------------------------------------------
    }
  } else if (available < amount) { // You hit the end of the boundary
    result.isFull = true
    result.returned = true
  }

  return result
}

async function allocateAvailableCveIds (ids, cveId, year) {
  if (ids) {
    const cveIdDocuments = []

    ids.forEach(id => {
      cveId = new CveId()
      cveId.cve_id = id
      cveId.cve_year = year
      cveId.state = 'AVAILABLE'
      cveId.owning_cna = 'N/A' // the org who gets assigned the reserved CVE IDs
      cveId.reserved = Date.now()
      cveId.requested_by = {
        cna: 'N/A', // the org who requested the CVE IDs
        user: 'N/A'
      }

      cveIdDocuments.push(cveId)
    })

    if (CONSOLE_OUTPUT) {
      console.log('Allocated ids: [' + cveIdDocuments[0].cve_id + ', ... , ' + cveIdDocuments[cveIdDocuments.length - 1].cve_id + ']')
      console.log('Allocated count = ' + cveIdDocuments.length)
    }

    await CveId.insertMany(cveIdDocuments) // Save the 'AVAILABLE' cve ids
  }
}

async function reserveNonSequentialCveId (index, available, cveId, year, shortName, cnaShortName, requester) {
  // Update available Cve Id
  cveId = new CveId()
  cveId.cve_id = available[index].cve_id
  cveId.cve_year = year
  cveId.state = 'RESERVED'
  cveId.owning_cna = shortName // the org who gets assigned the reserved CVE IDs
  cveId.reserved = Date.now()
  cveId.requested_by = {
    cna: cnaShortName, // the org who requested the CVE IDs
    user: requester
  }

  const result = {
    cveId: cveId,
    isReserved: await CveId.findOneAndUpdate({ cve_id: cveId.cve_id, state: 'AVAILABLE' }, cveId, { new: true })
  }

  return result
}

function generateSequentialIds (year, topId, increment) {
  const start = topId - increment + 1 // before the pool 'AVAILABLE' pool increment
  const end = topId // after the 'AVAILABLE' pool increment
  const ids = []

  if (CONSOLE_OUTPUT) {
    console.log('start = ' + start)
    console.log('end = ' + end)
  }

  for (let i = start; i < end + 1; i++) {
    ids.push('CVE-' + year + '-' + String(i).padStart(4, '0'))
  }

  if (CONSOLE_OUTPUT) {
    console.log('Generated ids: [' + ids[0] + ', ... , ' + ids[ids.length - 1] + ']')
  }

  return ids
}

function getRandomInt (min, max) {
  min = Math.ceil(min)
  max = Math.floor(max)

  return Math.floor(Math.random() * (max - min) + min) // The maximum is exclusive and the minimum is inclusive
}

module.exports = {
  CVEID_RESERVE: reserveCveId,
  reservedByOther: reservedByOther
}
