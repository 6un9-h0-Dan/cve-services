const server = require('../../../test-utils/index')
const chai = require('chai')
const expect = chai.expect
chai.use(require('chai-http'))

const orgFixtures = require('./mockObjects.org')
const orgController = require('../../../src/controller/org.controller/org.controller')
const orgParams = require('../../../src/controller/org.controller/org.middleware')

const errors = require('../../../src/controller/org.controller/error')
const error = new errors.OrgControllerError()

describe('Testing the /org/:shortname/users endpoint in Org Controller', () => {
    before(async () => {

    })

    context('Negative Tests', () => {
        it('should return 404 becuase org does not exist', (done) => {
            class NoOrg {
                async getOrgUUID () {
                    return null
                }
            }
        
            class Blank {
                async aggregate () {
                    return []
                }
            }
        
            server.route('/org-does-not-exist/:shortname/users')
              .get((req, res, next) => {
                const factory = {
                  getOrgRepository: () => { return new NoOrg() },
                  getUserRepository: () => { return new Blank() }
                }
                req.ctx.repositories = factory
                next()
              }, orgParams.parseGetParams, orgController.USER_ALL)

            // perform the request to the api
            chai.request(server)
                .get(`/org-does-not-exist/${orgFixtures.nonExistentOrg.short_name}/users`)
                .set(orgFixtures.owningOrgHeader)
                .end((err, res) => {
                if (err) {
                    done(err)
                }
        
                // assert expected response
                expect(res).to.have.status(404)
                expect(res).to.have.property('body').and.to.be.a('object')
                const errObj = error.orgDneParam(orgFixtures.nonExistentOrg.short_name)
                expect(res.body.error).to.equal(errObj.error)
                expect(res.body.message).to.equal(errObj.message)
                done()
                })
        })
    
        it('should return 403 because requester does not belong to the same org', (done) => {
            class NotSameOrg {
                async getOrgUUID () {
                  return "not-an-org"
                }
            }
        
            class Blank {
                async aggregate () {
                    return []
                }
            }
        
            server.route('/requester-does-not-belong/:shortname/users')
            .get((req, res, next) => {
            const factory = {
                getOrgRepository: () => { return new NotSameOrg() },
                getUserRepository: () => { return new Blank() }
            }
            req.ctx.repositories = factory
            next()
            }, orgParams.parseGetParams, orgController.USER_ALL)

            // perform the request to the api
            chai.request(server)
                .get(`/requester-does-not-belong/${orgFixtures.owningOrg.short_name}/users`)
                .set(orgFixtures.orgHeader)
                .end((err, res) => {
                if (err) {
                    done(err)
                }
        
                // assert expected response
                expect(res).to.have.status(403)
                expect(res).to.have.property('body').and.to.be.a('object')
                expect(res.body.error).to.equal('NOT_OWNER')
                expect(res.body.message).to.equal('This information can only be viewed by the owning CNA.')
                done()
                })
        })
    })


    context('Positive Tests', () => {
        it('should list the users for cisco org', (done) => {
            //setup
        
            class GetOrgUUID {
                async getOrgUUID () {
                return orgFixtures.owningOrg.UUID
                }
            }
        
            class GetAllOrgUsers {
                async aggregate () {
                return [orgFixtures.existentUserDummy]
                }
            }
        
            server.route('/user-list-returned/:shortname/users')
            .get((req, res, next) => {
                const factory = {
                getOrgRepository: () => { return new GetOrgUUID() },
                getUserRepository: () => { return new GetAllOrgUsers() }
                }
                req.ctx.repositories = factory
                next()
            }, orgParams.parseGetParams, orgController.USER_ALL)
        
            //execution
            chai.request(server)
                .get(`/user-list-returned/${orgFixtures.owningOrg.short_name}/users`)
                .set(orgFixtures.owningOrgHeader)
                .end((err, res) => {
                if (err) {
                    done(err)
                }
        
                // assertion
                expect(res).to.have.status(200)
                expect(res).to.have.property('body').and.to.be.a('array').and.to.have.lengthOf(1)
                expect(res.body[0]).to.have.property('org_UUID').and.to.equal(orgFixtures.owningOrg.UUID)
                done()
                })
        })
    })


    after(async () => {
    
    })
  })
