const server = require('../../../test-utils/index')
const chai = require('chai')
const expect = chai.expect
chai.use(require('chai-http'))
const mongoose = require('mongoose')
const secretariatHeader = require('./mockObjects.org').secretariatHeader
const existentUser = require('./mockObjects.org').existentUser
const nonExistentUser = require('./mockObjects.org').nonExistentUser
const existentOrg = require('./mockObjects.org').existentOrg
const owningOrg = require('./mockObjects.org').owningOrg
const existentUserDummy = require('./mockObjects.org').existentUserDummy
const existentOrgDummy2 = require('./mockObjects.org').existentOrgDummy2
const nonExistentOrg = require('./mockObjects.org').nonExistentOrg
const User = require('../../../src/model/user')
const Org = require('../../../src/model/org')
const errors = require('../../../src/controller/org.controller/error')
const error = new errors.OrgControllerError()

const repos = require('../../../test-utils/repositories')
const orgController = require('../../../src/controller/org.controller/org.controller')

describe('Test user functions in Org Controller', () => {
  before(async () => {
    await User.findOneAndUpdate()
      .byUUID(existentUser.UUID)
      .updateOne(existentUser)
      .setOptions({ upsert: true })

    await User.findOneAndUpdate()
      .byUUID(existentUserDummy.UUID)
      .updateOne(existentUserDummy)
      .setOptions({ upsert: true })

    await Org.findOneAndUpdate()
      .byUUID(existentOrg.UUID)
      .updateOne(existentOrg)
      .setOptions({ upsert: true })

    await Org.findOneAndUpdate()
      .byUUID(existentOrgDummy2.UUID)
      .updateOne(existentOrgDummy2)
      .setOptions({ upsert: true })

    await Org.findOneAndUpdate()
      .byUUID(owningOrg.UUID)
      .updateOne(owningOrg)
      .setOptions({ upsert: true })
  })

  context('Creating a user', () => {
    it('User is not created because org does not exist', (done) => {
      // perform the request to the api
      const factory = {}
      factory.getOrgRepository = () => {
        return new repos.OrgCantCreateUserCnaDoesNotExist()
      }
      factory.getUserRepository = () => {
        return new repos.NullUserRepo()
      }
      server.route('/user-not-created-org-does-not-exist')
        .post((req, res, next) => {
          req.ctx.repositories = factory
          req.ctx.body = nonExistentUser
          req.ctx.params = {}
          req.ctx.params.shortname = nonExistentOrg.short_name
          next()
        }, orgController.USER_CREATE_SINGLE)
      chai.request(server)
        .post('/user-not-created-org-does-not-exist')
        .set(secretariatHeader)
        .send(nonExistentUser)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          // assert expected response
          expect(res).to.have.status(404)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.cnaDneParam(nonExistentOrg.short_name)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('Param org\'s UUID does not match the provided org\'s UUID', (done) => {
      const testUser = Object.assign({}, existentUser)
      testUser.org_UUID = owningOrg.UUID
      const factory = {}
      factory.getOrgRepository = () => {
        return new repos.OrgCantCreateUserCnaDoesNotMatch()
      }
      factory.getUserRepository = () => {
        return new repos.NullUserRepo()
      }
      server.route('/user-not-created-org-does-not-match')
        .post((req, res, next) => {
          req.ctx.repositories = factory
          req.ctx.body = testUser
          req.ctx.params = {}
          req.ctx.params.shortname = existentOrg.short_name
          next()
        }, orgController.USER_CREATE_SINGLE)

      // perform the request to the api
      chai.request(server)
        .post('/user-not-created-org-does-not-match')
        .set(secretariatHeader)
        .send(testUser)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          // assert expected response
          expect(res).to.have.status(400)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.shortnameMismatch(existentOrg.short_name, owningOrg.short_name)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('User is created when org UUID is undefined', (done) => {
      const testUser = Object.assign({}, nonExistentUser)
      delete testUser.org_UUID
      const factory = {}
      factory.getOrgRepository = () => {
        return new repos.OrgCreatedUserOrgUndefined()
      }
      factory.getUserRepository = () => {
        return new repos.UserCreatedOrgUndefined()
      }
      server.route('/user-created-org-undefined')
        .post((req, res, next) => {
          req.ctx.repositories = factory
          req.ctx.body = testUser
          req.ctx.params = {}
          req.ctx.params.shortname = existentOrg.short_name
          next()
        }, orgController.USER_CREATE_SINGLE)
      // perform the request to the api
      chai.request(server)
        .post('/user-created-org-undefined')
        .set(secretariatHeader)
        .send(testUser)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          // assert expected response
          expect(res).to.have.status(200)
          expect(res).to.have.property('body').and.to.be.a('object')
          expect(res.body).to.have.property('message').and.to.be.a('string')
          expect(res.body.message).to.equal(testUser.username + ' was successfully created.')
          expect(res.body).to.have.property('created').and.to.be.a('object')
          expect(res.body.created).to.have.property('org_UUID').and.to.equal(existentOrg.UUID)
          expect(res.body.created).to.have.property('username').and.to.equal(testUser.username)
          done()
        })
    })

    it('User is created when org UUID is null', (done) => {
      User.findOneAndRemove()
        .byUUID(nonExistentUser.UUID)
        .exec((err) => {
          if (err) {
            done(err)
          }

          const testUser = Object.assign({}, nonExistentUser)
          testUser.org_UUID = null
          const factory = {}
          factory.getOrgRepository = () => {
            return new repos.OrgCreatedUserOrgUndefined()
          }
          factory.getUserRepository = () => {
            return new repos.UserCreatedOrgUndefined()
          }
          server.route('/user-created-org-null')
            .post((req, res, next) => {
              req.ctx.repositories = factory
              req.ctx.body = testUser
              req.ctx.params = {}
              req.ctx.params.shortname = existentOrg.short_name
              next()
            }, orgController.USER_CREATE_SINGLE)
          // perform the request to the api
          chai.request(server)
            .post('/user-created-org-null')
            .set(secretariatHeader)
            .send(testUser)
            .end((err, res) => {
              if (err) {
                done(err)
              }

              // assert expected response
              expect(res).to.have.status(200)
              expect(res).to.have.property('body').and.to.be.a('object')
              expect(res.body).to.have.property('message').and.to.be.a('string')
              expect(res.body.message).to.equal(testUser.username + ' was successfully created.')
              expect(res.body).to.have.property('created').and.to.be.a('object')
              expect(res.body.created).to.have.property('org_UUID').and.to.equal(existentOrg.UUID)
              expect(res.body.created).to.have.property('username').and.to.equal(testUser.username)
              done()
            })
        })
    })

    it('User is created when user UUID is undefined', (done) => {
      User.findOneAndRemove()
        .byUUID(nonExistentUser.UUID)
        .exec((err) => {
          if (err) {
            done(err)
          }

          const testUser = Object.assign({}, nonExistentUser)
          delete testUser.UUID
          const factory = {}
          factory.getOrgRepository = () => {
            return new repos.OrgCreatedUserOrgUndefined()
          }
          factory.getUserRepository = () => {
            return new repos.UserCreatedOrgUndefined()
          }
          server.route('/user-created-uuid-undefined')
            .post((req, res, next) => {
              req.ctx.repositories = factory
              req.ctx.body = testUser
              req.ctx.params = {}
              req.ctx.params.shortname = existentOrg.short_name
              next()
            }, orgController.USER_CREATE_SINGLE)
          // perform the request to the api
          chai.request(server)
            .post('/user-created-uuid-undefined')
            .set(secretariatHeader)
            .send(testUser)
            .end((err, res) => {
              if (err) {
                done(err)
              }

              // assert expected response
              expect(res).to.have.status(200)
              expect(res).to.have.property('body').and.to.be.a('object')
              expect(res.body).to.have.property('message').and.to.be.a('string')
              expect(res.body.message).to.equal(testUser.username + ' was successfully created.')
              expect(res.body).to.have.property('created').and.to.be.a('object')
              expect(res.body.created).to.have.property('org_UUID').and.to.equal(testUser.org_UUID)
              expect(res.body.created).to.have.property('username').and.to.equal(testUser.username)
              expect(res.body.created).to.have.property('UUID').and.to.be.a('string')
              done()
            })
        })
    })

    it('User is created when UUID is null', (done) => {
      User.findOneAndRemove()
        .byUserNameAndOrgUUID(nonExistentUser.username, nonExistentUser.org_UUID)
        .exec((err) => {
          if (err) {
            done(err)
          }

          const testUser = Object.assign({}, nonExistentUser)
          testUser.UUID = null
          const factory = {}
          factory.getOrgRepository = () => {
            return new repos.OrgCreatedUserOrgUndefined()
          }
          factory.getUserRepository = () => {
            return new repos.UserCreatedOrgUndefined()
          }
          server.route('/user-created-uuid-null')
            .post((req, res, next) => {
              req.ctx.repositories = factory
              req.ctx.body = testUser
              req.ctx.params = {}
              req.ctx.params.shortname = existentOrg.short_name
              next()
            }, orgController.USER_CREATE_SINGLE)
          // perform the request to the api
          chai.request(server)
            .post('/user-created-uuid-null')
            .set(secretariatHeader)
            .send(testUser)
            .end((err, res) => {
              if (err) {
                done(err)
              }

              // assert expected response
              expect(res).to.have.status(200)
              expect(res).to.have.property('body').and.to.be.a('object')
              expect(res.body).to.have.property('message').and.to.be.a('string')
              expect(res.body.message).to.equal(testUser.username + ' was successfully created.')
              expect(res.body).to.have.property('created').and.to.be.a('object')
              expect(res.body.created).to.have.property('org_UUID').and.to.equal(testUser.org_UUID)
              expect(res.body.created).to.have.property('username').and.to.equal(testUser.username)
              expect(res.body.created).to.have.property('UUID').and.to.be.a('string')
              done()
            })
        })
    })

    it('User is created when UUID is defined', (done) => {
      User.findOneAndRemove()
        .byUserNameAndOrgUUID(nonExistentUser.username, nonExistentUser.org_UUID)
        .exec((err) => {
          if (err) {
            done(err)
          }
          const factory = {}
          factory.getOrgRepository = () => {
            return new repos.OrgCreatedUserOrgUndefined()
          }
          factory.getUserRepository = () => {
            return new repos.UserCreatedOrgUndefined()
          }
          server.route('/user-created-uuid-defined')
            .post((req, res, next) => {
              req.ctx.repositories = factory
              req.ctx.body = nonExistentUser
              req.ctx.params = {}
              req.ctx.params.shortname = existentOrg.short_name
              next()
            }, orgController.USER_CREATE_SINGLE)
          // perform the request to the api
          chai.request(server)
            .post('/user-created-uuid-defined')
            .set(secretariatHeader)
            .send(nonExistentUser)
            .end((err, res) => {
              if (err) {
                done(err)
              }

              // assert expected response
              expect(res).to.have.status(200)
              expect(res).to.have.property('body').and.to.be.a('object')
              expect(res.body).to.have.property('message').and.to.be.a('string')
              expect(res.body.message).to.equal(nonExistentUser.username + ' was successfully created.')
              expect(res.body).to.have.property('created').and.to.be.a('object')
              expect(res.body.created).to.have.property('org_UUID').and.to.equal(nonExistentUser.org_UUID)
              expect(res.body.created).to.have.property('username').and.to.equal(nonExistentUser.username)
              expect(res.body.created).to.have.property('UUID').and.to.equal(nonExistentUser.UUID)
              done()
            })
        })
    })

    it('User is not created because it already exists', (done) => {
      User.findOneAndRemove()
        .byUUID(nonExistentUser.UUID)
        .exec((err) => {
          if (err) {
            done(err)
          }
          const factory = {}
          factory.getOrgRepository = () => {
            return new repos.OrgCreatedUserOrgUndefined()
          }
          factory.getUserRepository = () => {
            return new repos.UserNotCreatedAlreadyExists()
          }
          server.route('/user-not-created-already-exists')
            .post((req, res, next) => {
              req.ctx.repositories = factory
              req.ctx.body = existentUser
              req.ctx.params = {}
              req.ctx.params.shortname = existentOrg.short_name
              next()
            }, orgController.USER_CREATE_SINGLE)
          // perform the request to the api
          chai.request(server)
            .post('/user-not-created-already-exists')
            .set(secretariatHeader)
            .send(existentUser)
            .end((err, res) => {
              if (err) {
                done(err)
              }

              // assert expected response
              expect(res).to.have.status(400)
              expect(res).to.have.property('body').and.to.be.a('object')
              const errObj = error.userExists(existentUser.username)
              expect(res.body.error).to.equal(errObj.error)
              expect(res.body.message).to.equal(errObj.message)
              done()
            })
        })
    })
  })

  context('Updating a user', () => {
    it('User is not updated because org does not exist', (done) => {
      // perform the request to the api
      const shortname = nonExistentOrg.short_name.replace(/\s/g, '')
      const username = existentUser.username.replace(/\s/g, '')
      const factory = {}
      factory.getOrgRepository = () => {
        return new repos.OrgUserNotUpdatedOrgDoesntExist()
      }
      factory.getUserRepository = () => {
        return new repos.NullUserRepo()
      }
      server.route('/user-not-updated-already-exists')
        .post((req, res, next) => {
          req.ctx.repositories = factory
          req.ctx.params = {}
          req.ctx.params.shortname = shortname
          req.ctx.params.username = username
          next()
        }, orgController.USER_UPDATE_SINGLE)
      chai.request(server)
        .post('/user-not-updated-already-exists')
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          // assert expected response
          expect(res).to.have.status(404)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.cnaDneParam(nonExistentOrg.short_name)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('User is not updated because user does not exist', (done) => {
      // perform the request to the api
      const shortname = existentOrg.short_name.replace(/\s/g, '')
      const username = nonExistentUser.username.replace(/\s/g, '')
      const factory = {}
      factory.getOrgRepository = () => {
        return new repos.OrgUserNotUpdatedUserDoesntExist()
      }
      factory.getUserRepository = () => {
        return new repos.UserNotUpdatedUserDoesntExist()
      }
      server.route('/user-not-updated-doesnt-exist')
        .post((req, res, next) => {
          req.ctx.repositories = factory
          req.ctx.params = {}
          req.ctx.params.shortname = shortname
          req.ctx.params.username = username
          next()
        }, orgController.USER_UPDATE_SINGLE)
      chai.request(server)
        .post('/user-not-updated-doesnt-exist')
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          // assert expected response
          expect(res).to.have.status(404)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.userDne(nonExistentUser.username)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('User is not updated because org query does not exist', (done) => {
      // perform the request to the api
      const factory = {}
      factory.getOrgRepository = () => {
        return new repos.OrgUserNotUpdatedOrgQueryDoesntExist()
      }
      factory.getUserRepository = () => {
        return new repos.UserNotUpdatedOrgQueryDoesntExist()
      }
      server.route('/user-not-updated-user-doesnt-exist')
        .post((req, res, next) => {
          req.ctx.repositories = factory
          req.ctx.params = {}
          req.ctx.query = {}
          req.ctx.params.shortname = existentOrg.short_name
          req.ctx.params.username = existentUser.username
          req.ctx.query.new_cna_shortname = nonExistentOrg.short_name
          next()
        }, orgController.USER_UPDATE_SINGLE)
      chai.request(server)
        .post('/user-not-updated-user-doesnt-exist')
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }
          // assert expected response
          expect(res).to.have.status(404)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.cnaDne(nonExistentOrg.short_name)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    // check that the user is unchanged
    it('No query parameters are provided', (done) => {
      User.findOne()
        .byUUID(existentUser.UUID)
        .exec((err, result) => {
          if (err) {
            done(err)
          }
          const factory = {}
          factory.getOrgRepository = () => {
            return new repos.OrgUserNotUpdatedOrgQueryDoesntExist()
          }
          factory.getUserRepository = () => {
            return new repos.UserNotUpdatedNoQuery()
          }
          server.route('/user-not-updated-no-parameters')
            .post((req, res, next) => {
              req.ctx.repositories = factory
              req.ctx.params = {}
              req.ctx.query = {}
              req.ctx.params.shortname = existentOrg.short_name
              req.ctx.params.username = existentUser.username
              next()
            }, orgController.USER_UPDATE_SINGLE)
          // perform the request to the api
          chai.request(server)
            .post('/user-not-updated-no-parameters')
            .set(secretariatHeader)
            .end((err, res) => {
              if (err) {
                done(err)
              }

              // assert expected response
              expect(res).to.have.status(200)
              expect(res).to.have.property('body').and.to.be.a('object')
              expect(res.body).to.have.property('updated').and.to.be.a('object')
              expect(JSON.stringify(res.body.updated)).to.equal('{}')
              expect(result.cna_short_name).to.equal(existentUser.cna_short_name)
              expect(result.username).to.equal(existentUser.username)
              expect(result.UUID).to.equal(existentUser.UUID)
              expect(result.secret).to.equal(existentUser.secret)
              expect(result.active).to.equal(existentUser.active)
              expect(result.name.first).to.equal(existentUser.name.first)
              expect(result.name.last).to.equal(existentUser.name.last)
              expect(result.name.middle).to.equal(existentUser.name.middle)
              expect(result.name.suffix).to.equal(existentUser.name.suffix)
              expect(result.name.surname).to.equal(existentUser.name.surname)
              done()
            })
        })
    })
  })

  context('Resetting a user\'s secret', () => {
    it('User secret is not reset because org does not exists', (done) => {
      const factory = {}
      factory.getOrgRepository = () => {
        return new repos.OrgUserSecretNotResetOrgDoesntExist()
      }
      factory.getUserRepository = () => {
        return new repos.NullUserRepo()
      }
      server.route('/user-secret-not-reset-org-doesnt-exist')
        .post((req, res, next) => {
          req.ctx.repositories = factory
          req.ctx.params = {}
          req.ctx.params.shortname = nonExistentOrg.short_name
          req.ctx.params.username = existentUser.username
          next()
        }, orgController.USER_RESET_SECRET)
      // perform the request to the api
      chai.request(server)
        .post('/user-secret-not-reset-org-doesnt-exist')
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          // assert expected response
          expect(res).to.have.status(404)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.cnaDneParam(nonExistentOrg.short_name)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('User secret is not reset because user does not exists', (done) => {
      const factory = {}
      factory.getOrgRepository = () => {
        return new repos.OrgUserSecretNotResetUserDoesntExist()
      }
      factory.getUserRepository = () => {
        return new repos.UserSecretNotResetUserDoesntExist()
      }
      server.route('/user-secret-not-reset-user-doesnt-exist')
        .post((req, res, next) => {
          req.ctx.repositories = factory
          req.ctx.params = {}
          req.ctx.params.shortname = existentOrg.short_name
          req.ctx.params.username = nonExistentUser.username
          next()
        }, orgController.USER_RESET_SECRET)
      // perform the request to the api
      chai.request(server)
        .post('/user-secret-not-reset-user-doesnt-exist')
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          // assert expected response
          expect(res).to.have.status(404)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.userDne(nonExistentUser.username)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('User secret is reset', (done) => {
      const factory = {}
      factory.getOrgRepository = () => {
        return new repos.OrgUserSecretReset()
      }
      factory.getUserRepository = () => {
        return new repos.UserSecretReset()
      }
      server.route('/user-secret-reset')
        .post((req, res, next) => {
          req.ctx.repositories = factory
          req.ctx.params = {}
          req.ctx.params.shortname = existentOrg.short_name
          req.ctx.params.username = existentUser.username
          next()
        }, orgController.USER_RESET_SECRET)
      chai.request(server)
        // perform the request to the api
        .post('/user-secret-reset')
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          // assert expected response
          expect(res).to.have.status(200)
          expect(res).to.have.property('body').and.to.be.a('object')
          expect(res.body).to.have.property('API-secret').and.to.be.a('string')
          done()
        })
    })
  })

  context('Getting a user', () => {
    it('Org does not exists', (done) => {
      const factory = {}
      factory.getOrgRepository = () => {
        return new repos.OrgGetUserOrgDoesntExist()
      }
      factory.getUserRepository = () => {
        return new repos.NullUserRepo()
      }
      server.route('/user-get-user-org-doesnt-exist')
        .get((req, res, next) => {
          req.ctx.repositories = factory
          req.ctx.params = {}
          req.ctx.params.shortname = nonExistentOrg.short_name
          req.ctx.params.username = existentUser.username
          next()
        }, orgController.USER_SINGLE)
      // perform the request to the api
      chai.request(server)
        .get('/user-get-user-org-doesnt-exist')
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          // assert expected response
          expect(res).to.have.status(404)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.cnaDneParam(nonExistentOrg.short_name)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('User does not exists', (done) => {
      const factory = {}
      factory.getOrgRepository = () => {
        return new repos.OrgGetUserUserDoesntExist()
      }
      factory.getUserRepository = () => {
        return new repos.UserGetUserDoesntExist()
      }
      server.route('/user-get-user-user-doesnt-exist')
        .get((req, res, next) => {
          req.ctx.repositories = factory
          req.ctx.params = {}
          req.ctx.params.shortname = existentOrg.short_name
          req.ctx.params.username = nonExistentUser.username
          next()
        }, orgController.USER_SINGLE)
      // perform the request to the api
      chai.request(server)
        .get('/user-get-user-user-doesnt-exist')
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          // assert expected response
          expect(res).to.have.status(404)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.userDne(nonExistentUser.username)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('User exists', (done) => {
      const factory = {}
      factory.getOrgRepository = () => {
        return new repos.OrgGetUser()
      }
      factory.getUserRepository = () => {
        return new repos.UserGetUser()
      }
      server.route('/user-get-user')
        .get((req, res, next) => {
          req.ctx.repositories = factory
          req.ctx.params = {}
          req.ctx.params.shortname = existentOrg.short_name
          req.ctx.params.username = existentUser.username
          next()
        }, orgController.USER_SINGLE)
      // perform the request to the api
      chai.request(server)
        .get('/user-get-user')
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          // assert expected response
          expect(res).to.have.status(200)
          expect(res).to.have.property('body').and.to.be.a('object')
          expect(res.body).to.have.property('username').and.to.equal(existentUser.username)
          expect(res.body).to.have.property('org_UUID').and.to.equal(existentUser.org_UUID)
          done()
        })
    })
  })

  after(async () => {
    await User.deleteMany({})
    await Org.deleteMany({})

    // The db connection must be closed after all tests are run. The userTest.js is the last test file to run because it is
    // the last file in the unit test folder (tests are run sequentially). Therefore, this test closes the db connection.
    mongoose.connection.close()
  })
})
