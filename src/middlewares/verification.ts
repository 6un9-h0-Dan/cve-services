import { dbOperations } from "../database/db-operations";
import * as NodeRSA from "node-rsa";

export const verifyRequester = async (req, res, next) => {
  const noAuth = /(^\/health-check|\/user-auth|\/sign|\/getAllCNA)/g; // Place route names here that dont need authentication
  const cnaAuth = /(^\/register-user)/g; // Place route names here that only CNA role can use.
  const { userUUID, payload } = req.body;
  var verify = false;
  try {
    if (!new RegExp(noAuth).test(req.originalUrl)) {
      const signature = req.headers.signature;
      if (!signature)
        return res
          .status(403)
          .send({ auth: false, message: "No Signature Provided." });
      if (new RegExp(cnaAuth).test(req.originalUrl)) {
        //routes that only Organizations can access
        let userData = await dbOperations.getUserData(userUUID);
        req.cnaOrgName = userData.cnaName;
        if (userData.cnaUUID) {
          verify = verifySignature(signature, userData.cnaPublicKey, payload);
        } else {
          return res
            .status(500)
            .send({ auth: false, message: "Failed to validate key." });
        }
        if (verify) {
          next();
        } else {
          //routes authenticated users can access
          return res
            .status(500)
            .send({ auth: false, message: "Failed to validate key." });
        }
      } else {
        //verify signature. If true user is authenticated and can proceed. Else throw error
        let userData = await dbOperations.getUserData(userUUID);
        if (userData.cnaUUID) {
          verify = verifySignature(signature, userData.cnaPublicKey, payload);
          req.CNAID = userData.cnaUUID;
        } else {
          verify = verifySignature(signature, userData.userPublicKey, payload);
          req.userData = userData;
          req.CNAID = userData.userCNAUUID;
        }
        if (verify) {
          next();
        } else {
          return res
            .status(500)
            .send({ auth: false, message: "Failed to validate key." });
        }
      }
    } else {
      next();
    }
  } catch (err) {
    return res
      .status(500)
      .send({ auth: false, message: "Failed to validate key." });
  }
};

function verifySignature(signature, publicKey, payload) {
  let serverNodeRsa = new NodeRSA(publicKey);
  serverNodeRsa.setOptions({ signingScheme: process.env.RSASigningSchema });
  let verify = serverNodeRsa.verify(payload, signature, null, "hex");
  return verify;
}
