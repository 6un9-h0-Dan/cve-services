import { dbOperations } from '../database/db-operations';
import * as NodeRSA from 'node-rsa';
import { RESPONSE_ERROR_MESSAGE } from '../constants';

/**
 * Verify validation of signature recived from client.
 * @param {string} signature - Signature recived from client.
 * @param {string} publicKey - Publickey stored in DB for the UUID of requesting client.
 * @param {Object} payload - Payload the client is trying to send.
 * @returns {boolean} - If true, user has passed verification.
 */
function verifySignature(signature, publicKey, payload) {
    if (payload === undefined) {
        payload = '';
    }
    let serverNodeRsa = new NodeRSA(publicKey);
    serverNodeRsa.setOptions({ signingScheme: process.env.RSASigningSchema });
    return serverNodeRsa.verify(payload, signature, null, 'hex');
}

export const verifyRequester = async (req, res, next) => {
    const noAuth = /(^\/health-check|\/user-auth|\/sign|\/get-all-cna)/g; // Place route names here that dont need authentication
    const cnaAuth = /(^\/register-user)/g; // Place route names here that only CNA role can use.
    const { userUUID, payload } = req.body;
    var verify = false;
    try {
        if (!new RegExp(noAuth).test(req.originalUrl)) {
            const signature = req.headers.signature;
            if (!signature) return res.status(404).send({ auth: false, message: RESPONSE_ERROR_MESSAGE[404] });
            if (new RegExp(cnaAuth).test(req.originalUrl)) {
                //routes that only Organizations can access
                console.log(userUUID);
                let userData = await dbOperations.getUserData(userUUID);
                console.log(userData);
                req.cnaOrgName = userData.cnaName;
                if (userData.cnaUUID) {
                    verify = verifySignature(signature, userData.cnaPublicKey, payload);
                } else {
                    return res.status(500).send({ auth: false, message: RESPONSE_ERROR_MESSAGE[500] });
                }
                if (verify) {
                    next();
                } else {
                    //routes authenticated users can access
                    return res.status(500).send({ auth: false, message: RESPONSE_ERROR_MESSAGE[500] });
                }
            } else {
                //verify signature. If true user is authenticated and can proceed. Else throw error
                let userData = await dbOperations.getUserData(userUUID);
                if (userData.cnaUUID) {
                    verify = verifySignature(signature, userData.cnaPublicKey, payload);
                    req.CNAID = userData.cnaUUID;
                } else {
                    verify = verifySignature(signature, userData.userPublicKey, payload);
                    req.userData = userData;
                    req.CNAID = userData.userCNAUUID;
                }
                if (verify) {
                    next();
                } else {
                    return res.status(500).send({ auth: false, message: RESPONSE_ERROR_MESSAGE[500] });
                }
            }
        } else {
            next();
        }
    } catch (err) {
        return res.status(500).send({ auth: false, message: RESPONSE_ERROR_MESSAGE[500] });
    }
};
