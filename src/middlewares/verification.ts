import * as jwt from "jsonwebtoken";
import { dbOperations } from "../database/db-operations";
import * as NodeRSA from "node-rsa";

export const verifyRequester = async (req, res, next) => {
  const noAuth = /(^\/health-check|\/user-auth|\/sign)/g; // Place route names here that dont need authentication
  const cnaAuth = /(^\/register-user)/g; // Place route names here that only CNA role can use.
  const { userUUID, payload } = req.body;
  try {
    if (!new RegExp(noAuth).test(req.originalUrl)) {
      const signature = req.headers.signature;
      if (!signature)
        return res
          .status(403)
          .send({ auth: false, message: "No Signature Provided." });

      if (new RegExp(cnaAuth).test(req.originalUrl)) {
        let userData = await dbOperations.getUserData(userUUID);
        if (userData.cnaUUID) {
          var serverNodeRsa = new NodeRSA(userData.cnaPublicKey);
        } else {
          return res
            .status(500)
            .send({ auth: false, message: "Failed to validate key." });
        }
        serverNodeRsa.setOptions({ signingScheme: "pkcs1-sha256" });
        let verify = serverNodeRsa.verify(payload, signature, null, "hex");
        if (verify) {
          next();
        } else {
          return res
            .status(500)
            .send({ auth: false, message: "Failed to validate key." });
        }
      } else {
        //verify signature. If true user is authenticated and can proceed. Else throw error
        let userData = await dbOperations.getUserData(userUUID);
        if (userData.cnaUUID) {
          var serverNodeRsa = new NodeRSA(userData.cnaPublicKey);
        } else {
          var serverNodeRsa = new NodeRSA(userData.userPublicKey);
        }
        serverNodeRsa.setOptions({ signingScheme: "pkcs1-sha256" });
        let verify = serverNodeRsa.verify(payload, signature, null, "hex");

        if (verify) {
          next();
        } else {
          return res
            .status(500)
            .send({ auth: false, message: "Failed to validate key." });
        }
      }
    } else {
      next();
    }
  } catch (err) {
    return res
      .status(500)
      .send({ auth: false, message: "Failed to validate key." });
  }
};
