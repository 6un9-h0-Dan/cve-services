import * as _ from "lodash";

const db = require("./models/index"); // tslint:disable
import { CNADetailsObject, userDetailsObject } from "./dbconstants";

export const dbOperations = {
  async getAllCves() {
    return db.CVES.findAll({}).then(resolve => {
      return Promise.resolve(resolve);
    });
  },

  async getAllCNA() {
    return db.CNAs.findAll({ where: { cnaStatus: "ACTIVE" } }).then(resolve => {
      const cnas = resolve.map(cna => _.omit(cna.dataValues, CNADetailsObject));
      return Promise.resolve(cnas);
    });
  },

  async getAllOrgCvesNoFilter(cveOrganizationUUID) {
    return db.CVES.findAll({ where: { cveOrganizationUUID } }).then(resolve => {
      const cves = resolve.map(cve => _.omit(cve.dataValues));
      return Promise.resolve(cves);
    });
  },
  //Filter only by status for now.
  async getAllOrgCvesFilter(cveOrganizationUUID, cveStatus) {
    return db.CVES.findAll({ where: { cveOrganizationUUID, cveStatus } }).then(
      resolve => {
        const cves = resolve.map(cve => _.omit(cve.dataValues));
        return Promise.resolve(cves);
      }
    );
  },
  async getCveId(cveID, cveOrganizationUUID) {
    return db.CVES.findAll({ where: { cveID, cveOrganizationUUID } }).then(
      resolve => {
        const cves = resolve.map(cve => _.omit(cve.dataValues));
        return Promise.resolve(cves);
      }
    );
  },
  async createUser(user) {
    return db.Users.create(user).then(
      resolve => {
        const { userUUID } = resolve;
        return Promise.resolve(userUUID);
      },
      rejected => {
        return Promise.reject(rejected);
      }
    );
  },

  async getUserData(UUID) {
    return db.CNAs.findOne({
      where: {
        cnaUUID: UUID,
        cnaStatus: "ACTIVE"
      }
    })
      .then(
        resolved => {
          const { cnaPublicKey, cnaUUID, cnaName } = resolved;
          console.log({ cnaPublicKey, cnaUUID, cnaName });
          return Promise.resolve({ cnaPublicKey, cnaUUID, cnaName });
        },
        rejection => {}
      )
      .catch(err => {
        return db.Users.findOne({
          where: {
            userUUID: UUID,
            userStatus: "ACTIVE"
          }
        }).then(
          resolved => {
            const {
              userPublicKey,
              userUUID,
              userType,
              userHardQuota,
              userSoftQuota,
              userDescription,
              userGithubID,
              userFName,
              userLName,
              userEmail,
              userCNAUUID,
              userCNAName
            } = resolved;
            return Promise.resolve({
              userPublicKey,
              userUUID,
              userType,
              userHardQuota,
              userSoftQuota,
              userDescription,
              userGithubID,
              userFName,
              userLName,
              userEmail,
              userCNAUUID,
              userCNAName
            });
          },
          rejection => {
            return Promise.reject(rejection);
          }
        );
      });
  },

  async saveCVE(cveObject) {
    var data = {
      cveID: cveObject.cve_id,
      cveStatus: cveObject.status,
      cveRequesterUserID: cveObject.Requestor.user_id,
      cveRequesterUserName: cveObject.Requestor.user_name,
      cveOrganizationUUID: cveObject.Organization.org_id,
      cveOragnizationName: cveObject.Organization.org_name
    };
    return db.CVES.create(data)
      .then(
        resolved => {
          return Promise.resolve(resolved);
        },
        rejection => {
          console.log(rejection);
          return Promise.reject(rejection);
        }
      )
      .catch(err => {
        console.log(err);
        return Promise.reject(err);
      });
  },

  async editCveStatus(cveID, status: string, cveOrganizationUUID) {
    return db.CVES.update(
      { cveStatus: status },
      {
        where: { cveID, cveOrganizationUUID }
      }
    )
      .then(
        isInDb => {
          return Promise.resolve(isInDb);
        },
        rejection => {
          return Promise.reject(rejection);
        }
      )
      .catch(err => {
        return Promise.reject({ error: err });
      });
  }
};
