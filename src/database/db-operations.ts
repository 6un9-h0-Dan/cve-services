import * as _ from "lodash";
import * as bcrypt from "bcryptjs";

const db = require("./models/index"); // tslint:disable

export const dbOperations = {
  async viewHash(pass: string) {
    bcrypt.hash(pass, 8).then(userHash => {
      console.log(userHash);
    });
  },

  async verifyUserActiveStatus(email: string) {
    return db.Users.findOne({
      where: {
        userEmail: email,
        userStatus: "ACTIVE"
      }
    })
      .then(
        isActive => {
          if (isActive === null) {
            return Promise.reject({ error: "User account not active." });
          } else {
            const {
              userHash,
              userUUID,
              userUName,
              userOrganizationUUID
            } = isActive;
            return Promise.resolve({
              userHash,
              userUUID,
              userUName,
              userOrganizationUUID
            });
          }
        },
        rejected => {
          return Promise.reject(rejected);
        }
      )
      .catch(err => {
        return Promise.reject({ error: err });
      });
  },
  async userAuthentication(email: string, pass: string) {
    return this.verifyUserActiveStatus(email).then(
      resolved => {
        console.log(resolved);
        const {
          userHash,
          userUUID,
          userUName,
          userOrganizationUUID
        } = resolved;
        return bcrypt.compare(pass, userHash).then(isMatch => {
          return isMatch
            ? Promise.resolve({
                userUUID,
                userEmail: email,
                userUName,
                userOrganizationUUID
              })
            : Promise.reject({ error: "User account not verified." });
        });
      },
      rejected => Promise.reject(rejected)
    );
  },
  async getAllCves() {
    return db.CVES.findAll({}).then(resolve => {
      return Promise.resolve(resolve);
    });
  },
  async getAllOrgCvesNoFilter(cveOrganizationUUID) {
    return db.CVES.findAll({ where: { cveOrganizationUUID } }).then(resolve => {
      const cves = resolve.map(cve => _.omit(cve.dataValues));
      return Promise.resolve(cves);
    });
  },
  //Filter only by status for now.
  async getAllOrgCvesFilter(cveOrganizationUUID, cveStatus) {
    return db.CVES.findAll({ where: { cveOrganizationUUID, cveStatus } }).then(
      resolve => {
        const cves = resolve.map(cve => _.omit(cve.dataValues));
        return Promise.resolve(cves);
      }
    );
  },
  async getCveId(cveID, cveOrganizationUUID) {
    return db.CVES.findAll({ where: { cveID, cveOrganizationUUID } }).then(
      resolve => {
        const cves = resolve.map(cve => _.omit(cve.dataValues));
        return Promise.resolve(cves);
      }
    );
  },
  async createJWTRecord(token: string) {
    return db.Token.create({
      token
    }).then(resolve => {
      return Promise.resolve("Token record added.");
    });
  },

  async deleteJWTRecord(token: string) {
    return db.Token.destroy({
      where: { token }
    }).then(resolve => {
      return Promise.resolve(resolve);
    });
  },

  async checkJWTRecord(token: string) {
    return db.Token.findOne({
      where: {
        token
      }
    }).then(
      resolved => {
        return Promise.resolve(resolved);
      },
      rejection => {
        console.log(rejection);
        return Promise.reject(rejection);
      }
    );
  },

  async saveCVE(cveObject) {
    var data = {
      cveID: cveObject.cve_id,
      cveStatus: cveObject.status,
      cveRequesterUserID: cveObject.Requestor.user_id,
      cveRequesterUserName: cveObject.Requestor.user_name,
      cveOrganizationUUID: cveObject.Organization.org_id,
      cveOragnizationName: cveObject.Organization.org_name
    };
    return db.CVES.create(data)
      .then(
        resolved => {
          return Promise.resolve(resolved);
        },
        rejection => {
          console.log(rejection);
          return Promise.reject(rejection);
        }
      )
      .catch(err => {
        console.log(err);
        return Promise.reject(err);
      });
  },

  async editCveStatus(cveID, status: string, cveOrganizationUUID) {
    return db.CVES.update(
      { cveStatus: status },
      {
        where: { cveID, cveOrganizationUUID }
      }
    )
      .then(
        isInDb => {
          return Promise.resolve(isInDb);
        },
        rejection => {
          return Promise.reject(rejection);
        }
      )
      .catch(err => {
        return Promise.reject({ error: err });
      });
  },

  //---------------------------FOR DEV ONLY--------------------

  async getMitreOrg() {
    return db.Organizations.findAll({
      where: {
        organizationName: "MITRE"
      }
    }).then(resolve => {
      const org = resolve.map(org => _.omit(org.dataValues));
      console.log(org[0].organizationUUID);
      return org[0].organizationUUID;
    });
  },
  async setUserOrg(organizationUUID, userUUID) {
    return db.Users.update(
      {
        userOrganizationUUID: organizationUUID
      },
      { where: { userUUID } }
    ).then(resolved => {
      return resolved;
    });
  }
};
