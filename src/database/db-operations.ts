import * as _ from "lodash";

const db = require("./models/index"); // tslint:disable

export const dbOperations = {
  async getAllCves() {
    return db.CVES.findAll({}).then(resolve => {
      return Promise.resolve(resolve);
    });
  },
  async getAllOrgCvesNoFilter(cveOrganizationUUID) {
    return db.CVES.findAll({ where: { cveOrganizationUUID } }).then(resolve => {
      const cves = resolve.map(cve => _.omit(cve.dataValues));
      return Promise.resolve(cves);
    });
  },
  //Filter only by status for now.
  async getAllOrgCvesFilter(cveOrganizationUUID, cveStatus) {
    return db.CVES.findAll({ where: { cveOrganizationUUID, cveStatus } }).then(
      resolve => {
        const cves = resolve.map(cve => _.omit(cve.dataValues));
        return Promise.resolve(cves);
      }
    );
  },
  async getCveId(cveID, cveOrganizationUUID) {
    return db.CVES.findAll({ where: { cveID, cveOrganizationUUID } }).then(
      resolve => {
        const cves = resolve.map(cve => _.omit(cve.dataValues));
        return Promise.resolve(cves);
      }
    );
  },
  async createUser(user) {
    return db.Users.create(user).then(
      resolve => {
        const { userUUID } = resolve;
        return Promise.resolve(userUUID);
      },
      rejected => {
        return Promise.reject(rejected);
      }
    );
  },

  async getUserData(UUID) {
    console.log("here");
    return db.CNAs.findOne({
      where: {
        cnaUUID: UUID,
        cnaStatus: "ACTIVE"
      }
    }).then(
      resolved => {
        const { cnaPublicKey, cnaUUID } = resolved;
        return Promise.resolve({ cnaPublicKey, cnaUUID });
      },
      rejection => {
        console.log(rejection);
        return db.Users.findOne({
          where: {
            cnaUUID: UUID,
            userStatus: "ACTIVE"
          }
        }).then(
          resolved => {
            const { userPublicKey, userUUID } = resolved;
            return Promise.resolve({ userPublicKey, userUUID });
          },
          rejection => {
            return Promise.reject(rejection);
          }
        );
      }
    );
  },

  async saveCVE(cveObject) {
    var data = {
      cveID: cveObject.cve_id,
      cveStatus: cveObject.status,
      cveRequesterUserID: cveObject.Requestor.user_id,
      cveRequesterUserName: cveObject.Requestor.user_name,
      cveOrganizationUUID: cveObject.Organization.org_id,
      cveOragnizationName: cveObject.Organization.org_name
    };
    return db.CVES.create(data)
      .then(
        resolved => {
          return Promise.resolve(resolved);
        },
        rejection => {
          console.log(rejection);
          return Promise.reject(rejection);
        }
      )
      .catch(err => {
        console.log(err);
        return Promise.reject(err);
      });
  },

  async editCveStatus(cveID, status: string, cveOrganizationUUID) {
    return db.CVES.update(
      { cveStatus: status },
      {
        where: { cveID, cveOrganizationUUID }
      }
    )
      .then(
        isInDb => {
          return Promise.resolve(isInDb);
        },
        rejection => {
          return Promise.reject(rejection);
        }
      )
      .catch(err => {
        return Promise.reject({ error: err });
      });
  }
};
