require('dotenv').config()
const User = require('../../model/user')
const Org = require('../../model/org')
const CveId = require('../../model/cve-id')
const logger = require('../../middleware/logger')
const CONSTANTS = require('../../constants')
const uuidAPIKey = require('uuid-apikey')
const utils = require('../../utils/utils')
const uuid = require('uuid')

// Get the details of all cnas
async function getCnas (req, res, next) {
  try {
    const result = await Org.aggregate([
      {
        $project: {
          _id: false,
          UUID: true,
          short_name: true,
          name: true,
          'authority.active_roles': true,
          'policies.id_quota': true,
          time: true
        }
      }
    ])

    logger.info('The CNAs were sent to the user.')
    return res.status(200).json(result)
  } catch (err) {
    next(err)
  }
}

// Get the details of a single cna for the specified shortname
async function getCna (req, res, next) {
  try {
    const shortName = req.params.shortname
    const result = await Org.aggregate([
      {
        $match: { short_name: shortName }
      },
      {
        $project: {
          _id: false,
          UUID: true,
          short_name: true,
          name: true,
          'authority.active_roles': true,
          'policies.id_quota': true,
          time: true
        }
      }
    ])

    if (utils.isEmptyObject(result)) {
      logger.info(shortName + ' CNA does not exist.')
      return res.status(404).json({ message: shortName + ' CNA does not exist.' })
    }

    logger.info({ message: shortName + ' CNA was sent to the user.', cna: result })
    return res.status(200).json(result[0])
  } catch (err) {
    next(err)
  }
}

// Get the details of a single user for the specified username
async function getUser (req, res, next) {
  try {
    const username = req.params.username
    const cnaShortName = req.params.shortname
    let returned = false

    const orgUUID = await utils.getOrgUUID(cnaShortName)
    if (!orgUUID) {
      returned = true
      logger.info(cnaShortName + ' CNA does not exist.')
      return res.status(404).json({ message: cnaShortName + ' CNA does not exist.' })
    }

    if (!returned) {
      const result = await User.aggregate([
        {
          $match: { username: username, org_UUID: orgUUID }
        },
        {
          $project: {
            _id: false,
            UUID: true,
            username: true,
            org_UUID: true,
            name: true,
            active: true,
            time: true
          }
        }
      ])

      if (utils.isEmptyObject(result)) {
        logger.info(username + ' does not exist.')
        return res.status(404).json({ message: username + ' does not exist.' })
      }

      logger.info({ message: username + ' was sent to the user.', user: result })
      return res.status(200).json(result[0])
    }
  } catch (err) {
    next(err)
  }
}

// Get details on ID quota for a org with the specified org shortname
async function getOrgIdQuota (req, res, next) {
  try {
    const cnaShortName = req.header(CONSTANTS.AUTH_HEADERS.ORG)
    const shortName = req.params.shortname

    const isSecretariat = await utils.isSecretariat(cnaShortName)
    if (cnaShortName !== shortName && !isSecretariat) {
      logger.info({ message: shortName + ' CNA id quota can only be viewed by the owning CNA or the Secretariat.' })
      return res.status(403).json({ message: 'This information can only be viewed by the owning CNA or the Secretariat.' })
    }

    let result = await Org.findOne().byShortName(shortName)
    if (!result) {
      logger.info(shortName + ' CNA does not exist.')
      return res.status(404).json({ message: shortName + ' CNA does not exist.' })
    }

    const returnPayload = {
      id_quota: result.policies.id_quota,
      total_reserved: null,
      available: null
    }

    const query = {
      owning_cna: shortName,
      state: 'RESERVED'
    }

    result = await CveId.countDocuments(query)
    returnPayload.total_reserved = result
    returnPayload.available = (returnPayload.id_quota - returnPayload.total_reserved)

    logger.info({ message: 'The CVE ID quota returned to the user.', details: returnPayload })
    return res.status(200).json(returnPayload)
  } catch (err) {
    next(err)
  }
}

// Creates a new cna only if the cna doesn't exist for the specified shortname. If the cna exists, it does not update the cna.
async function createCna (req, res, next) {
  try {
    const newCna = new Org(req.body)
    let returned = false

    if (newCna.short_name === undefined || newCna.short_name === null) {
      return res.status(400).json({ message: 'Provide the cna\'s short name to create the cna.' })
    }

    if (newCna.name === undefined || newCna.name === null) {
      return res.status(400).json({ message: 'Provide the cna\'s name to create the cna.' })
    }

    if (newCna.short_name.length < 1) {
      return res.status(400).json({ message: 'The cna\'s short name cannot be an empty string.' })
    }

    if (newCna.name.length < 1) {
      return res.status(400).json({ message: 'The cna\'s name cannot be an empty string.' })
    }

    const result = await Org.findOne().byShortName(newCna.short_name) // Find cna in MongoDB
    if (result) {
      logger.info(newCna.short_name + ' CNA was not created because it already exists.')
      return res.status(400).json({ message: newCna.short_name + ' CNA already exists.' })
    }

    newCna.inUse = false

    // policies are undefined
    if (newCna.authority.active_roles.length === 0) {
    // default role
      newCna.authority.active_roles = [CONSTANTS.AUTH_ROLE_ENUM.CNA]
    } else {
      newCna.authority.active_roles.forEach(r => {
        const role = r.replace(/["']/g, '').toUpperCase()

        // validate roles
        if (!CONSTANTS.CNA_ROLES.includes(role) && !returned) {
          returned = true
          return res.status(400).json({ message: 'CNA role \'' + role + '\' does not exist.' })
        }
      })
    }

    if (newCna.UUID === undefined || newCna.UUID === null) {
      newCna.UUID = uuid.v4()
    }

    if (!returned) {
      if (newCna.policies.id_quota === undefined || newCna.policies.id_quota === null) {
        newCna.policies.id_quota = CONSTANTS.DEFAULT_ID_QUOTA
      } else {
      // validate id_quota
        if (CONSTANTS.MONGOOSE_VALIDATION.Org_policies_id_quota_min > newCna.policies.id_quota ||
        newCna.policies.id_quota > CONSTANTS.MONGOOSE_VALIDATION.Org_policies_id_quota_max) {
          returned = true
          return res.status(403).json({ message: 'The id_quota does not comply with CVE id quota limitations.' })
        }
      }
    }

    if (!returned) {
      await Org.findOneAndUpdate().byUUID(newCna.UUID).updateOne(newCna).setOptions({ upsert: true }) // Create cna in MongoDB if it doesn't exist

      const responseMessage = {
        message: newCna.short_name + ' CNA was successfully created.',
        created: newCna
      }

      logger.info(JSON.stringify(responseMessage))
      return res.status(200).json(responseMessage)
    }
  } catch (err) {
    next(err)
  }
}

// Updates a cna only if the cna exist for the specified shortname. If no cna exists, it does not create the cna.
async function updateCna (req, res, next) {
  try {
    const shortName = req.params.shortname
    const newCna = new Org()
    let returned = false
    let quota
    let name
    let shortname
    const removeRoles = []
    const addRoles = []
    const org = await Org.findOne().byShortName(shortName)

    // org doesn't exist
    if (!org && !returned) {
      returned = true
      logger.info(shortName + ' CNA could not be updated in MongoDB because it does not exist.')
      return res.status(404).json({ message: shortName + ' CNA does not exist.' })
    }

    // parsing query parameters
    Object.keys(req.query).forEach(key => {
      if (!returned) {
        if (key === 'id_quota') {
          quota = req.query.id_quota.replace(/["']/g, '')
        } else if (key === 'name') {
          name = req.query.name.replace(/["']/g, '')
        } else if (key === 'shortname') {
          shortname = req.query.shortname.replace(/["']/g, '')
        } else if (key === 'active_roles.add') {
          if (Array.isArray(req.query['active_roles.add'])) {
            req.query['active_roles.add'].forEach(r => {
              const role = r.replace(/["']/g, '').toUpperCase()

              if (!CONSTANTS.CNA_ROLES.includes(role)) {
                returned = true
                logger.info('Invalid role for CNA', role)
                return res.status(400).json({ message: 'CNA role \'' + role + '\' does not exist.' })
              }

              addRoles.push(role)
            })
          } else {
            const role = req.query['active_roles.add'].replace(/["']/g, '').toUpperCase()

            if (!CONSTANTS.CNA_ROLES.includes(role)) {
              returned = true
              logger.info('Invalid role for CNA', role)
              return res.status(400).json({ message: 'CNA role \'' + role + '\' does not exist.' })
            }

            addRoles.push(role)
          }
        } else if (key === 'active_roles.remove') {
          if (Array.isArray(req.query['active_roles.remove'])) {
            req.query['active_roles.remove'].forEach(r => {
              const role = r.replace(/["']/g, '').toUpperCase()

              if (!CONSTANTS.CNA_ROLES.includes(role)) {
                returned = true
                logger.info('Invalid role for CNA', role)
                return res.status(400).json({ message: 'CNA role \'' + role + '\' does not exist.' })
              }

              removeRoles.push(role)
            })
          } else {
            const role = req.query['active_roles.remove'].replace(/["']/g, '').toUpperCase()

            if (!CONSTANTS.CNA_ROLES.includes(role)) {
              returned = true
              logger.info('Invalid role for CNA', role)
              return res.status(400).json({ message: 'CNA role \'' + role + '\' does not exist.' })
            }

            removeRoles.push(role)
          }
        } else {
          returned = true
          return res.status(400).json({ message: 'Invalid query parameter \'' + key + '\'' })
        }
      }
    })

    // updating the org's roles
    if (org && !returned) {
      const roles = org.authority.active_roles
      newCna.policies.id_quota = org.policies.id_quota

      // adding roles
      addRoles.forEach(role => {
        if (!roles.includes(role)) {
          roles.push(role)
        }
      })

      // removing roles
      removeRoles.forEach(role => {
        const index = roles.indexOf(role)

        if (index > -1) {
          roles.splice(index, 1)
        }
      })

      newCna.authority.active_roles = roles
    }

    // updating the org's quota
    if (quota && !returned) {
      const result = quota.match(/^-*\d+$/)

      if (!result) {
        returned = true
        return res.status(400).json(CONSTANTS.INVALID_ID_QUOTA)
      }

      newCna.policies.id_quota = quota

      if ((CONSTANTS.MONGOOSE_VALIDATION.Org_policies_id_quota_min > newCna.policies.id_quota ||
      newCna.policies.id_quota > CONSTANTS.MONGOOSE_VALIDATION.Org_policies_id_quota_max) && !returned) {
        returned = true
        return res.status(403).json({ message: 'The id_quota does not comply with CVE id quota limitations.' })
      }
    }

    // updating the org's name (the name field is never an empty string due to the stripping of the quotes and double quotes)
    if (name && !returned) {
      newCna.name = name
    }

    // updating the org's shortname (the shortname field is never an empty string due to the stripping of the quotes and double quotes)
    if (shortname && !returned) {
      newCna.short_name = shortname
      const result = await Org.findOne().byShortName(newCna.short_name)

      if (result && !returned) {
        returned = true
        return res.status(403).json({ message: 'CNA can not be renamed as ' + newCna.short_name + ' because this shortname is used by another CNA.' })
      }
    }

    // update org
    if (!returned) {
      const result = await Org.findOneAndUpdate().byUUID(org.UUID).updateOne(newCna)

      if (result.n === 0) {
        logger.info(shortName + ' CNA could not be updated in MongoDB because it does not exist.')
        return res.status(404).json({ message: shortName + ' CNA does not exist.' })
      }

      const responseMessage = {
        message: shortName + ' CNA was successfully updated.',
        updated: newCna
      }

      logger.info(JSON.stringify(responseMessage))
      return res.status(200).json(responseMessage)
    }
  } catch (err) {
    next(err)
  }
}

// Creates a user only if the cna exist and the user doesn't exist for the specified shortname and username respectively.
async function createUser (req, res, next) {
  try {
    const cnaShortName = req.params.shortname
    const newUser = new User(req.body)

    if (newUser.username === undefined || newUser.username === null) {
      return res.status(400).json({ message: 'To create a user, a username must be provided.' })
    }

    if (newUser.username.length < 1) {
      return res.status(400).json({ message: 'The user\'s username cannot be an empty string.' })
    }

    const orgUUID = await utils.getOrgUUID(cnaShortName)
    if (!orgUUID) {
      logger.info('The user could not be created because ' + cnaShortName + ' CNA does not exist.')
      return res.status(404).json({ message: 'The user could not be created because ' + cnaShortName + ' CNA does not exist.' })
    }

    if (newUser.org_UUID === undefined || newUser.org_UUID === null) {
      newUser.org_UUID = orgUUID
    }

    // If org's UUID was provided in the body, it must match the org's UUID of the org provided in the URL params
    if (newUser.org_UUID !== orgUUID) {
      const temp = await Org.findOne().byUUID(newUser.org_UUID)
      let sn

      if (!temp) {
        sn = null
      } else {
        sn = temp.short_name
      }

      return res.status(400).json({ message: cnaShortName + ' URL parameter does not match ' + sn + ' in the JSON body.' })
    }

    let result = await Org.findOne().byUUID(newUser.org_UUID) // Check the cna exists

    if (!result) {
      logger.info('The user could not be created because ' + cnaShortName + ' CNA does not exist.')
      return res.status(400).json({ message: 'The user could not be created because ' + cnaShortName + ' CNA does not exist.' })
    }

    newUser.active = true
    const key = uuidAPIKey.create()
    newUser.secret = key.uuid

    if (newUser.UUID === undefined || newUser.UUID === null) {
      newUser.UUID = uuid.v4()
    }

    result = await User.findOne().byUserNameAndOrgUUID(newUser.username, newUser.org_UUID) // Find user in MongoDB

    if (result) {
      logger.info(newUser.username + ' was not created because it already exists.')
      return res.status(400).json({ message: newUser.username + ' already exists.' })
    }

    await User.findOneAndUpdate().byUserNameAndOrgUUID(newUser.username, newUser.org_UUID).updateOne(newUser).setOptions({ upsert: true }) // Create user in MongoDB if it doesn't exist

    newUser.secret = key.apiKey
    const responseMessage = {
      message: newUser.username + ' was successfully created.',
      created: newUser
    }

    logger.info(JSON.stringify(responseMessage))
    return res.status(200).json(responseMessage)
  } catch (err) {
    next(err)
  }
}

// Updates a user only if the user exist for the specified username. If no user exists, it does not create the user.
async function updateUser (req, res, next) {
  try {
    const username = req.params.username
    const shortName = req.params.shortname
    const newUser = new User()
    let returned = false
    let nameChanged = false
    let newUsername
    let newCnaShortname
    let active
    const name = {
      first: null,
      ast: null,
      middle: null,
      surname: null,
      suffix: null
    }

    const orgUUID = await utils.getOrgUUID(shortName)
    if (!orgUUID) {
      returned = true
      logger.info('The user could not be updated because ' + shortName + ' CNA does not exist.')
      return res.status(404).json({ message: 'The user could not be updated because ' + shortName + ' CNA does not exist.' })
    }

    const user = await User.findOne().byUserNameAndOrgUUID(username, orgUUID)
    if (!user) {
      returned = true
      logger.info('The user could not be updated because ' + username + ' does not exist for ' + shortName + ' CNA')
      return res.status(404).json({ message: username + ' could not be found.' })
    }

    Object.keys(req.query).forEach(key => {
      if (!returned) {
        if (key === 'new_username') {
          newUsername = req.query.new_username.replace(/["']/g, '')
        } else if (key === 'new_cna_shortname') {
          newCnaShortname = req.query.new_cna_shortname.replace(/["']/g, '')
        } else if (key === 'active') {
          active = req.query.active.replace(/["']/g, '').toLowerCase()

          if (active !== 'true' && active !== 'false') {
            returned = true
            return res.status(400).json({ message: 'Bad query parameter.' })
          }
        } else if (key === 'name.first') {
          name.first = req.query['name.first'].replace(/["']/g, '')
          user.name.first = name.first
          nameChanged = true
        } else if (key === 'name.last') {
          name.last = req.query['name.last'].replace(/["']/g, '')
          user.name.last = name.last
          nameChanged = true
        } else if (key === 'name.middle') {
          name.middle = req.query['name.middle'].replace(/["']/g, '')
          user.name.middle = name.middle
          nameChanged = true
        } else if (key === 'name.suffix') {
          name.suffix = req.query['name.suffix'].replace(/["']/g, '')
          user.name.suffix = name.suffix
          nameChanged = true
        } else if (key === 'name.surname') {
          name.surname = req.query['name.surname'].replace(/["']/g, '')
          user.name.surname = name.surname
          nameChanged = true
        } else {
          returned = true
          return res.status(400).json({ message: 'Invalid query parameter \'' + key + '\'' })
        }
      }
    })

    // updating the user's username (the username field is never an empty string due to the stripping of the quotes and double quotes)
    if (newUsername && !returned) {
      newUser.username = newUsername
    }

    if (active && !returned) {
      newUser.active = active
    }

    // only update the name sub fields that were changed
    if (nameChanged && !returned) {
      newUser.name = user.name
    }

    // check if the new org exist
    if (newCnaShortname && !returned) {
      newUser.org_UUID = await utils.getOrgUUID(newCnaShortname)

      if (!newUser.org_UUID) {
        returned = true
        logger.info('The user could not be updated because ' + newCnaShortname + ' CNA does not exist.')
        return res.status(404).json({ message: 'The user could not be updated because ' + newCnaShortname + ' CNA does not exist.' })
      }
    }

    if (!returned) {
      const result = await User.findOneAndUpdate().byUserNameAndOrgUUID(username, orgUUID).updateOne(newUser)

      if (result.n === 0) {
        logger.info('The user could not be updated because ' + username + ' does not exist for ' + shortName + ' CNA')
        return res.status(404).json({ message: username + ' could not be found.' })
      }

      const responseMessage = {
        message: username + ' was successfully updated.',
        updated: newUser
      }

      logger.info(JSON.stringify(responseMessage))
      return res.status(200).json(responseMessage)
    }
  } catch (err) {
    next(err)
  }
}

// Resets the user secret
async function resetSecret (req, res, next) {
  try {
    const username = req.params.username
    const cnaShortName = req.params.shortname
    const newUser = new User()
    const keyUUIDPair = uuidAPIKey.create()
    const key = keyUUIDPair.apiKey // send to user
    newUser.secret = keyUUIDPair.uuid // store in db
    newUser.username = username
    const orgUUID = await utils.getOrgUUID(cnaShortName) // userUUID may be null if user does  not exist

    if (!orgUUID) {
      logger.info(cnaShortName + ' CNA does not exist.')
      return res.status(404).json({ message: 'The user secret could not be reset because ' + cnaShortName + ' CNA does not exist.' })
    }

    const result = await User.findOneAndUpdate().byUserNameAndOrgUUID(newUser.username, orgUUID).updateOne(newUser)
    if (result.n === 0) {
      logger.info('The user could not be updated because ' + username + ' does not exist for ' + cnaShortName)
      return res.status(404).json({ message: username + ' could not be found.' })
    }

    logger.info(JSON.stringify('The API secret was successfully reset and sent to ' + username, newUser.secret))
    return res.status(200).json({ 'API-secret': key })
  } catch (err) {
    next(err)
  }
}

module.exports = {
  CNA_ALL: getCnas,
  CNA_SINGLE: getCna,
  CNA_CREATE_SINGLE: createCna,
  CNA_UPDATE_SINGLE: updateCna,
  ORG_ID_QUOTA: getOrgIdQuota,
  USER_SINGLE: getUser,
  USER_CREATE_SINGLE: createUser,
  USER_UPDATE_SINGLE: updateUser,
  USER_RESET_SECRET: resetSecret
}
