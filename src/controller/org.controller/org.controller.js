require('dotenv').config()
const User = require('../../model/user')
const Org = require('../../model/org')
const CveId = require('../../model/cve-id')
const logger = require('../../middleware/logger')
const CONSTANTS = require('../../constants')
const uuidAPIKey = require('uuid-apikey')
const utils = require('../../utils/utils')
const uuid = require('uuid')

// Get the details of all cnas
async function getCnas (req, res) {
  Org.find().exec((err, result) => {
    if (err) {
      logger.error(err.stack)
      return res.status(500).send(CONSTANTS.SERVER_RESPONSES.Internal_Server_Error)
    }

    if (result) {
      result.forEach((obj) => {
        const cna = Object.assign({}, obj)._doc
        delete cna._id

        if (cna.__v !== undefined) {
          delete cna.__v
        }
      })
    }

    logger.info('The CNAs were sent to the user.')
    return res.status(200).json(result)
  })
}

// Get the details of a single cna for the specified shortname
async function getCna (req, res) {
  const shortName = req.params.shortname

  Org.findOne()
    .byShortName(shortName)
    .exec((err, result) => {
      if (err) {
        logger.error(err.stack)
        return res.status(500).send(CONSTANTS.SERVER_RESPONSES.Internal_Server_Error)
      }

      if (!result) {
        logger.info(shortName + ' CNA does not exist.')
        return res.status(404).json({ message: shortName + ' CNA does not exist.' })
      }

      const cna = Object.assign({}, result)._doc
      delete cna._id

      if (cna.__v !== undefined) {
        delete cna.__v
      }

      logger.info({ message: shortName + ' CNA was sent to the user.', cna: cna })
      return res.status(200).json(cna)
    })
}

// Get details on ID quota for a org with the specified org shortname
async function getOrgIdQuota (req, res) {
  const cnaShortName = req.header(CONSTANTS.AUTH_HEADERS.ORG)
  const shortName = req.params.shortname

  const isSecretariat = await utils.isSecretariat(cnaShortName)
  if (cnaShortName !== shortName && !isSecretariat) {
    logger.info({ message: shortName + ' CNA id quota can only be viewed by the owning CNA or the Secretariat.' })
    return res.status(403).json({ message: 'This information can only be viewed by the owning CNA or the Secretariat.' })
  }

  Org.findOne()
    .byShortName(shortName)
    .exec(async (err, result) => {
      if (err) {
        logger.error(err.stack)
        return res.status(500).send(CONSTANTS.SERVER_RESPONSES.Internal_Server_Error)
      }

      if (!result) {
        logger.info(shortName + ' CNA does not exist.')
        return res.status(404).json({ message: shortName + ' CNA does not exist.' })
      }

      const returnPayload = {
        id_quota: result.policies.id_quota,
        total_reserved: null,
        available: null
      }

      const query = {
        owning_cna: shortName,
        state: 'RESERVED'
      }

      CveId.countDocuments(query)
        .exec((err, result) => {
          if (err) {
            logger.error(err.stack)
            return res.status(500).send('Internal Server Error')
          }

          returnPayload.total_reserved = result
          returnPayload.available = (returnPayload.id_quota - returnPayload.total_reserved)

          logger.info({ message: 'The CVE ID quota returned to the user.', details: returnPayload })
          return res.status(200).json(returnPayload)
        })
    })
}

// Get the details of a single user for the specified username
async function getUser (req, res) {
  const username = req.params.username
  const cnaShortName = req.params.shortname
  const orgUUID = await utils.getOrgUUID(cnaShortName) // userUUID may be null if user does  not exist

  if (!orgUUID) {
    logger.info(cnaShortName + ' CNA does not exist.')
    return res.status(404).json({ message: cnaShortName + ' CNA does not exist.' })
  }

  User.findOne()
    .byUserNameAndOrgUUID(username, orgUUID)
    .exec((err, result) => {
      if (err) {
        logger.error(err.stack)
        return res.status(500).send(CONSTANTS.SERVER_RESPONSES.Internal_Server_Error)
      }

      if (!result) {
        logger.info(username + ' does not exist.')
        return res.status(404).json({ message: username + ' does not exist.' })
      }

      const user = Object.assign({}, result)._doc
      delete user._id
      delete user.secret

      if (user.__v !== undefined) {
        delete user.__v
      }

      logger.info({ message: username + ' was sent to the user.', user: user })
      return res.status(200).json(user)
    })
}

// Creates a new cna only if the cna doesn't exist for the specified shortname. If the cna exists, it does not update the cna.
async function createCna (req, res) {
  const newCna = new Org(req.body)
  let returned = false

  if (newCna.short_name === undefined || newCna.short_name === null) {
    return res.status(400).json({ message: 'Provide the cna\'s short name to create the cna.' })
  }

  if (newCna.name === undefined || newCna.name === null) {
    return res.status(400).json({ message: 'Provide the cna\'s name to create the cna.' })
  }

  // Find cna in MongoDB
  Org.findOne()
    .byShortName(newCna.short_name)
    .exec(async (err, result) => {
      if (err) {
        logger.error(err.stack)
        return res.status(500).send(CONSTANTS.SERVER_RESPONSES.Internal_Server_Error)
      }

      if (result) {
        logger.info(newCna.short_name + ' CNA was not created because it already exists.')
        return res.status(400).json({ message: newCna.short_name + ' CNA already exists.' })
      }

      // policies are undefined
      if (newCna.authority.active_roles.length === 0) {
        // default role
        newCna.authority.active_roles = [CONSTANTS.AUTH_ROLE_ENUM.CNA]
      } else {
        newCna.authority.active_roles.forEach(role => {
          // validate roles
          if (!CONSTANTS.CNA_ROLES.includes(role) && !returned) {
            returned = true
            return res.status(400).json({ message: 'CNA role \'' + role + '\' does not exist.' })
          }
        })
      }

      if (newCna.UUID === undefined || newCna.UUID === null) {
        newCna.UUID = uuid.v4()
      }

      if (!returned) {
        // org is secretariat
        if (newCna.authority.active_roles.includes(CONSTANTS.AUTH_ROLE_ENUM.SECRETARIAT)) {
          newCna.policies.id_quota = 0
        } else if (newCna.policies.id_quota === undefined || newCna.policies.id_quota === null) {
          newCna.policies.id_quota = CONSTANTS.DEFAULT_ID_QUOTA
        } else {
          // validate id_quota
          if (CONSTANTS.MONGOOSE_VALIDATION.Org_policies_id_quota_min > newCna.policies.id_quota ||
            newCna.policies.id_quota > CONSTANTS.MONGOOSE_VALIDATION.Org_policies_id_quota_max) {
            returned = true
            return res.status(403).json({ message: 'The id_quota does not comply with CVE id quota limitations.' })
          }
        }
      }

      if (!returned) {
        // Create cna in MongoDB if it doesn't exist
        Org.findOneAndUpdate()
          .byUUID(newCna.UUID)
          .updateOne(newCna)
          .setOptions({ upsert: true })
          .exec((err) => {
            if (err) {
              logger.error(err.stack)
              return res.status(500).send(CONSTANTS.SERVER_RESPONSES.Internal_Server_Error)
            }

            const responseMessage = {
              message: newCna.short_name + ' CNA was successfully created.',
              created: newCna
            }

            logger.info(JSON.stringify(responseMessage))
            return res.status(200).json(responseMessage)
          })
      }
    })
}

// Updates a cna only if the cna exist for the specified shortname. If no cna exists, it does not create the cna.
async function updateCna (req, res) {
  const cnaShortName = req.header(CONSTANTS.AUTH_HEADERS.ORG)
  const shortName = req.params.shortname
  const newCna = new Org()
  let returned = false
  let quota
  let name
  let shortname
  const removeRoles = []
  const addRoles = []

  const isSecretariat = await utils.isSecretariat(cnaShortName)
  if (!isSecretariat) {
    logger.info(shortName + ' CNA could not be updated because the requestor is not the the Secretariat.')
    return res.status(403).json({ message: 'A CNA cannot be updated by other than the Secretariat.' })
  }

  Object.keys(req.query).forEach(key => {
    if (!returned) {
      if (key === 'id_quota') {
        quota = req.query.id_quota.replace(/["']/g, '')
      } else if (key === 'name') {
        name = req.query.name.replace(/["']/g, '')
      } else if (key === 'shortname') {
        shortname = req.query.shortname.replace(/["']/g, '')
      } else if (key === 'active_roles.add') {
        if (Array.isArray(req.query['active_roles.add'])) {
          req.query['active_roles.add'].forEach(r => {
            const role = r.replace(/["']/g, '').toUpperCase()

            if (!CONSTANTS.CNA_ROLES.includes(role)) {
              returned = true
              logger.info('Invalid role for CNA', role)
              return res.status(400).json({ message: 'CNA role \'' + role + '\' does not exist.' })
            }

            addRoles.push(role)
          })
        } else {
          const role = req.query['active_roles.add'].replace(/["']/g, '').toUpperCase()

          if (!CONSTANTS.CNA_ROLES.includes(role)) {
            returned = true
            logger.info('Invalid role for CNA', role)
            return res.status(400).json({ message: 'CNA role \'' + role + '\' does not exist.' })
          }

          addRoles.push(role)
        }
      } else if (key === 'active_roles.remove') {
        if (Array.isArray(req.query['active_roles.remove'])) {
          req.query['active_roles.remove'].forEach(r => {
            const role = r.replace(/["']/g, '').toUpperCase()

            if (!CONSTANTS.CNA_ROLES.includes(role)) {
              returned = true
              logger.info('Invalid role for CNA', role)
              return res.status(400).json({ message: 'CNA role \'' + role + '\' does not exist.' })
            }

            removeRoles.push(role)
          })
        } else {
          const role = req.query['active_roles.remove'].replace(/["']/g, '').toUpperCase()

          if (!CONSTANTS.CNA_ROLES.includes(role)) {
            returned = true
            logger.info('Invalid role for CNA', role)
            return res.status(400).json({ message: 'CNA role \'' + role + '\' does not exist.' })
          }

          removeRoles.push(role)
        }
      } else {
        returned = true
        return res.status(400).json({ message: 'Invalid query parameter \'' + key + '\'' })
      }
    }
  })

  const org = await Org.findOne().byShortName(shortName)

  // updating the org's roles
  if (org && !returned) {
    const roles = org.authority.active_roles
    newCna.policies.id_quota = org.policies.id_quota

    // adding roles
    addRoles.forEach(role => {
      if (!roles.includes(role)) {
        roles.push(role)
      }
    })

    // removing roles
    removeRoles.forEach(role => {
      const index = roles.indexOf(role)

      if (index > -1) {
        roles.splice(index, 1)
      }
    })

    newCna.authority.active_roles = roles
  }

  // updating the org's quota
  if (quota && !returned) {
    const result = quota.match(/^-*\d+$/)

    if (!result) {
      returned = true
      return res.status(400).json(CONSTANTS.INVALID_ID_QUOTA)
    }

    newCna.policies.id_quota = quota

    if ((CONSTANTS.MONGOOSE_VALIDATION.Org_policies_id_quota_min > newCna.policies.id_quota ||
      newCna.policies.id_quota > CONSTANTS.MONGOOSE_VALIDATION.Org_policies_id_quota_max) && !returned) {
      returned = true
      return res.status(403).json({ message: 'The id_quota does not comply with CVE id quota limitations.' })
    }
  }

  // updating the org's name
  if (name && !returned) {
    newCna.name = name
  }

  // updating the org's shortname
  if (shortname && !returned) {
    const result = await Org.findOne().byShortName(shortname)

    if (result && !returned) {
      returned = true
      return res.status(403).json({ message: 'CNA can not be renamed as ' + shortname + ' because this shortname is used by another CNA.' })
    }

    newCna.short_name = shortname
  }

  // org doesn't exist
  if (!org && !returned) {
    returned = true
    logger.info(shortName + ' CNA could not be updated in MongoDB because it does not exist.')
    return res.status(404).json({ message: shortName + ' CNA does not exist.' })
  }

  // update org
  if (!returned) {
    Org.findOneAndUpdate()
      .byUUID(org.UUID)
      .updateOne(newCna)
      .exec((err, result) => {
        if (err) {
          logger.error(err.stack)
          return res.status(500).send(CONSTANTS.SERVER_RESPONSES.Internal_Server_Error)
        }

        if (result.n === 0) {
          logger.info(shortName + ' CNA could not be updated in MongoDB because it does not exist.')
          return res.status(404).json({ message: shortName + ' CNA does not exist.' })
        }

        const responseMessage = {
          message: shortName + ' CNA was successfully updated.',
          updated: newCna
        }

        logger.info(JSON.stringify(responseMessage))
        return res.status(200).json(responseMessage)
      })
  }
}

// Creates a user only if the cna exist and the user doesn't exist for the specified shortname and username respectively.
async function createUser (req, res) {
  const cnaShortName = req.params.shortname
  const newUser = new User(req.body)

  if (newUser.username === undefined || newUser.username === null) {
    return res.status(400).json({ message: 'To create a user, a username must be provided.' })
  }

  if (newUser.org_UUID === undefined || newUser.org_UUID === null) {
    newUser.org_UUID = await utils.getOrgUUID(cnaShortName)
  }

  // // If CNA shortname was provided in the body, it must match the one in the URL params
  // if (newUser.cna_short_name !== cnaShortName) {
  //   return res.status(400).json({ message: cnaShortName + ' URL parameter does not match ' + newUser.cna_short_name + ' in the JSON body.' })
  // }

  // Check the cna exists
  Org.findOne()
    .byShortName(cnaShortName)
    .exec((err, result) => {
      if (err) {
        logger.error(err.stack)
        return res.status(500).send(CONSTANTS.SERVER_RESPONSES.Internal_Server_Error)
      }

      if (!result) {
        logger.info('The user could not be created because ' + cnaShortName + ' CNA does not exist.')
        return res.status(400).json({ message: 'The user could not be created because ' + cnaShortName + ' CNA does not exist.' })
      }

      newUser.active = true
      const key = uuidAPIKey.create()
      newUser.secret = key.uuid

      if (newUser.UUID === undefined || newUser.UUID === null) {
        newUser.UUID = uuid.v4()
      }

      // Find user in MongoDB
      User.findOne()
        .byUserNameAndOrgUUID(newUser.username, newUser.org_UUID)
        .exec((err, result) => {
          if (err) {
            logger.warn('An error ocurred: ' + newUser.username + ' was not found in the database.')
            logger.error(err.stack)
            return res.status(500).send(CONSTANTS.SERVER_RESPONSES.Internal_Server_Error)
          }

          if (result) {
            logger.info(newUser.username + ' was not created because it already exists.')
            return res.status(400).json({ message: newUser.username + ' already exists.' })
          }

          // Create user in MongoDB if it doesn't exist
          User.findOneAndUpdate()
            .byUserNameAndOrgUUID(newUser.username, newUser.org_UUID)
            .updateOne(newUser)
            .setOptions({ upsert: true })
            .exec((err) => {
              if (err) {
                logger.error(err.stack)
                return res.status(500).send(CONSTANTS.SERVER_RESPONSES.Internal_Server_Error)
              }

              newUser.secret = key.apiKey
              const responseMessage = {
                message: newUser.username + ' was successfully created.',
                created: newUser
              }

              logger.info(JSON.stringify(responseMessage))
              return res.status(200).json(responseMessage)
            })
        })
    })
}

// Updates a user only if the user exist for the specified username. If no user exists, it does not create the user.
async function updateUser (req, res) {
  const cnaShortName = req.header(CONSTANTS.AUTH_HEADERS.ORG)
  const username = req.params.username
  const shortName = req.params.shortname
  const newUser = new User()
  let returned = false
  let nameChanged = false
  let newUsername
  let newCnaShortname
  let active
  const name = {
    first: null,
    ast: null,
    middle: null,
    surname: null,
    suffix: null
  }

  const isSecretariat = await utils.isSecretariat(cnaShortName)
  if (!isSecretariat) {
    logger.info('User ' + username + ' could not be updated because the requestor is not the the Secretariat.')
    return res.status(403).json({ message: 'A user cannot be updated by other than the Secretariat.' })
  }

  const orgUUID = await utils.getOrgUUID(shortName)
  const user = await User.findOne().byUserNameAndbyUUID(username, orgUUID)

  if (!user) {
    returned = true
    logger.info('The user could not be updated because ' + username + ' does not exist for ' + shortName + ' CNA')
    return res.status(404).json({ message: username + ' could not be found.' })
  }

  Object.keys(req.query).forEach(key => {
    if (!returned) {
      if (key === 'new_username') {
        newUsername = req.query.new_username.replace(/["']/g, '')
        newUser.username = newUsername
      } else if (key === 'new_cna_shortname') {
        newCnaShortname = req.query.new_cna_shortname.replace(/["']/g, '')
        newUser.cna_short_name = newCnaShortname
      } else if (key === 'active') {
        active = req.query.active.replace(/["']/g, '').toLowerCase()

        if (active !== 'true' && active !== 'false') {
          returned = true
          return res.status(400).json({ message: 'Bad query parameter.' })
        }

        newUser.active = active
      } else if (key === 'name.first') {
        name.first = req.query['name.first'].replace(/["']/g, '')
        user.name.first = name.first
        nameChanged = true
      } else if (key === 'name.last') {
        name.last = req.query['name.last'].replace(/["']/g, '')
        user.name.last = name.last
        nameChanged = true
      } else if (key === 'name.middle') {
        name.middle = req.query['name.middle'].replace(/["']/g, '')
        user.name.middle = name.middle
        nameChanged = true
      } else if (key === 'name.suffix') {
        name.suffix = req.query['name.suffix'].replace(/["']/g, '')
        user.name.suffix = name.suffix
        nameChanged = true
      } else if (key === 'name.surname') {
        name.surname = req.query['name.surname'].replace(/["']/g, '')
        user.name.surname = name.surname
        nameChanged = true
      } else {
        returned = true
        return res.status(400).json({ message: 'Invalid query parameter \'' + key + '\'' })
      }
    }
  })

  if (nameChanged) {
    newUser.name = user.name
  }

  if (!returned) {
    User.findOneAndUpdate()
      .byUserNameAndOrgUUID(username, orgUUID)
      .updateOne(newUser)
      .exec((err, result) => {
        if (err) {
          logger.error(err.stack)
          return res.status(500).send(CONSTANTS.SERVER_RESPONSES.Internal_Server_Error)
        }

        if (result.n === 0) {
          logger.info('The user could not be updated because ' + username + ' does not exist for ' + shortName + ' CNA')
          return res.status(404).json({ message: username + ' could not be found.' })
        }

        const responseMessage = {
          message: username + ' was successfully updated.',
          updated: newUser
        }

        logger.info(JSON.stringify(responseMessage))
        return res.status(200).json(responseMessage)
      })
  }
}

// Resets the user secret
async function resetSecret (req, res) {
  const cna = req.header(CONSTANTS.AUTH_HEADERS.ORG)
  const username = req.params.username
  const cnaShortName = req.params.shortname
  const newUser = new User()

  const isSecretariat = await utils.isSecretariat(cna)
  if (!isSecretariat) {
    logger.info('The API secret of ' + username + ' could not be updated because the user\'s secret cannot be updated by other than the Secretariat.')
    return res.status(403).json({ message: 'The user\'s secret cannot be updated by other than the Secretariat.' })
  }

  const keyUUIDPair = uuidAPIKey.create()
  const key = keyUUIDPair.apiKey // send to user
  newUser.secret = keyUUIDPair.uuid // store in db
  newUser.username = username
  const orgUUID = await utils.getOrgUUID(cnaShortName) // userUUID may be null if user does  not exist

  if (!orgUUID) {
    logger.info(cnaShortName + ' CNA does not exist.')
    return res.status(404).json({ message: cnaShortName + ' CNA does not exist.' })
  }

  User.findOneAndUpdate()
    .byUserNameAndOrgUUID(newUser.username, orgUUID)
    .updateOne(newUser)
    .exec((err, result) => {
      if (err) {
        logger.error(err.stack)
        return res.status(500).send(CONSTANTS.SERVER_RESPONSES.Internal_Server_Error)
      }

      if (result.n === 0) {
        logger.info('The user could not be updated because ' + username + ' does not exist for ' + cnaShortName)
        return res.status(404).json({ message: username + ' could not be found.' })
      }

      logger.info(JSON.stringify('The API secret was successfully reset and sent to ' + username, newUser.secret))
      return res.status(200).json({ 'API-secret': key })
    })
}

module.exports = {
  CNA_ALL: getCnas,
  CNA_SINGLE: getCna,
  CNA_CREATE_SINGLE: createCna,
  CNA_UPDATE_SINGLE: updateCna,
  ORG_ID_QUOTA: getOrgIdQuota,
  USER_SINGLE: getUser,
  USER_CREATE_SINGLE: createUser,
  USER_UPDATE_SINGLE: updateUser,
  USER_RESET_SECRET: resetSecret
}
