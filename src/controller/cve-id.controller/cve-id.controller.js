require('dotenv').config()
const CveId = require('../../model/cve-id')
const Org = require('../../model/org')
const logger = require('../../middleware/logger')
const CONSTANTS = require('../../constants')
const util = require('../../utils/utils')

async function getCveId (req, res) {
  const id = req.params.id
  const cnaShortName = req.header('CVE-API-CNA')

  CveId.findOne()
    .byCveId(id)
    .exec(async (err, result) => {
      if (err) {
        logger.error(err.stack)
        return res.status(500).send('Internal Server Error')
      }

      if (!result) {
        return res.status(404).json({ message: id + ' not found' })
      }

      const isSecretariat = await util.isSecretariat(cnaShortName)
      if (cnaShortName !== result.owning_cna && !isSecretariat) {
        if (result.state === 'RESERVED') {
          const cveId = Object.assign({}, result)._doc
          delete cveId._id

          logger.info({ message: id + ' is RESERVED. A 404 status was sent to the requester.', cveId: result })
          return res.status(404).json({ message: id + ' not found' })
        }

        const cveId = {
          cve_id: result.cve_id,
          cve_year: result.cve_year,
          state: result.state,
          owning_cna: result.owning_cna
        }

        logger.info({ message: id + ' record was sent to the user.', cveId: cveId })
        return res.status(200).json(cveId)
      } else {
        const cveId = Object.assign({}, result)._doc
        delete cveId._id

        logger.info({ message: id + ' record was sent to the user.', cveId: cveId })
        return res.status(200).json(cveId)
      }
    })
}

async function getFilteredCveId (req, res) {
  let state
  let year
  const timestamps = {
    timeReserved: [],
    dateOperator: []
  }
  let returned = false

  Object.keys(req.query).forEach(k => {
    const key = k.toLowerCase()

    if (!returned) {
      if (key === 'state') {
        state = req.query.state.replace(/["']/g, '').toUpperCase()
      } else if (key === 'cve_id_year') {
        year = req.query.cve_id_year.replace(/["']/g, '')
      } else if (key === 'time_reserved.lt') {
        if (Array.isArray(req.query['time_reserved.lt'])) {
          returned = true
          return res.status(400).json({ message: 'Only one query parameter of \'' + key + '\' is allowed.' })
        }

        timestamps.dateOperator.push('lt')
        timestamps.timeReserved.push(req.query['time_reserved.lt'].replace(/["']/g, ''))
      } else if (key === 'time_reserved.gt') {
        if (Array.isArray(req.query['time_reserved.gt'])) {
          returned = true
          return res.status(400).json({ message: 'Only one query parameter of \'' + key + '\' is allowed.' })
        }

        timestamps.dateOperator.push('gt')
        timestamps.timeReserved.push(req.query['time_reserved.gt'].replace(/["']/g, ''))
      } else {
        returned = true
        return res.status(400).json({ message: 'Invalid query parameter \'' + key + '\'' })
      }
    }
  })

  // verify format of timestamps
  for (let i = 0; i < timestamps.timeReserved.length; i++) {
    let value = timestamps.timeReserved[i].match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/)

    if (!returned) {
      if (value) {
        timestamps.timeReserved[i] = new Date(`${value[0]}.000+00:00`)
      } else {
        value = timestamps.timeReserved[i].match(/^\d{4}-\d{2}-\d{2}$/)

        if (value) {
          timestamps.timeReserved[i] = new Date(`${value[0]}T00:00:00.000+00:00`)
        } else {
          returned = true
          return res.status(400).json({ message: 'Timestamp query parameter only supports formats "YYYY-MM-DDTHH:mm:ss" or "YYYY-MM-DD"' })
        }
      }
    }
  }

  const query = {
    owning_cna: req.header('CVE-API-CNA')
  }

  if (year) {
    query.cve_year = year
  }

  if (state) {
    query.state = state
  }

  if (timestamps.timeReserved.length > 0) {
    query['time.reserved'] = {}

    for (let i = 0; i < timestamps.timeReserved.length; i++) {
      if (timestamps.dateOperator[i] === 'lt') {
        query['time.reserved'].$lt = timestamps.timeReserved[i]
      } else {
        query['time.reserved'].$gt = timestamps.timeReserved[i]
      }
    }
  }

  if (!returned) {
    CveId.find(query)
      .exec((err, result) => {
        if (err) {
          logger.error(err.stack)
          return res.status(500).send('Internal Server Error')
        }

        if (!result || result.length === 0) {
          return res.status(404).json({ message: 'No CVE IDs were found for the specified query parameters.' })
        }

        result.forEach((obj) => {
          const cna = Object.assign({}, obj)._doc
          delete cna._id
        })

        logger.info({ message: 'The CVEs were sent to the user.' })
        return res.status(200).json(result)
      })
  }
}

async function modifyCveId (req, res) {
  const id = req.params.id
  const cnaShortName = req.header('CVE-API-CNA')
  let state = null
  let newCnaShortname = null

  const isSecretariat = await util.isSecretariat(cnaShortName)
  if (!isSecretariat) {
    logger.info({ message: id + ' cannot be updated by other than the secretariat.' })
    return res.status(403).json({ message: id + ' cannot be updated by other than the secretariat.' })
  }

  if (req.query.state) {
    state = req.query.state.toUpperCase()

    if (state === 'RESERVED') {
      return res.status(400).json({ message: 'Cannot change the state to RESERVED.' })
    } else if (state !== 'PUBLIC' && state !== 'REJECT') {
      return res.status(400).json({ message: 'Invalid CVE state.' })
    }
  }

  if (req.query.cna) {
    newCnaShortname = req.query.cna
  }

  CveId.findOne()
    .byCveId(id)
    .exec(async (err, result) => {
      if (err) {
        logger.error(err.stack)
        return res.status(500).send('Internal Server Error')
      }

      if (!result) {
        return res.status(404).json({ message: id + ' not found' })
      }

      const updatedCveId = Object.assign({}, result)._doc

      if (state) {
        updatedCveId.state = state
      }

      if (newCnaShortname) {
        const result = await Org.findOne().byShortName(newCnaShortname)

        if (!result) {
          logger.info(id + ' could not be reasigned to ' + newCnaShortname + ' in MongoDB because it does not exist.')
          return res.status(404).json({ message: newCnaShortname + ' CNA does not exist.' })
        }

        updatedCveId.owning_cna = newCnaShortname
      }

      delete updatedCveId._id
      delete updatedCveId.time

      CveId.findOneAndUpdate()
        .byCveId(id)
        .updateOne(updatedCveId)
        .exec(async err => {
          if (err) {
            logger.error(err.stack)
            return res.status(500).send('Internal Server Error')
          }

          const result = await CveId.findOne().byCveId(id)
          const cveId = Object.assign({}, result)._doc
          delete cveId._id

          const responseMessage = {
            message: id + ' was successfully updated.',
            updated: cveId
          }

          logger.info(JSON.stringify(responseMessage))
          return res.status(200).json(responseMessage)
        })
    })
}

async function reserveCveId (req, res) {
  const sequential = req.query.sequential
  const amount = req.query.amount
  if (amount === undefined) {
    return res.status(404).json(CONSTANTS.no_amount)
  }
  if (amount <= 0) {
    return res.status(404).json(CONSTANTS.invalid_amount)
  }
  const available = 5
  if (amount > available) {
    return res.status(404).json(CONSTANTS.over_id_quota)
  }
  res.header('CVE-API-REMAINING-QUOTA', available - amount)
  if (sequential) {
    return res.status(200).json(sequentialIds.slice(0, amount))
  }
  return res.status(200).json(nonsequentialIds.slice(0, amount))
}

const sequentialIds = [
  {
    cve_id: 'CVE-3000-0001',
    cve_year: 3000,
    owning_cna: 'orgshortname',
    state: 'RESERVED',
    requested_by: {
      cna: 'orgshortname',
      user: 'you'
    },
    time: {
      created: '3000-06-24T21:08:42.937+00:00',
      modified: '3000-06-24T21:12:46.576+00:00',
      reserved: '3000-06-24T21:12:46.576+00:00'
    }
  },
  {
    cve_id: 'CVE-3000-0002',
    cve_year: 3000,
    owning_cna: 'orgshortname',
    state: 'RESERVED',
    requested_by: {
      cna: 'orgshortname',
      user: 'you'
    },
    time: {
      created: '3000-06-24T21:08:42.937+00:00',
      modified: '3000-06-24T21:12:46.576+00:00',
      reserved: '3000-06-24T21:12:46.576+00:00'
    }
  },
  {
    cve_id: 'CVE-3000-0003',
    cve_year: 3000,
    owning_cna: 'orgshortname',
    state: 'RESERVED',
    requested_by: {
      cna: 'orgshortname',
      user: 'you'
    },
    time: {
      created: '3000-06-24T21:08:42.937+00:00',
      modified: '3000-06-24T21:12:46.576+00:00',
      reserved: '3000-06-24T21:12:46.576+00:00'
    }
  },
  {
    cve_id: 'CVE-3000-0004',
    cve_year: 3000,
    owning_cna: 'orgshortname',
    state: 'RESERVED',
    requested_by: {
      cna: 'orgshortname',
      user: 'you'
    },
    time: {
      created: '3000-06-24T21:08:42.937+00:00',
      modified: '3000-06-24T21:12:46.576+00:00',
      reserved: '3000-06-24T21:12:46.576+00:00'
    }
  },
  {
    cve_id: 'CVE-3000-0005',
    cve_year: 3000,
    owning_cna: 'orgshortname',
    state: 'RESERVED',
    requested_by: {
      cna: 'orgshortname',
      user: 'you'
    },
    time: {
      created: '3000-06-24T21:08:42.937+00:00',
      modified: '3000-06-24T21:12:46.576+00:00',
      reserved: '3000-06-24T21:12:46.576+00:00'
    }
  }
]

const nonsequentialIds = [
  {
    cve_id: 'CVE-3000-0500',
    cve_year: 3000,
    owning_cna: 'orgshortname',
    state: 'RESERVED',
    requested_by: {
      cna: 'orgshortname',
      user: 'you'
    },
    time: {
      created: '3000-06-24T21:08:42.937+00:00',
      modified: '3000-06-24T21:12:46.576+00:00',
      reserved: '3000-06-24T21:12:46.576+00:00'
    }
  },
  {
    cve_id: 'CVE-3000-0522',
    cve_year: 3000,
    owning_cna: 'orgshortname',
    state: 'RESERVED',
    requested_by: {
      cna: 'orgshortname',
      user: 'you'
    },
    time: {
      created: '3000-06-24T21:08:42.937+00:00',
      modified: '3000-06-24T21:12:46.576+00:00',
      reserved: '3000-06-24T21:12:46.576+00:00'
    }
  },
  {
    cve_id: 'CVE-3000-0558',
    cve_year: 3000,
    owning_cna: 'orgshortname',
    state: 'RESERVED',
    requested_by: {
      cna: 'orgshortname',
      user: 'you'
    },
    time: {
      created: '3000-06-24T21:08:42.937+00:00',
      modified: '3000-06-24T21:12:46.576+00:00',
      reserved: '3000-06-24T21:12:46.576+00:00'
    }
  },
  {
    cve_id: 'CVE-3000-0518',
    cve_year: 3000,
    owning_cna: 'orgshortname',
    state: 'RESERVED',
    requested_by: {
      cna: 'orgshortname',
      user: 'you'
    },
    time: {
      created: '3000-06-24T21:08:42.937+00:00',
      modified: '3000-06-24T21:12:46.576+00:00',
      reserved: '3000-06-24T21:12:46.576+00:00'
    }
  },
  {
    cve_id: 'CVE-3000-0591',
    cve_year: 3000,
    owning_cna: 'orgshortname',
    state: 'RESERVED',
    requested_by: {
      cna: 'orgshortname',
      user: 'you'
    },
    time: {
      created: '3000-06-24T21:08:42.937+00:00',
      modified: '3000-06-24T21:12:46.576+00:00',
      reserved: '3000-06-24T21:12:46.576+00:00'
    }
  }
]

module.exports = {
  CVEID_GET_SINGLE: getCveId,
  CVEID_RESERVE: reserveCveId,
  CVEID_GET_FILTER: getFilteredCveId,
  CVEID_STATE_REASIGN_SINGLE: modifyCveId
}
