require('dotenv').config()
const CveId = require('../../model/cve-id')
const CveIdRange = require('../../model/cve-id-range')
const Org = require('../../model/org')
const logger = require('../../middleware/logger')
const CONSTANTS = require('../../constants')
const util = require('../../utils/utils')

async function getCveId (req, res) {
  const id = req.params.id
  const cnaShortName = req.header(CONSTANTS.AUTH_HEADERS.ORG)

  CveId.findOne()
    .byCveId(id)
    .exec(async (err, result) => {
      if (err) {
        logger.error(err.stack)
        return res.status(500).json({ error: 'INTERNAL_SERVER_ERROR', message: 'Internal Server Error' })
      }

      if (!result || result.state === 'AVAILABLE') {
        return res.status(404).json({ error: 'NOT_FOUND', message: id + ' not found' })
      }

      const isSecretariat = await util.isSecretariat(cnaShortName)
      // the requester is not the owning org and the secretariat
      if (cnaShortName !== result.owning_cna && !isSecretariat) {
        if (result.state === 'RESERVED') {
          const cveId = Object.assign({}, result)._doc
          delete cveId._id

          logger.info({ message: id + ' is ' + result.state + '. A 404 status was sent to the requester.', cveId: result })
          return res.status(404).json({ error: 'NOT_FOUND', message: id + ' not found' })
        }

        const cveId = {
          cve_id: result.cve_id,
          cve_year: result.cve_year,
          state: result.state,
          owning_cna: result.owning_cna
        }

        logger.info({ message: id + ' record was sent to the user.', cveId: cveId })
        return res.status(200).json(cveId)
      } else {
        // the requester is the owning org or the secretariat
        const cveId = Object.assign({}, result)._doc
        delete cveId._id

        if (cveId.__v !== undefined) {
          delete cveId.__v
        }

        logger.info({ message: id + ' record was sent to the user.', cveId: cveId })
        return res.status(200).json(cveId)
      }
    })
}

async function getFilteredCveId (req, res) {
  let state
  let year
  const timestamps = {
    timeReserved: [],
    dateOperator: []
  }
  let returned = false
  const isSecretariat = await util.isSecretariat(req.header(CONSTANTS.AUTH_HEADERS.ORG))

  Object.keys(req.query).forEach(k => {
    const key = k.toLowerCase()

    if (!returned) {
      if (key === 'state') {
        state = req.query.state.replace(/["']/g, '').toUpperCase()
      } else if (key === 'cve_id_year') {
        year = req.query.cve_id_year.replace(/["']/g, '')
      } else if (key === 'time_reserved.lt') {
        if (Array.isArray(req.query['time_reserved.lt'])) {
          returned = true
          return res.status(400).json({ message: 'Only one query parameter of \'' + key + '\' is allowed.' })
        }

        timestamps.dateOperator.push('lt')
        timestamps.timeReserved.push(req.query['time_reserved.lt'].replace(/["']/g, ''))
      } else if (key === 'time_reserved.gt') {
        if (Array.isArray(req.query['time_reserved.gt'])) {
          returned = true
          return res.status(400).json({ message: 'Only one query parameter of \'' + key + '\' is allowed.' })
        }

        timestamps.dateOperator.push('gt')
        timestamps.timeReserved.push(req.query['time_reserved.gt'].replace(/["']/g, ''))
      } else {
        returned = true
        return res.status(400).json({ message: 'Invalid query parameter \'' + key + '\'' })
      }
    }
  })

  // verify format of timestamps
  for (let i = 0; i < timestamps.timeReserved.length; i++) {
    let value = timestamps.timeReserved[i].match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/)

    if (!returned) {
      if (value) {
        timestamps.timeReserved[i] = new Date(`${value[0]}.000+00:00`)
      } else {
        value = timestamps.timeReserved[i].match(/^\d{4}-\d{2}-\d{2}$/)

        if (value) {
          timestamps.timeReserved[i] = new Date(`${value[0]}T00:00:00.000+00:00`)
        } else {
          returned = true
          return res.status(400).json({ message: 'Timestamp query parameter only supports formats "YYYY-MM-DDTHH:mm:ss" or "YYYY-MM-DD"' })
        }
      }
    }
  }

  const query = {
    state: { $ne: 'AVAILABLE' }
  }

  if (!isSecretariat) {
    query.owning_cna = req.header(CONSTANTS.AUTH_HEADERS.ORG)
  }

  if (year) {
    query.cve_year = year
  }

  if (state) {
    if (state === 'AVAILABLE') {
      returned = true
      return res.status(404).json({ error: 'NOT_FOUND', message: 'No CVE IDs were found for the specified query parameters.' })
    }

    query.state = state
  }

  if (timestamps.timeReserved.length > 0) {
    query.reserved = {}

    for (let i = 0; i < timestamps.timeReserved.length; i++) {
      if (timestamps.dateOperator[i] === 'lt') {
        query.reserved.$lt = timestamps.timeReserved[i]
      } else {
        query.reserved.$gt = timestamps.timeReserved[i]
      }
    }
  }

  if (!returned) {
    CveId.find(query)
      .exec((err, result) => {
        if (err) {
          logger.error(err.stack)
          return res.status(500).json({ error: 'INTERNAL_SERVER_ERROR', message: 'Internal Server Error' })
        }

        if (!result || result.length === 0) {
          return res.status(404).json({ error: 'NOT_FOUND', message: 'No CVE IDs were found for the specified query parameters.' })
        }

        result.forEach((obj) => {
          const cna = Object.assign({}, obj)._doc
          delete cna._id

          if (cna.__v !== undefined) {
            delete cna.__v
          }
        })

        logger.info({ message: 'The CVEs were sent to the user.' })
        return res.status(200).json(result)
      })
  }
}

async function modifyCveId (req, res) {
  const id = req.params.id
  const cnaShortName = req.header(CONSTANTS.AUTH_HEADERS.ORG)
  let state = null
  let newCnaShortname = null

  const isSecretariat = await util.isSecretariat(cnaShortName)
  if (!isSecretariat) {
    logger.info({ message: id + ' cannot be updated by other than the secretariat.' })
    return res.status(403).json({ message: id + ' cannot be updated by other than the secretariat.' })
  }

  if (req.query.state) {
    state = req.query.state.toUpperCase()

    if (state === 'RESERVED') {
      return res.status(400).json({ message: 'Cannot change the state to RESERVED.' })
    } else if (state !== 'PUBLIC' && state !== 'REJECT') {
      return res.status(400).json({ message: 'Invalid CVE state.' })
    }
  }

  if (req.query.cna) {
    newCnaShortname = req.query.cna
  }

  CveId.findOne()
    .byCveId(id)
    .exec(async (err, result) => {
      if (err) {
        logger.error(err.stack)
        return res.status(500).send('Internal Server Error')
      }

      if (!result) {
        return res.status(404).json({ message: id + ' not found' })
      }

      const updatedCveId = Object.assign({}, result)._doc

      if (state) {
        updatedCveId.state = state
      }

      if (newCnaShortname) {
        const result = await Org.findOne().byShortName(newCnaShortname)

        if (!result) {
          logger.info(id + ' could not be reasigned to ' + newCnaShortname + ' in MongoDB because it does not exist.')
          return res.status(404).json({ message: newCnaShortname + ' CNA does not exist.' })
        }

        updatedCveId.owning_cna = newCnaShortname
      }

      delete updatedCveId._id
      delete updatedCveId.time

      CveId.findOneAndUpdate()
        .byCveId(id)
        .updateOne(updatedCveId)
        .exec(async err => {
          if (err) {
            logger.error(err.stack)
            return res.status(500).send('Internal Server Error')
          }

          const result = await CveId.findOne().byCveId(id)
          const cveId = Object.assign({}, result)._doc
          delete cveId._id

          if (cveId.__v !== undefined) {
            delete cveId.__v
          }

          const responseMessage = {
            message: id + ' was successfully updated.',
            updated: cveId
          }

          logger.info(JSON.stringify(responseMessage))
          return res.status(200).json(responseMessage)
        })
    })
}

async function reserveCveId (req, res) {
  const requester = req.header(CONSTANTS.AUTH_HEADERS.USER)
  const cnaShortName = req.header(CONSTANTS.AUTH_HEADERS.ORG)
  let returned = false
  let batchType
  let amount
  let shortName
  let year
  let cveId

  Object.keys(req.query).forEach(k => {
    const key = k.toLowerCase()

    if (key === 'amount') {
      amount = req.query.amount.replace(/["']/g, '')
    } else if (key === 'batch_type') {
      batchType = req.query.batch_type.replace(/["']/g, '').toLowerCase()
    } else if (key === 'short_name') {
      shortName = req.query.short_name.replace(/["']/g, '').toLowerCase()
    } else if (key === 'cve_year') {
      year = req.query.cve_year.replace(/["']/g, '')
    } else {
      if (!returned) {
        returned = true
        return res.status(400).json({ message: 'Invalid query parameter \'' + key + '\'' })
      }
    }
  })

  const isSecretariat = await util.isSecretariat(cnaShortName)
  if (cnaShortName !== shortName && !isSecretariat && !returned) {
    returned = true
    return res.status(403).json(CONSTANTS.CNA_CANNOT_RESERVE_FOR_OTHER)
  }

  if (shortName === undefined && !returned) {
    returned = true
    return res.status(400).json(CONSTANTS.NO_CNA_SHORTNAME)
  }

  if (year === undefined && !returned) {
    returned = true
    return res.status(400).json(CONSTANTS.NO_YEAR)
  }

  if (amount === undefined && !returned) {
    returned = true
    return res.status(400).json(CONSTANTS.NO_AMOUNT)
  }

  if (amount <= 0 && !returned) {
    returned = true
    return res.status(400).json(CONSTANTS.INVALID_AMOUNT)
  }

  if (amount > 1 && batchType === undefined && !returned) {
    returned = true
    return res.status(400).json(CONSTANTS.NO_BATCH_TYPE)
  }

  let result = await Org.findOne().byShortName(shortName)
  if (!result && !returned) {
    returned = true
    logger.info(shortName + ' CNA does not exist.')
    return res.status(403).json(CONSTANTS.CNA_DNE)
  }

  let payload

  if (!returned) {
    payload = {
      id_quota: result.policies.id_quota
    }

    result = await CveId.countDocuments({ owning_cna: shortName, state: 'RESERVED' })
    payload.total_reserved = result
    payload.available = (payload.id_quota - payload.total_reserved)
  }

  if (!returned && amount > payload.available) {
    returned = true
    CONSTANTS.OVER_ID_QUOTA.details = payload
    return res.status(403).json(CONSTANTS.OVER_ID_QUOTA)
  }

  if (!returned) {
    result = await Org.findOneAndUpdate({ short_name: shortName, inUse: false }, { $set: { inUse: true } }, { new: true }) // set lock for org

    if (!result) {
      returned = true
      return res.status(403).json(CONSTANTS.RESERVATION_IN_PROGRESS)
    }
  }

  if (!returned) {
    // priority
    if (batchType === undefined) {
      await priorityReservation(year, amount, cveId, shortName, cnaShortName, requester, payload.available, res)
    } else if (batchType === 'sequential') {
      await sequentialReservation(year, amount, cveId, shortName, cnaShortName, requester, payload.available, false, res)
    } else if (batchType === 'non-sequential' || batchType === 'nonsequential') {
      await nonSequentialReservation(year, amount, cveId, shortName, cnaShortName, requester, payload.available, res)
    } else {
      return res.status(400).json(CONSTANTS.INVALID_BATCH_TYPE)
    }

    await Org.findOneAndUpdate({ short_name: shortName, inUse: true }, { $set: { inUse: false } }, { new: true }) // release lock for org
  }
}

async function priorityReservation (year, amount, cveId, shortName, cnaShortName, requester, availableIds, res) {
  let result = await CveIdRange.findOne({ cve_year: year })
  let returned = false
  let isFull = false

  // Cve Id Range for 'year' does not exists
  if (!result) {
    returned = true
    logger.info('CVE IDs for year ' + year + ' cannot be reserved at this time.')
    res.header(CONSTANTS.QUOTA_HEADER, availableIds)
    return res.status(403).json(CONSTANTS.CANNOT_RESERVE_FOR_YEAR)
  }

  if (!returned) {
    const endRange = parseInt(result.ranges.priority.end)
    result = await CveIdRange.findOneAndUpdate({ $and: [{ cve_year: year }, { 'ranges.priority.top_id': { $lt: endRange } }] }, { $inc: { 'ranges.priority.top_id': amount } }, { new: true })

    // priority id block is full, reserve id in sequential block
    if (!result) {
      isFull = true
      logger.info('Priority id block is full for year ' + year + ', reserving id in sequential block.')
      await sequentialReservation(year, amount, cveId, shortName, cnaShortName, requester, availableIds, true, res)
    }
  }

  if (!isFull && !returned) {
    const id = generateSequentialIds(year, result.ranges.priority.top_id, amount)
    const cveIdDocuments = []

    cveId = new CveId()
    cveId.cve_id = id[0]
    cveId.cve_year = year
    cveId.state = 'RESERVED'
    cveId.owning_cna = shortName // the org who gets assigned the reserved CVE IDs
    cveId.reserved = Date.now()
    cveId.requested_by = {
      cna: cnaShortName, // the org who requested the CVE IDs
      user: requester
    }

    cveIdDocuments.push(cveId)

    // Create a CveId document (reserve the CVE ID)
    await CveId.findOneAndUpdate().byCveId(id).updateOne(cveId).setOptions({ upsert: true })

    logger.info({ message: 'A priority CVE ID was reserved for \'' + shortName + '\' org on behalf of \'' + cnaShortName + '\' org.', cve_id: id })
    res.header(CONSTANTS.QUOTA_HEADER, availableIds - amount)
    return res.status(200).json({ cve_ids: cveIdDocuments })
  }
}

async function sequentialReservation (year, amount, cveId, shortName, cnaShortName, requester, availableIds, isPriority, res) {
  let result = await CveIdRange.findOne({ cve_year: year })
  let topId
  let returned = false
  let isFull = false

  // Cve Id Range for 'year' does not exists
  if (!result) {
    returned = true
    logger.info('CVE IDs for year ' + year + ' cannot be reserved at this time.')
    res.header(CONSTANTS.QUOTA_HEADER, availableIds)
    return res.status(403).json(CONSTANTS.CANNOT_RESERVE_FOR_YEAR)
  }

  if (!returned) {
    topId = parseInt(result.ranges.general.top_id)
    amount = parseInt(amount)
    result = await CveIdRange.findOneAndUpdate({ $and: [{ cve_year: year }, { 'ranges.general.end': { $gt: (topId + amount - 1) } }] }, { $inc: { 'ranges.general.top_id': amount } }, { new: true })

    // The cve id block is full for sequential CVE IDs
    if (!result) {
      isFull = true
      returned = true

      if (isPriority) {
        logger.error('The cve id priority and sequential blocks are full for year ' + year + '. No more priority or sequential ids can be reserved at this time.')
      } else {
        logger.error('The cve id sequential block is full for year ' + year + '. No more sequential ids can be reserved at this time.')
      }

      res.header(CONSTANTS.QUOTA_HEADER, availableIds)
      return res.status(403).json(CONSTANTS.YEAR_RANGE_FULL)
    }
  }

  if (!isFull && !returned) {
    const ids = generateSequentialIds(year, result.ranges.general.top_id, amount)
    let cveIdDocuments = []

    ids.forEach(id => {
      cveId = new CveId()
      cveId.cve_id = id
      cveId.cve_year = year
      cveId.state = 'RESERVED'
      cveId.owning_cna = shortName // the org who gets assigned the reserved CVE IDs
      cveId.reserved = Date.now()
      cveId.requested_by = {
        cna: cnaShortName, // the org who requested the CVE IDs
        user: requester
      }

      cveIdDocuments.push(cveId)
    })

    await CveId.insertMany(cveIdDocuments) // Create multiple CveId documents (reserve the CVE IDs)
    cveIdDocuments = await cleanOutputSequential(cveIdDocuments) // Clean output after inserts

    if (isPriority) {
      logger.info({ message: 'The cve id priority block is full for year ' + year + '. A sequential CVE ID was reserved for \'' + shortName + '\' org on behalf of \'' + cnaShortName + '\' org.', cve_ids: ids })
    } else {
      logger.info({ message: 'Sequential CVE IDs were reserved for \'' + shortName + '\' org on behalf of \'' + cnaShortName + '\' org.', cve_ids: ids })
    }

    res.header(CONSTANTS.QUOTA_HEADER, availableIds - amount)
    return res.status(200).json({ cve_ids: cveIdDocuments })
  }
}

async function nonSequentialReservation (year, amount, cveId, shortName, cnaShortName, requester, availableIds, res) {
  let isFull = false
  let returned = false
  let available
  amount = parseInt(amount)
  let availableLimit = Math.max(3 * amount, CONSTANTS.DEFAULT_AVAILABLE_POOL)
  let result = await CveIdRange.findOne({ cve_year: year })

  // Cve Id Range for 'year' does not exists
  if (!result) {
    returned = true
    logger.info('CVE IDs for year ' + year + ' cannot be reserved at this time.')
    res.header(CONSTANTS.QUOTA_HEADER, availableIds)
    return res.status(403).json(CONSTANTS.CANNOT_RESERVE_FOR_YEAR)
  }

  if (!returned) {
    available = await CveId.find({ cve_year: year, state: 'AVAILABLE' }).limit(availableLimit) // get available ids

    // Case 1: Not enough IDs in the 'AVAILABLE' pool
    if (available.length < availableLimit) {
      result = await incrementNonSequentialPool(availableLimit, result.ranges.general.end, result.ranges.general.top_id, amount, available.length, year)
      isFull = result.isFull
      returned = result.returned

      if (isFull || returned) {
        logger.error('The cve id non-sequential block is full for year ' + year + '. No more sequential ids can be reserved at this time.')
        res.header(CONSTANTS.QUOTA_HEADER, availableIds)
        return res.status(403).json(CONSTANTS.YEAR_RANGE_FULL)
      }

      await allocateAvailableCveIds(result.ids, cveId, year) // Pool was incremented. Create 'AVAILABLE' cve ids.
      available = await CveId.find({ cve_year: year, state: 'AVAILABLE' }).limit(availableLimit) // get available ids
    }
  }

  // Case 2: Enough IDs in the 'AVAILABLE' pool
  let index
  let counter = 0
  const cveIdDocuments = []

  while ((counter < amount) && (!isFull && !returned)) {
    index = getRandomInt(0, available.length) // get random index in the available array
    result = await reserveNonSequentialCveId(index, available, cveId, year, shortName, cnaShortName, requester)

    if (result.isReserved) {
      cveIdDocuments.push(result.cveId) // add reserved cve id to the array of reserved cve ids
      available.splice(index, 1) // remove reserved cve id from the 'AVAILABLE' pool
      counter++
    } else {
      available = await CveId.find({ cve_year: year, state: 'AVAILABLE' }).limit(availableLimit) // get available ids
      availableLimit = Math.max(3 * (amount - counter), CONSTANTS.DEFAULT_AVAILABLE_POOL) // recalculate the available limit since some ids might have been reserved

      // Case 1: Not enough IDs in the 'AVAILABLE' pool
      if (available.length < availableLimit) {
        result = await CveIdRange.findOne({ cve_year: year })
        result = await incrementNonSequentialPool(availableLimit, result.ranges.general.end, result.ranges.general.top_id, amount - counter, available.length, year)
        isFull = result.isFull
        returned = result.returned

        if (isFull || returned) {
          logger.info({ message: 'Only ' + counter + ' cve ids were reserved because there are not enough ids in the CVE ID non-sequential block.' })
          const partialError = CONSTANTS.RESERVED_PARTIAL_AMOUNT
          partialError.details = { amount_reserved: counter }
          partialError.cve_ids = cveIdDocuments
          res.header(CONSTANTS.QUOTA_HEADER, availableIds - counter)
          return res.status(206).json(partialError)
        }

        await allocateAvailableCveIds(result.ids, cveId, year) // Pool was incremented. Create 'AVAILABLE' cve ids.
        available = await CveId.find({ cve_year: year, state: 'AVAILABLE' }).limit(availableLimit) // get available ids
      }
    }
  }

  if (!isFull && !returned) {
    logger.info({ message: 'Non-sequential CVE IDs were reserved for \'' + shortName + '\' org on behalf of \'' + cnaShortName + '\' org.', cve_ids: cveIdDocuments })
    res.header(CONSTANTS.QUOTA_HEADER, availableIds - amount)
    return res.status(200).json({ cve_ids: cveIdDocuments })
  }
}

async function incrementNonSequentialPool (availableLimit, end, top, amount, available, year) {
  let increment = availableLimit - available + amount // the amount is the increment amount
  const endRange = parseInt(end)
  const topId = parseInt(top)

  // Cap increment to end of general CVE ID block
  if (endRange < (topId + increment)) {
    increment = endRange - topId
  }

  const result = {
    isFull: false,
    returned: false,
    ids: null
  }

  if (increment > 0) {
    let r = await CveIdRange.findOneAndUpdate({ $and: [{ cve_year: year }, { 'ranges.general.end': { $gte: increment } }] }, { $inc: { 'ranges.general.top_id': increment } }, { new: true })

    // Cap increment because it went over end of general block
    if (r.ranges.general.top_id > endRange) {
      increment = increment - (r.ranges.general.top_id - endRange) // adjusting real increment
      r = await CveIdRange.findOneAndUpdate({ cve_year: year }, { $set: { 'ranges.general.top_id': endRange } }, { new: true }) // Cap top_id to end of the block
    }

    if (increment > 0) {
      result.ids = generateSequentialIds(year, r.ranges.general.top_id, increment)
    } else if (available < amount) { // You hit the end of the boundary
      result.isFull = true
      result.returned = true
    }
  } else if (available < amount) { // You hit the end of the boundary
    result.isFull = true
    result.returned = true
  }

  return result
}

async function allocateAvailableCveIds (ids, cveId, year) {
  if (ids) {
    const cveIdDocuments = []

    ids.forEach(id => {
      cveId = new CveId()
      cveId.cve_id = id
      cveId.cve_year = year
      cveId.state = 'AVAILABLE'
      cveId.owning_cna = 'N/A' // the org who gets assigned the reserved CVE IDs
      cveId.reserved = Date.now()
      cveId.requested_by = {
        cna: 'N/A', // the org who requested the CVE IDs
        user: 'N/A'
      }

      cveIdDocuments.push(cveId)
    })

    await CveId.insertMany(cveIdDocuments) // Save the 'AVAILABLE' cve ids
  }
}

async function reserveNonSequentialCveId (index, available, cveId, year, shortName, cnaShortName, requester) {
  // Update available Cve Id
  cveId = new CveId()
  cveId.cve_id = available[index].cve_id
  cveId.cve_year = year
  cveId.state = 'RESERVED'
  cveId.owning_cna = shortName // the org who gets assigned the reserved CVE IDs
  cveId.reserved = Date.now()
  cveId.requested_by = {
    cna: cnaShortName, // the org who requested the CVE IDs
    user: requester
  }

  const result = {
    cveId: cveId,
    isReserved: await CveId.findOneAndUpdate({ cve_id: cveId.cve_id, state: 'AVAILABLE' }, cveId, { new: true })
  }

  return result
}

async function cleanOutputSequential (cveIdDocuments) {
  cveIdDocuments.forEach((obj) => {
    const cveId = Object.assign({}, obj)._doc
    delete cveId.time

    if (cveId.__v !== undefined) {
      delete cveId.__v
    }
  })

  return cveIdDocuments
}

function generateSequentialIds (year, topId, increment) {
  const start = topId - increment + 1 // before the pool 'AVAILABLE' pool increment
  const end = topId // after the 'AVAILABLE' pool increment
  const ids = []

  for (let i = start; i < end + 1; i++) {
    ids.push('CVE-' + year + '-' + String(i).padStart(4, '0'))
  }

  return ids
}

function getRandomInt (min, max) {
  min = Math.ceil(min)
  max = Math.floor(max)

  return Math.floor(Math.random() * (max - min) + min) // The maximum is exclusive and the minimum is inclusive
}

async function createCveIdRange (req, res) {
  const year = req.params.year
  const cnaShortName = req.header(CONSTANTS.AUTH_HEADERS.ORG)

  const isSecretariat = await util.isSecretariat(cnaShortName)
  if (!isSecretariat) {
    logger.info({ message: 'The Cve Id Range cannot be created by other than the secretariat.' })
    return res.status(403).json(CONSTANTS.SECRETARIAT_ONLY)
  }

  const result = await CveIdRange.findOne({ cve_year: year })

  if (result) {
    logger.info('CVE Id Range document for year ' + year + ' already exists.')
    return res.status(400).json({ message: 'CVE Id Range document for year ' + year + ' was not created because it already exists.' })
  }

  const defaultDoc = CONSTANTS.DEFAULT_CVE_ID_RANGE
  defaultDoc.cve_year = year
  await CveIdRange.findOneAndUpdate({ cve_year: year }, defaultDoc, { upsert: true })

  logger.info('CVE Id Range document for year ' + year + ' was created.')
  return res.status(200).send()
}

module.exports = {
  CVEID_GET_SINGLE: getCveId,
  CVEID_RESERVE: reserveCveId,
  CVEID_GET_FILTER: getFilteredCveId,
  CVEID_STATE_REASIGN_SINGLE: modifyCveId,
  CVEID_RANGE_CREATE: createCveIdRange
}
