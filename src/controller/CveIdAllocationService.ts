import { dbOperations } from "../database/db-operations";
import { ERROR_MESSAGE } from "../constants";
import { CVE_Object } from "./utils/CVE_Object_Class";
export class CveIdAllocationController {
  /**
  * @api {post} /get-cvs-info Get CVE Info
  * @apiName Get CVE Info
  * @apiGroup CVE
  * @apiVersion  0.0.0
  * @apiDescription 
  * Use this method to get status and/or the related metadata about the CVEs that have been allocated to the requestor. 
  * Information can be requested for a single CVE ID, all CVE IDs, a subset of CVE IDs as specified by a filter.
  * Note: Caller must be authenticated, authorized CVE AIS user.
  * 
  * @apiHeader Signature RSA Signature.
  * @apiParamExample {json} Request-Example With ID's:
 content-type: application/json
 {
   "Payload": {
     "ids": ["CVE-2019-10d2b65c-c68e-4804-b444-45e6b172e708"]
   }, 
   "userUUID": "246aef24-c31e-485e-ab03-133fa0cc3442"
 }
 
 * @apiParamExample {json} Request-Example with Status Filter:
 content-type: application/json
 {
   "Payload": {
     "filter": 'Free|Rejected|Disputed|Populated|Published|Public|Reserved|Obsolete'
   }, 
   "userUUID": "246aef24-c31e-485e-ab03-133fa0cc3442"
 }
 
  *@apiSuccessExample Success-Response For ID's Search:
  *HTTP/1.1 200 OK
 [
     {
         "cve_id": "CVE-2019-10d2b65c-c68e-4804-b444-45e6b172e708",
         "status": "status",
         "Requestor": {
             "user_id": "246aef24-c31e-485e-ab03-133fa0cc3442",
             "user_name": "user name"
         },
         "Organization": {
             "org_id": "3bb4c1e8-84fd-466a-bc32-b39a5ba5df4a",
             "org_name": "Org Name"
         },
         "History": "TBD"
     }
 ]
  *@apiSuccessExample Success-Response For Filters Search:
  *HTTP/1.1 200 OK
 [
     {
         "cve_id": "CVE-2019-10d2b65c-c68e-4804-b444-45e6b172e708",
         "status": "Free|Rejected|Disputed|Populated|Published|Public|Reserved|Obsolete",
         "Requestor": {
             "user_id": "246aef24-c31e-485e-ab03-133fa0cc3442",
             "user_name": "user name"
         },
         "Organization": {
             "org_id": "3bb4c1e8-84fd-466a-bc32-b39a5ba5df4a",
             "org_name": "Org Name"
         },
         "History": "TBD"
     }
 ]
  * @apiErrorExample Error-Response 1:
  *HTTP/1.1 400 Bad Request
 {
   "error": "error message"
 }
  * @apiErrorExample Error-Response 2:
  *HTTP/1.1 500 Bad Request
 {
   "error": "Failed to validate key."
 }
  */

  async getCveInfo(request, response, next) {
    const { payload } = request.body;
    const filterRegex = /^(Free|Rejected|Disputed|Populated|Public|Published|Reserved|Obsolete)$/g; //Filter for status only
    var filterFlag = false;
    var result = [];
    try {
      if (payload.filter) {
        if (!new RegExp(filterRegex).test(payload.filter)) {
          response.status(403).json({ error: ERROR_MESSAGE[403] });
          return;
        } else {
          filterFlag = true;
        }
      }
      if (payload.ids) {
        var holdResponse = [];
        for (var i = 0; i < payload.ids.length; i++) {
          try {
            let cves = await dbOperations.getCveId(
              payload.ids[i],
              request.CNAID
            );
            holdResponse.push(cves);
          } catch (err) {
            console.log(err);
            response.status(403).json({ error: ERROR_MESSAGE[403] });
          }
        }
        for (var i = 0; i < holdResponse.length; i++) {
          var cveIdObject = {
            cve_id: "",
            status: "",
            Requestor: { user_id: "", user_name: "" },
            Organization: { org_id: "", org_name: "" },
            History: "TBD"
          };
          cveIdObject.cve_id = holdResponse[i][0].cveID;
          cveIdObject.status = holdResponse[i][0].cveStatus;
          cveIdObject.Requestor.user_id = holdResponse[i][0].cveRequesterUserID;
          cveIdObject.Requestor.user_name =
            holdResponse[i][0].cveRequesterUserName;
          cveIdObject.Organization.org_id =
            holdResponse[i][0].cveOrganizationUUID;
          cveIdObject.Organization.org_name =
            holdResponse[i][0].cveOragnizationName;
          result.push(cveIdObject);
        }
        response.status(200).json(result);
      } else {
        if (filterFlag) {
          dbOperations
            .getAllOrgCvesFilter(request.CNAID, payload.filter)
            .then(
              response => {
                for (var i = 0; i < response.length; i++) {
                  var cveIdObject = {
                    cve_id: "",
                    status: "",
                    Requestor: { user_id: "", user_name: "" },
                    Organization: { org_id: "", org_name: "" },
                    History: "TBD"
                  };
                  cveIdObject.cve_id = response[i].cveID;
                  cveIdObject.status = response[i].cveStatus;
                  cveIdObject.Requestor.user_name =
                    response[i].cveRequesterUserName;
                  cveIdObject.Requestor.user_id =
                    response[i].cveRequesterUserID;
                  cveIdObject.Organization.org_name =
                    response[i].cveOragnizationName;
                  cveIdObject.Organization.org_id =
                    response[i].cveOrganizationUUID;
                  result.push(cveIdObject);
                }
                response.status(200).json(result);
              },
              rejected => {
                response.status(400).json(ERROR_MESSAGE[400]);
              }
            )
            .catch(err => {
              console.log(err);
              response.status(400).json({ error: ERROR_MESSAGE[400] });
            });
        } else {
          dbOperations
            .getAllOrgCvesNoFilter(request.CNAID)
            .then(
              response => {
                for (var i = 0; i < response.length; i++) {
                  var cveIdObject = {
                    cve_id: "",
                    status: "",
                    Requestor: { user_id: "", user_name: "" },
                    Organization: { org_id: "", org_name: "" },
                    History: "TBD"
                  };
                  cveIdObject.cve_id = response[i].cveID;
                  cveIdObject.status = response[i].cveStatus;
                  cveIdObject.Requestor.user_name =
                    response[i].cveRequesterUserName;
                  cveIdObject.Requestor.user_id =
                    response[i].cveRequesterUserID;
                  cveIdObject.Organization.org_name =
                    response[i].cveOragnizationName;
                  cveIdObject.Organization.org_id =
                    response[i].cveOrganizationUUID;
                  result.push(cveIdObject);
                }
                response.status(200).json(result);
              },
              rejected => {
                response.status(400).json(ERROR_MESSAGE[400]);
              }
            )
            .catch(err => {
              console.log(err);
              response.status(400).json({ error: ERROR_MESSAGE[400] });
            });
        }
      }
    } catch (err) {
      console.log(err);
      response.status(400).json({ error: ERROR_MESSAGE[400] });
    }
  }

  /**
* @api {post} /get-cve-id Request CVE ID
* @apiName Request CVE ID
* @apiGroup CVE
* @apiVersion  0.0.0
* @apiDescription 
* This method will allocate and assign one or more non-sequential CVE IDs to the requestor. The backend database will be 
* updated to reflect the allocated CVE IDs, status (i.e. "Reserved"), and requestors identity & associated CNA (as provided by 
* the CVE Authentication and Authorization Services).

* Note: the number of CVE IDs are limited based on the specified quota.

* Note: the params are optional. If no params are given, default CVE object will be handed out. 
* @apiHeader Signature RSA Signature.
* @apiParamExample {json} Request-Example With ID's:
content-type: application/json
{
 "payload":
 {
   "year" : "2009", 
   "count" : 1, 
   "status": "Free"
 }, 
 "userUUID": "246aef24-c31e-485e-ab03-133fa0cc3442"
}


*@apiSuccessExample Success-Response For ID's Search:
*HTTP/1.1 200 OK
[
  {
       "cve_id": "CVE-2009-74007fad-fe80-4770-a5b3-7e47a5093122",
       "status": "Free",
       "Requestor": {
           "user_id": "246aef24-c31e-485e-ab03-133fa0cc3442",
           "user_name": "User Name"
       },
       "Organization": {
           "org_id": "3bb4c1e8-84fd-466a-bc32-b39a5ba5df4a",
           "org_name": "Org Name "
       },
       "History": "TBD"
   }
]

* @apiErrorExample Error-Response 1:
*HTTP/1.1 400 Bad Request
{
 "error": "Invalid Year"
}
* @apiErrorExample Error-Response 2:
*HTTP/1.1 500 Bad Request
{
 "error": "Invalid Status"
}
*/
  async getCveId(request, response, next) {
    const { payload } = request.body;
    if (!payload.year) {
      payload.year = undefined;
    }
    if (!payload.status) {
      payload.status = undefined;
    }
    if (!payload.count) {
      payload.count = 1;
    }
    try {
      var result = [];
      for (var i = 0; i < payload.count; i++) {
        try {
          var newCveID = new CVE_Object(request, payload.year, payload.status);
          result.push(newCveID.createCVEID());
        } catch (e) {
          console.log(e);
          response.status(403).json({ error: ERROR_MESSAGE[403] });
        }
        try {
          await dbOperations.saveCVE(newCveID.createCVEID());
        } catch (e) {
          console.log(e);
          response.status(400).json({ error: ERROR_MESSAGE[400] });
        }
      }
      response.status(200).json(result);
    } catch (e) {}
  }

  /**
* @api {post} /set-cve-status Set CVE ID Status
* @apiName Set CVE ID Status
* @apiGroup CVE
* @apiVersion  0.0.0
* @apiDescription 
* Use this method to update the status of assigned CVE IDs in the backend database.
 
* @apiHeader Signature RSA Signature.
* @apiParamExample {json} Request-Example With ID's:
content-type: application/json
{
"payload":
{
"ids":["CVE-2009-b5c29a6c-c7e2-4e2d-9680-e16d612d9e3f", "CVE-2009-9b30ace9-7ccc-4d15-8590-3c329279b7e4"],
"status": "Free|Rejected|Disputed|Populated|Published|Public|Reserved|Obsolete"
}, 
"userUUID": "246aef24-c31e-485e-ab03-133fa0cc3442"
}


*@apiSuccessExample Success-Response For ID's Search:
*HTTP/1.1 200 OK
{
  "Success": true
}

* @apiErrorExample Error-Response:
*HTTP/1.1 400 Bad Request
{
"error": "Invalid Status"
}

*/
  async setCveIdStatus(request, response, next) {
    const { payload } = request.body;
    const statusRegex = /^(Free|Rejected|Disputed|Populated|Public|Published|Reserved|Obsolete)$/g;
    try {
      if (payload.status) {
        if (!new RegExp(statusRegex).test(payload.status)) {
          response.status(403).json({ error: ERROR_MESSAGE[403] });
          return;
        }
      }
      var result = [];
      for (let i = 0; i < payload.ids.length; i++) {
        try {
          let newStatus = await dbOperations.editCveStatus(
            payload.ids[i],
            payload.status,
            request.userData.userCNAUUID
          );
          result.push(newStatus);
        } catch (err) {
          response.status(400).json({ error: ERROR_MESSAGE[400] });
        }
      }
      response.status(200).json({ Success: true });
    } catch (err) {
      console.log(err);
      response.status(400).json({ error: ERROR_MESSAGE[400] });
    }
  }
}
