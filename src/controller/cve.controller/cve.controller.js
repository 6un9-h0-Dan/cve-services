const Cve = require('../../model/cve')
const Org = require('../../model/org')
const logger = require('../../middleware/logger')

// Creates a new CVE only if it does not exists for the specified CVE ID in the request body. If it exists, it does not update the CVE.
async function submitCve (req, res) {
  const cve = req.body
  const cveId = cve.cve.CVE_data_meta.ID

  if (cve.cve_id.match(/^CVE-[0-9]{4}-[0-9]{4,}$/i)) {
    if (cve.cve_id.substring(4, 8) !== cve.cve_year) {
      return res.status(400).json({ message: 'Year ' + cve.cve_year + ' does not match ' + cve.cve_id + '\'s year of reservation in the JSON body.' })
    }
  } else {
    return res.status(400).json({ message: cve.cve_id + ' in the JSON body is not a valid CVE ID.' })
  }

  if (cve.cve_id !== cveId) {
    return res.status(400).json({ message: cve.cve_id + ' does not match ' + cveId + ' in the JSON body.' })
  }

  if (!cve.requested_by) {
    cve.requested_by = {
      cna: req.header('CVE-API-CNA'),
      user: req.header('CVE-API-SUBMITTER')
    }
  }

  if (!cve.owning_cna) {
    res.status(400).json({ message: 'The owning CNA of ' + cve.cve_id + ' must be provided.' })
  }

  if (cve.cve.CVE_data_meta.STATE.toUpperCase() === 'PUBLIC') {
    const uuid = cve.cve.containers.CNA.provider_data_meta.ID
    const result = await Org.findOne().byUUID(uuid)

    if (!result || result.short_name !== cve.owning_cna) {
      return res.status(400).json({ message: 'The owning CNA field of ' + cve.cve_id + ' does not match the owning CNA in the JSON body.' })
    }
  }

  // Find CVE in MongoDB
  Cve.findOne()
    .byCveId(cveId)
    .exec((err, result) => {
      if (err) {
        logger.warn('An error ocurred in MongoDB while trying to check if ' + cveId + ' already exists.')
        logger.error(err.stack)
        return res.status(500).send('Internal Server Error')
      }

      if (result) {
        logger.info(cveId + ' already exists.')
        return res.status(400).json({ message: cveId + ' already exists.' })
      }

      // Create CVE in MongoDB if it doesn't exist
      const newCve = new Cve(cve)

      // Find and Update CVE in MongoDB
      Cve.findOneAndReplace()
        .byCveId(cveId)
        .replaceOne(newCve)
        .setOptions({ upsert: true })
        .exec((err) => {
          if (err) {
            logger.warn('An error ocurred in MongoDB. ' + cveId + ' was not created in the database.')
            logger.error(err.stack)
            return res.status(500).json({ message: 'Failed to create ' + cveId + '.' })
          }

          logger.info(cveId + ' has been created.')
          return res.status(200).json({ message: cveId + ' has been created.' })
        })
    })
}

// Updates a CVE if one exists for the specified CVE ID
async function updateCve (req, res) {
  const cve = req.body
  const cveId = req.params.id

  if (!cveId.match(/^CVE-[0-9]{4}-[0-9]{4,}$/i)) {
    return res.status(400).json({ message: cve.cve_id + ' is not a valid CVE ID.' })
  }

  if (cveId !== cve.cve.CVE_data_meta.ID) {
    return res.status(400).json({ message: cveId + ' parameter does not match ' + cve.cve.CVE_data_meta.ID + ' in the JSON body.' })
  }

  if (!cve.cve_id) {
    cve.cve_id = cve.cve.CVE_data_meta.ID
  } else if (cve.cve_id !== cve.cve.CVE_data_meta.ID) {
    return res.status(400).json({ message: cve.cve_id + ' does not match ' + cve.cve.CVE_data_meta.ID + ' in the JSON body.' })
  }

  if (!cve.cve_year) {
    cve.cve_year = cve.cve_id.substring(4, 8)
  } else if (cve.cve_year !== cve.cve_id.substring(4, 8)) {
    return res.status(400).json({ message: 'Year ' + cve.cve_year + ' does not match ' + cve.cve_id + '\'s year of reservation in the JSON body.' })
  }

  const newCve = new Cve(cve)

  if (JSON.stringify(newCve.requested_by) === '{}') {
    const result = await Cve.findOne().byCveId(cveId)

    if (result) {
      newCve.requested_by = result.requested_by
    }
  }

  if (cve.owning_cna && cve.cve.CVE_data_meta.STATE.toUpperCase() === 'PUBLIC') {
    const uuid = cve.cve.containers.CNA.provider_data_meta.ID
    const result = await Org.findOne().byUUID(uuid)

    if (!result || result.short_name !== cve.owning_cna) {
      return res.status(400).json({ message: 'The owning CNA field of ' + cve.cve_id + ' does not match the owning CNA in the JSON body.' })
    }
  }

  // Find and Update CVE in MongoDB
  Cve.findOneAndReplace()
    .byCveId(cveId)
    .replaceOne(newCve)
    .exec((err, result) => {
      if (err) {
        logger.warn('An error ocurred in MongoDB. ' + cveId + ' was not updated in the database.')
        logger.error(err.stack)
        return res.status(500).send('Internal Server Error')
      }

      if (result.n === 0) {
        logger.info(cveId + ' does not exist.')
        return res.status(404).json({ message: cveId + ' does not exist.' })
      }

      logger.info(cveId + ' has been updated.')
      return res.status(200).json({ message: cveId + ' has been updated.' })
    })
}

module.exports = {
  CVE_SUBMIT: submitCve,
  CVE_UPDATE_SINGLE: updateCve
}
